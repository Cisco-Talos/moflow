Overview
--------

Piqi includes a data serialization system for OCaml. It can be used for
serializing OCaml values in 4 different formats: Google Protocol Buffers,
[JSON](/doc/encodings/#json), [XML](/doc/encodings/#xml) and [Piq](/doc/piq/).

A typical Piqi usage scenario involves the following steps:

**1. Build and install Piqi libraries for OCaml**
:   Piqi source code is distributed as a self-contained package with no external
    dependencies. Builds have been tested on all major platforms.

    The build instructions are available
    [here](https://github.com/alavrik/piqi/blob/dev/INSTALL.ocaml).

**2. Describe data structures using the Piqi data definition language**
:   The [Piqi](/doc/piqi/) data definition language can describe many OCaml
    types, both primitive and user-defined. This includes int, uint32 and
    uint64, floats, bools, strings, lists, arrays, records and polymorphic
    variants (including sub-variants).

    In addition to types supported by default, Piqi has a mechanism for adding
    support for arbitrary monomorphic OCaml types. It can be used, for example,
    to add support for OCaml's `nativeint` or `char`.

    Refer to the "Piqi to OCaml mapping" section below for details.

**3. Call the Piqi compiler to generate OCaml type definitions and serialization code**
:   See the "Piqi compilers for OCaml" section for detailed description.

**4. Use generated serializes/deserializers/printers in a user's program**
:   When multi-format serialization mode is used, one can specify a desired
    format at runtime.

**5. Link the user's program with the Piqi runtime library**
:   There are two Piqi runtime libraries: `piqirun` and `piqi`. The first one is
    for Protocol Buffers serialization. The second one is used for multi-format
    serialization. See the next section for more details.

The [Examples](#examples) section contains links to several sample OCaml
projects that use Piqi for data serialization and demonstrate usage of steps
2--5.

Piqi compilers and generated OCaml functions
--------------------------------------------

There are two Piqi compilers for OCaml: the basic `piqic ocaml` and
`piqic ocaml-ext`, which is the extended version of the first one.

### `piqic ocaml`

This Piqi compiler generates OCaml type definitions and code for Protocol
Buffers serialization.

`piqic ocaml` command takes a Piqi module `<dir path>/<file>.piqi` and produces
an output `<ocaml-module>.ml` file in the current working directory. By default,
`<ocaml-module>` is a valid OCaml module name equivalent to `<file>_piqi`.

For each specified, imported or included module `<m>.piqi`, the compiler tries
to load and automatically include `<m>.ocaml.piqi`. This mechanism is called
*Extension Modules*. It is described in detail in the Piqi language
[section](/doc/piqi#extensionmodules).

Output file name as well as output directory can be overridden using the `-o`
and `-C` command-line options. In addition, output `.ml` file can be
pretty-printed using CamlP4 (`--pp` flag).

Generated `<ocaml-module>.ml` file contains OCaml type definitions and functions
for serializing and deserializing OCaml values.

For each defined data type `<typename>`, `piqic ocaml` produces several
functions:

-   `parse_<typename>` -- for deserializing a value

-   `gen_<typename>` -- for serializing a value

And, optionally, when the `--gen-defaults` flag is specified:

-   `default_<typename>` -- returns the default value of this type

Compiled `.ml` files should be linked with `piqi.runtime` findlib package.

### `piqic ocaml-ext`

`piqic ocaml-ext` does everything what `piqic ocaml` does and, in addition,
generates code for serializing values in XML, JSON, Protobuf and Piq formats.

The additional module generated by this compiler is named
`<ocaml-module>_piqi_ext.ml`.

The `parse_<typename>` and `gen_<typename>` functions from this module take an
additional parameter specifying which serialization format to use:

    type input_format = [ `piq | `json | `xml | `pb | `wire ]

    type output_format = [ input_format | `json_pretty | `xml_pretty ]

`piqic ocaml-ext` also generates the following functions:

-   `print_<typename>` -- for printing a value to `stdout` in Piq format

Each `parse_<typename>` and `gen_<typename>` function accepts an optional
`?opts` argument representing a set of serialization options that can be
constructed using `Piqirun_ext.make_options`:

    (* Construct serialization options to be passed as an optional argument to
     * gen_<typename> and parse_<typename> functions. Available options:
     *
     * pretty_print
     *
     *      Pretty-print generated JSON and XML output (default = true)
     *
     * json_omit_null_fields
     *
     *      Omit missing optional and empty repeated fields from JSON
     *      output instead of representing them as {"field_name": null} and
     *      {"field_name", []} JSON fields (default = true)
     *
     * use_strict_parsing
     *
     *      Treat unknown and duplicate fields as errors when parsing JSON,
     *      XML and Piq formats (default = false)
     *)
    val make_options:
            ?pretty_print:bool ->
            ?json_omit_null_fields:bool ->
            ?use_strict_parsing:bool ->
            unit -> options

Compiled `.ml` files should be linked with `piqi.lib` findlib package.

### Command-line parameters

Both compilers accept the following command-line parameters.

-   `--normalize true|false` -- convert "CamelCase"-style identifiers from the
    original type spec into "camel-case" OCaml names (names will be capitalized
    when appropriate). When the argument is `false`, the original identifiers
    will be lowercased without performing any additional transformations, e.g.
    "CamelCase" turns into "camelCase". The default value is `true`.

-   `--gen-defaults` -- generate default constructors for each generated data
    type. The constructors are OCaml functions named as `default_<type-name>()`.

-   `-C <dir>` -- specify output directory for the generated `.ml` files.

-   `--pp` -- pretty-print output `.ml` files using CamlP4 (camlp4o).

-   `--leave-tmp-files` -- don't delete temporary files created during command
    execution. This flag is helpful for debugging "piqi ocaml" compilers.

There are some other command-line parameters that are not specific to "piqic
ocaml" compilers. They are documented in the [Piqi command-line
tools](/doc/tools/) section.

Piqi to OCaml mapping
---------------------

The following sections describe how different Piqi constructs such as modules
and types are mapped to OCaml.

### Modules

The name of OCaml module is derived from Piqi module name unless overridden by
`ocaml-module` top-level field.

If Piqi module name is "example.com/foo/bar", then "Bar" (the last part of the
Piqi module name) will be used as the OCaml module name. It is possible to
override such default name assignment by specifying
`.ocaml-module "<OtherName>"` in the Piqi module.

#### Includes

Piqi takes all "include" directives of a Piqi module, resolves them internally
and produces a compound Piqi module which is then mapped to the resulting OCaml
module.

#### Imports

Piqi "import" directives are mapped to OCaml modules in the following way.

Imports that do not specify local module name are used directly as a part of
Ocaml type names for imported types. For example,

    .import [ .module example.com/foo/bar ]
    .variant [
        .name v
        .option [
            .name o
            .type bar/t
        ]
    ]

is mapped to:

    type v = [ `o of Bar.t ]

Imports that do have imported module name result in generation of module alias.
For example,

    .import [ .module example.com/foo/bar .name fum ]

is mapped to:

    module Fum = Bar

### Primitive types

The table below represents correspondence between Piqi primitive types and OCaml
types.

(Mapping between Piqi and Protocol Buffers primitive type is documented
[here](/doc/protobuf/#primitivetypes)).

  Piqi type(s)                                                    OCaml type   Protobuf type(s)
  ----------------------------------------------------------      ------------ ------------------------------------------
  bool                                                            bool         bool
  string                                                          string       string
  binary                                                          string       bytes
  int, uint                                                       int          sint32, uint32
  int32, uint32, int32-fixed, uint32-fixed, protobuf-int32        int32        sint32, uint32, sfixed32, fixed32, int32
  int64, uint64, int64-fixed, uint64-fixed, protobuf-int64        int64        sint64, uint64, sfixed64, fixed64, int64
  float, float64, float32                                         float        double, float

If there is a need to add serialization support for other OCaml types, such as
`char`, `nativeint` or `bigint`, refer to [Custom OCaml
types](#customocamltypes) section which describes a method for mapping custom
OCaml types to Piqi types.

### User-defined types

-   Type names

    Each user-defined type is identified by its name. Piqi type names are
    converted to OCaml type name using the following rule.

    By default, Piqi identifiers are normalized and all hyphen characters are
    replaced by underscores. Normalization means converting "CamelCase" to
    "camel-case".

    If `--normalize false` command-line option is specified, then instead of
    full normalization, the first letter of the type name is uncapitalized.

    Sometimes it is necessary to override this rule and specify a custom OCaml
    name for a type. For example, when a Piqi type name conflicts with one of
    OCaml keywords. In such case, custom OCaml name can be specified using
    `.ocaml-name "<ocaml name>"` field next to the original `.name <name>`
    entry. (This feature also works for field names, option names, import names
    and function names).

    For those Piqi fields or options that do not specify names, OCaml name is
    derived from the name of the Piqi type for that field.

-   Records are mapped to OCaml records.

    As a workaround for OCaml's flat namespace for record labels, Piqi puts each
    record definition in a separate OCaml module. The module's name is set to
    the record's name.

    For example, Piqi record

        .record [
            .name r
            .field [ .name a .type int ]
        ]

    will be mapped to the following OCaml module:

        module R =
          struct
            record t = { mutable a : int }
          end

    (In fact, the real example would be more verbose, because Piqi uses
    recursive modules which require signature definition in addition to module
    implementation.)

    To make working with records defined in separate modules easier, Piqi
    provides a set of useful CamlP4 macros. Using one the macros, record
    creation would look like:

        R#{ a = 10; b = ... }

    instead of

        { R.a = 10; b = ... }

    **required** Piqi fields are mapped directly to OCaml record fields.

    **optional** Piqi fields of type `<t>` are mapped to fields with type
    `<t> option`.

    **optional** Piqi fields with specified default values are mapped
    to OCaml fields the same way as required fields unless
    `.ocaml-optional` flag is specified in which case the field will
    have type `<t> option`.

    If a value of such field is not defined in serialized object, it
    will be set to the default value during deserialization. Also, see
    [Limitations](#limitations) section below.

    **optional** Piqi fields without type (i.e. *flags*) are mapped to `bool`
    OCaml fields. The value of the field will be set to `true` if the flag is
    present in the record.

    **repeated** Piqi fields of type `<t>` are mapped to fields with type
    `<t> list`. It is possible to use OCaml `array` instead of `list` by
    specifying an additional `.ocaml-array` property in the field definition.

-   Enums and Variants are mapped directly to OCaml polymorphic variants.

    For example, these definitions:

        .enum [
            .name e
            .option [ .name a ]
            .option [ .name b ]
        ]
        .varint [
            .name v
            .option [ .type e ]
            .option [ .name f ]
            .option [ .name i .type int ]
        ]

    are mapped to:

        type e = [ `a | `b ]
        type v = [ e | `f | `i of int ]

-   List type is mapped OCaml list type.

    For example,

        .list [
            .name l
            .type x
        ]

    is mapped to:

        type l = x list

    It is possible to use OCaml `array` instead of `list` by specifying an
    additional `.ocaml-array` property in the field definition, e.g.:

        .list [
            .name l
            .type x
            .ocaml-array
        ]

    is mapped to:

        type l = x array

-   Aliases are mapped to OCaml type definitions.

    For example,

        .alias [
            .name a
            .type x
        ]

    is mapped to:

        type a = x

### Custom OCaml types

Piqi provides a way to define mappings between custom OCaml types and Piqi
types. Such mechanism is useful when there is a need to automatically serialize
an OCaml type using some relevant Piqi type, but there is no way to describe the
desired OCaml type using Piqi.

Inability to use Piqi to define an OCaml type would mean that the OCaml type is
either a primitive built-in or abstract type (e.g. `char` or `bigint`), or some
higher-order parametric type (e.g. `string Map.Make(String).t`).

The mapping mechanism works as follows. Suppose we need to add support for
serializing OCaml's `char` type as Piqi `int`. This can be done in a few steps:

1.  First, define Piqi alias for such mapping:

        .alias [
            % the new Piqi type
            .name char

            % the original Piqi type
            .type int

            % OCaml type (should be point to the namespace with the mapping
            % implementation -- see below)
            .ocaml-type "Piqirun_custom.char"

            % optionally, define a custom OCaml name for this type
            % .ocaml-name "char"
        ]

2.  Second, implement runtime functions for mapping the custom OCaml type to the
    Piqi type:

    In module `piqirun_custom.ml`:

        type char = Char.t

        let char_of_int: int -> char = Char.chr
        let char_to_int: char -> int = Char.code

After that, the only thing that's left is to compile and link
`piqirun_custom.ml` with your OCaml program.

More examples of how to map various OCaml types to Piqi types can be found
[here](http://github.com/alavrik/piqi/tree/dev/examples/ocaml-custom-types/).

### Piqi extensions

There is no direct notion of Piqi extensions in OCaml: Piqi extensions are all
resolved and applied to Piqi types before generating OCaml types from them.

Examples
--------

-   The first example is based on the "addressbook" example from Protocol
    Buffers source distribution. It contains OCaml implementation of two simple
    programs: for adding a record to an addressbook and for listing addressbook
    contents. The programs implement the same functionality as programs from the
    Protocol Buffers
    [examples](http://protobuf.googlecode.com/svn/trunk/examples/) written in
    C++, Java and Python.

    [examples/ocaml](http://github.com/alavrik/piqi/tree/dev/examples/ocaml/)

-   Data serialization in XML, JSON and Piq formats using `piqic ocaml-ext`

    In the same directory, there is the `io_json_xml_pb.ml` OCaml module. It
    reads and writes the addressbook data structure from the previous example in
    a variety of formats using functions generated by `piqic ocaml-ext` Piqi
    compiler.

-   Piqi implementation itself makes another example

    Piqi is implemented in OCaml but the Piqi language and Piqi internal
    representation are defined in a series of Piqi specifications which are
    mapped to OCaml types.

    [Piqi self-specifications](http://github.com/alavrik/piqi/tree/dev/piqi/)

-   More complicated example demonstrating complex types and module imports

    Piq interface compiler for OCaml (`piqic ocaml`) produces OCaml parsers and
    generators from Piqi self-specification
    ([piqi.piqi](/self-definition/#piqi_piqi)). After that, an OCaml
    program reads (and writes back) Piqi self-specification represented as a
    binary object.

    [tests/ocaml\_piqi](http://github.com/alavrik/piqi/tree/dev/tests/ocaml_piqi/)

-   Examples of serializing custom OCaml types using Piqi

    [examples/ocaml-custom-types](http://github.com/alavrik/piqi/tree/dev/examples/ocaml-custom-types/)

-   Example of using [Piq](/doc/piq) as a config file format

    [examples/ocaml-piq-config](http://github.com/alavrik/piqi/tree/dev/examples/ocaml-piq-config/)

Limitations
-----------

The way how Piqi records are mapped to OCaml records introduces several
limitations.

-   Limited support for defaults.

    There is no way to tell if the value of an optional field came from the
    original serialized object or it is the default value.

    There is no way to skip default values when serializing an optional field
    since concrete value for that field must be always present in the OCaml
    record. This behavior may be optimized in the future, but at the moment, it
    will produce somewhat excessive serialized representation for optional
    fields with default values.

-   No other dynamic properties.

    For example, in Protocol Buffers, there is a way to get the count of
    repeated fields and access them using field index. (Update: now it is
    possible to do that by specifying to use OCaml arrays instead of lists for
    repeated fields).

An alternative method would use OCaml objects for representing records,
providing "setters" and "getters" for object fields. Such method is used, for
example, in Protocol Buffers mappings for C++, Java and Python languages.

Although it is possible (and even easier) to implement this method for OCaml,
the current method has several advantages:

-   Native syntax for record construction and field access.

-   Pattern matching works with records.

-   No runtime overhead of calling constructors, setters and getters.

Other limitations:

-   Piqi runtime library hasn't been heavily optimized for performance yet.

Supported OCaml and Protocol Buffers versions
---------------------------------------------

Piqi works with OCaml \>= 3.11 and Protocol Buffers \>= 2.3.0
