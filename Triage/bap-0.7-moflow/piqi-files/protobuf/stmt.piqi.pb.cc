// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "stmt.piqi.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* program_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  program_reflection_ = NULL;
const ::google::protobuf::Descriptor* stmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  stmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* move_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  move_reflection_ = NULL;
const ::google::protobuf::Descriptor* jmp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  jmp_reflection_ = NULL;
const ::google::protobuf::Descriptor* cjmp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  cjmp_reflection_ = NULL;
const ::google::protobuf::Descriptor* label_stmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  label_stmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* halt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  halt_reflection_ = NULL;
const ::google::protobuf::Descriptor* assert_stmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  assert_stmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* assume_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  assume_reflection_ = NULL;
const ::google::protobuf::Descriptor* comment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  comment_reflection_ = NULL;
const ::google::protobuf::Descriptor* special_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  special_reflection_ = NULL;
const ::google::protobuf::Descriptor* typ_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  typ_reflection_ = NULL;
const ::google::protobuf::Descriptor* tmem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tmem_reflection_ = NULL;
const ::google::protobuf::Descriptor* array_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  array_reflection_ = NULL;
const ::google::protobuf::Descriptor* label_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  label_reflection_ = NULL;
const ::google::protobuf::Descriptor* var_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  var_reflection_ = NULL;
const ::google::protobuf::Descriptor* attribute_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  attribute_reflection_ = NULL;
const ::google::protobuf::Descriptor* attributes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  attributes_reflection_ = NULL;
const ::google::protobuf::Descriptor* liveout_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  liveout_reflection_ = NULL;
const ::google::protobuf::Descriptor* synthetic_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  synthetic_reflection_ = NULL;
const ::google::protobuf::Descriptor* operand_info_specific_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  operand_info_specific_reflection_ = NULL;
const ::google::protobuf::Descriptor* reg_operand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  reg_operand_reflection_ = NULL;
const ::google::protobuf::Descriptor* operand_usage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  operand_usage_reflection_ = NULL;
const ::google::protobuf::Descriptor* mem_operand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  mem_operand_reflection_ = NULL;
const ::google::protobuf::Descriptor* taint_info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  taint_info_reflection_ = NULL;
const ::google::protobuf::Descriptor* context_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  context_reflection_ = NULL;
const ::google::protobuf::Descriptor* exp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  exp_reflection_ = NULL;
const ::google::protobuf::Descriptor* load_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  load_reflection_ = NULL;
const ::google::protobuf::Descriptor* store_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  store_reflection_ = NULL;
const ::google::protobuf::Descriptor* binop_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  binop_reflection_ = NULL;
const ::google::protobuf::Descriptor* unop_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  unop_reflection_ = NULL;
const ::google::protobuf::Descriptor* inte_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  inte_reflection_ = NULL;
const ::google::protobuf::Descriptor* cast_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  cast_reflection_ = NULL;
const ::google::protobuf::Descriptor* let_exp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  let_exp_reflection_ = NULL;
const ::google::protobuf::Descriptor* unknown_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  unknown_reflection_ = NULL;
const ::google::protobuf::Descriptor* ite_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ite_reflection_ = NULL;
const ::google::protobuf::Descriptor* extract_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  extract_reflection_ = NULL;
const ::google::protobuf::Descriptor* concat_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  concat_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* cast_type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* binop_type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* unop_type_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_stmt_2epiqi_2eproto() {
  protobuf_AddDesc_stmt_2epiqi_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "stmt.piqi.proto");
  GOOGLE_CHECK(file != NULL);
  program_descriptor_ = file->message_type(0);
  static const int program_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(program, elem_),
  };
  program_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      program_descriptor_,
      program::default_instance_,
      program_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(program, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(program, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(program));
  stmt_descriptor_ = file->message_type(1);
  static const int stmt_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, move_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, jmp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, cjmp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, label_stmt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, halt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, assert_stmt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, assume_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, comment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, special_),
  };
  stmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      stmt_descriptor_,
      stmt::default_instance_,
      stmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(stmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(stmt));
  move_descriptor_ = file->message_type(2);
  static const int move_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(move, var_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(move, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(move, attributes_),
  };
  move_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      move_descriptor_,
      move::default_instance_,
      move_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(move, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(move, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(move));
  jmp_descriptor_ = file->message_type(3);
  static const int jmp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(jmp, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(jmp, attributes_),
  };
  jmp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      jmp_descriptor_,
      jmp::default_instance_,
      jmp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(jmp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(jmp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(jmp));
  cjmp_descriptor_ = file->message_type(4);
  static const int cjmp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cjmp, cond_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cjmp, iftrue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cjmp, iffalse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cjmp, attributes_),
  };
  cjmp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      cjmp_descriptor_,
      cjmp::default_instance_,
      cjmp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cjmp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cjmp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(cjmp));
  label_stmt_descriptor_ = file->message_type(5);
  static const int label_stmt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(label_stmt, label_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(label_stmt, attributes_),
  };
  label_stmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      label_stmt_descriptor_,
      label_stmt::default_instance_,
      label_stmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(label_stmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(label_stmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(label_stmt));
  halt_descriptor_ = file->message_type(6);
  static const int halt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(halt, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(halt, attributes_),
  };
  halt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      halt_descriptor_,
      halt::default_instance_,
      halt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(halt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(halt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(halt));
  assert_stmt_descriptor_ = file->message_type(7);
  static const int assert_stmt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(assert_stmt, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(assert_stmt, attributes_),
  };
  assert_stmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      assert_stmt_descriptor_,
      assert_stmt::default_instance_,
      assert_stmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(assert_stmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(assert_stmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(assert_stmt));
  assume_descriptor_ = file->message_type(8);
  static const int assume_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(assume, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(assume, attributes_),
  };
  assume_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      assume_descriptor_,
      assume::default_instance_,
      assume_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(assume, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(assume, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(assume));
  comment_descriptor_ = file->message_type(9);
  static const int comment_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(comment, string_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(comment, attributes_),
  };
  comment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      comment_descriptor_,
      comment::default_instance_,
      comment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(comment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(comment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(comment));
  special_descriptor_ = file->message_type(10);
  static const int special_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(special, string_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(special, attributes_),
  };
  special_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      special_descriptor_,
      special::default_instance_,
      special_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(special, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(special, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(special));
  typ_descriptor_ = file->message_type(11);
  static const int typ_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(typ, reg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(typ, tmem_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(typ, array_),
  };
  typ_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      typ_descriptor_,
      typ::default_instance_,
      typ_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(typ, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(typ, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(typ));
  tmem_descriptor_ = file->message_type(12);
  static const int tmem_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tmem, index_type_),
  };
  tmem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tmem_descriptor_,
      tmem::default_instance_,
      tmem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tmem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tmem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tmem));
  array_descriptor_ = file->message_type(13);
  static const int array_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(array, index_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(array, element_type_),
  };
  array_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      array_descriptor_,
      array::default_instance_,
      array_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(array, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(array, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(array));
  label_descriptor_ = file->message_type(14);
  static const int label_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(label, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(label, addr_),
  };
  label_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      label_descriptor_,
      label::default_instance_,
      label_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(label, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(label, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(label));
  var_descriptor_ = file->message_type(15);
  static const int var_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(var, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(var, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(var, typ_),
  };
  var_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      var_descriptor_,
      var::default_instance_,
      var_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(var, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(var, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(var));
  attribute_descriptor_ = file->message_type(16);
  static const int attribute_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, asm__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, liveout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, strattr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, context_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, thread_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, synthetic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, other_),
  };
  attribute_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      attribute_descriptor_,
      attribute::default_instance_,
      attribute_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attribute, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(attribute));
  attributes_descriptor_ = file->message_type(17);
  static const int attributes_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attributes, elem_),
  };
  attributes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      attributes_descriptor_,
      attributes::default_instance_,
      attributes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attributes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(attributes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(attributes));
  liveout_descriptor_ = file->message_type(18);
  static const int liveout_offsets_[1] = {
  };
  liveout_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      liveout_descriptor_,
      liveout::default_instance_,
      liveout_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(liveout, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(liveout, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(liveout));
  synthetic_descriptor_ = file->message_type(19);
  static const int synthetic_offsets_[1] = {
  };
  synthetic_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      synthetic_descriptor_,
      synthetic::default_instance_,
      synthetic_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(synthetic, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(synthetic, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(synthetic));
  operand_info_specific_descriptor_ = file->message_type(20);
  static const int operand_info_specific_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_info_specific, mem_operand_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_info_specific, reg_operand_),
  };
  operand_info_specific_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      operand_info_specific_descriptor_,
      operand_info_specific::default_instance_,
      operand_info_specific_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_info_specific, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_info_specific, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(operand_info_specific));
  reg_operand_descriptor_ = file->message_type(21);
  static const int reg_operand_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reg_operand, name_),
  };
  reg_operand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      reg_operand_descriptor_,
      reg_operand::default_instance_,
      reg_operand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reg_operand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(reg_operand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(reg_operand));
  operand_usage_descriptor_ = file->message_type(22);
  static const int operand_usage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_usage, read_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_usage, written_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_usage, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_usage, base_),
  };
  operand_usage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      operand_usage_descriptor_,
      operand_usage::default_instance_,
      operand_usage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_usage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(operand_usage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(operand_usage));
  mem_operand_descriptor_ = file->message_type(23);
  static const int mem_operand_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mem_operand, address_),
  };
  mem_operand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      mem_operand_descriptor_,
      mem_operand::default_instance_,
      mem_operand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mem_operand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(mem_operand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(mem_operand));
  taint_info_descriptor_ = file->message_type(24);
  static const int taint_info_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(taint_info, no_taint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(taint_info, taint_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(taint_info, taint_multiple_),
  };
  taint_info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      taint_info_descriptor_,
      taint_info::default_instance_,
      taint_info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(taint_info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(taint_info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(taint_info));
  context_descriptor_ = file->message_type(25);
  static const int context_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(context, operand_info_specific_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(context, bit_length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(context, operand_usage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(context, taint_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(context, value_),
  };
  context_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      context_descriptor_,
      context::default_instance_,
      context_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(context, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(context, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(context));
  exp_descriptor_ = file->message_type(26);
  static const int exp_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, load_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, store_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, binop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, unop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, var_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, lab_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, inte_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, cast_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, let_exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, unknown_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, ite_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, extract_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, concat_),
  };
  exp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      exp_descriptor_,
      exp::default_instance_,
      exp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(exp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(exp));
  load_descriptor_ = file->message_type(27);
  static const int load_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(load, memory_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(load, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(load, endian_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(load, typ_),
  };
  load_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      load_descriptor_,
      load::default_instance_,
      load_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(load, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(load, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(load));
  store_descriptor_ = file->message_type(28);
  static const int store_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(store, memory_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(store, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(store, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(store, endian_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(store, typ_),
  };
  store_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      store_descriptor_,
      store::default_instance_,
      store_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(store, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(store, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(store));
  binop_descriptor_ = file->message_type(29);
  static const int binop_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(binop, binop_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(binop, lexp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(binop, rexp_),
  };
  binop_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      binop_descriptor_,
      binop::default_instance_,
      binop_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(binop, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(binop, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(binop));
  unop_descriptor_ = file->message_type(30);
  static const int unop_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unop, unop_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unop, exp_),
  };
  unop_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      unop_descriptor_,
      unop::default_instance_,
      unop_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unop, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unop, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(unop));
  inte_descriptor_ = file->message_type(31);
  static const int inte_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(inte, int__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(inte, typ_),
  };
  inte_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      inte_descriptor_,
      inte::default_instance_,
      inte_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(inte, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(inte, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(inte));
  cast_descriptor_ = file->message_type(32);
  static const int cast_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cast, cast_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cast, new_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cast, exp_),
  };
  cast_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      cast_descriptor_,
      cast::default_instance_,
      cast_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cast, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cast, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(cast));
  let_exp_descriptor_ = file->message_type(33);
  static const int let_exp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(let_exp, var_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(let_exp, e1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(let_exp, e2_),
  };
  let_exp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      let_exp_descriptor_,
      let_exp::default_instance_,
      let_exp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(let_exp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(let_exp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(let_exp));
  unknown_descriptor_ = file->message_type(34);
  static const int unknown_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unknown, string_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unknown, typ_),
  };
  unknown_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      unknown_descriptor_,
      unknown::default_instance_,
      unknown_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unknown, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unknown, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(unknown));
  ite_descriptor_ = file->message_type(35);
  static const int ite_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ite, condition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ite, iftrue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ite, iffalse_),
  };
  ite_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ite_descriptor_,
      ite::default_instance_,
      ite_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ite, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ite, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ite));
  extract_descriptor_ = file->message_type(36);
  static const int extract_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(extract, hbit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(extract, lbit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(extract, exp_),
  };
  extract_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      extract_descriptor_,
      extract::default_instance_,
      extract_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(extract, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(extract, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(extract));
  concat_descriptor_ = file->message_type(37);
  static const int concat_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(concat, le_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(concat, re_),
  };
  concat_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      concat_descriptor_,
      concat::default_instance_,
      concat_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(concat, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(concat, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(concat));
  cast_type_descriptor_ = file->enum_type(0);
  binop_type_descriptor_ = file->enum_type(1);
  unop_type_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_stmt_2epiqi_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    program_descriptor_, &program::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    stmt_descriptor_, &stmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    move_descriptor_, &move::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    jmp_descriptor_, &jmp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    cjmp_descriptor_, &cjmp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    label_stmt_descriptor_, &label_stmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    halt_descriptor_, &halt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    assert_stmt_descriptor_, &assert_stmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    assume_descriptor_, &assume::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    comment_descriptor_, &comment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    special_descriptor_, &special::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    typ_descriptor_, &typ::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tmem_descriptor_, &tmem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    array_descriptor_, &array::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    label_descriptor_, &label::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    var_descriptor_, &var::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    attribute_descriptor_, &attribute::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    attributes_descriptor_, &attributes::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    liveout_descriptor_, &liveout::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    synthetic_descriptor_, &synthetic::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    operand_info_specific_descriptor_, &operand_info_specific::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    reg_operand_descriptor_, &reg_operand::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    operand_usage_descriptor_, &operand_usage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    mem_operand_descriptor_, &mem_operand::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    taint_info_descriptor_, &taint_info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    context_descriptor_, &context::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    exp_descriptor_, &exp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    load_descriptor_, &load::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    store_descriptor_, &store::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    binop_descriptor_, &binop::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    unop_descriptor_, &unop::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    inte_descriptor_, &inte::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    cast_descriptor_, &cast::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    let_exp_descriptor_, &let_exp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    unknown_descriptor_, &unknown::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ite_descriptor_, &ite::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    extract_descriptor_, &extract::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    concat_descriptor_, &concat::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_stmt_2epiqi_2eproto() {
  delete program::default_instance_;
  delete program_reflection_;
  delete stmt::default_instance_;
  delete stmt_reflection_;
  delete move::default_instance_;
  delete move_reflection_;
  delete jmp::default_instance_;
  delete jmp_reflection_;
  delete cjmp::default_instance_;
  delete cjmp_reflection_;
  delete label_stmt::default_instance_;
  delete label_stmt_reflection_;
  delete halt::default_instance_;
  delete halt_reflection_;
  delete assert_stmt::default_instance_;
  delete assert_stmt_reflection_;
  delete assume::default_instance_;
  delete assume_reflection_;
  delete comment::default_instance_;
  delete comment_reflection_;
  delete special::default_instance_;
  delete special_reflection_;
  delete typ::default_instance_;
  delete typ_reflection_;
  delete tmem::default_instance_;
  delete tmem_reflection_;
  delete array::default_instance_;
  delete array_reflection_;
  delete label::default_instance_;
  delete label_reflection_;
  delete var::default_instance_;
  delete var_reflection_;
  delete attribute::default_instance_;
  delete attribute_reflection_;
  delete attributes::default_instance_;
  delete attributes_reflection_;
  delete liveout::default_instance_;
  delete liveout_reflection_;
  delete synthetic::default_instance_;
  delete synthetic_reflection_;
  delete operand_info_specific::default_instance_;
  delete operand_info_specific_reflection_;
  delete reg_operand::default_instance_;
  delete reg_operand_reflection_;
  delete operand_usage::default_instance_;
  delete operand_usage_reflection_;
  delete mem_operand::default_instance_;
  delete mem_operand_reflection_;
  delete taint_info::default_instance_;
  delete taint_info_reflection_;
  delete context::default_instance_;
  delete context_reflection_;
  delete exp::default_instance_;
  delete exp_reflection_;
  delete load::default_instance_;
  delete load_reflection_;
  delete store::default_instance_;
  delete store_reflection_;
  delete binop::default_instance_;
  delete binop_reflection_;
  delete unop::default_instance_;
  delete unop_reflection_;
  delete inte::default_instance_;
  delete inte_reflection_;
  delete cast::default_instance_;
  delete cast_reflection_;
  delete let_exp::default_instance_;
  delete let_exp_reflection_;
  delete unknown::default_instance_;
  delete unknown_reflection_;
  delete ite::default_instance_;
  delete ite_reflection_;
  delete extract::default_instance_;
  delete extract_reflection_;
  delete concat::default_instance_;
  delete concat_reflection_;
}

void protobuf_AddDesc_stmt_2epiqi_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017stmt.piqi.proto\"\036\n\007program\022\023\n\004elem\030\001 \003"
    "(\0132\005.stmt\"\353\001\n\004stmt\022\023\n\004move\030\001 \001(\0132\005.move\022"
    "\021\n\003jmp\030\002 \001(\0132\004.jmp\022\023\n\004cjmp\030\003 \001(\0132\005.cjmp\022"
    "\037\n\nlabel_stmt\030\004 \001(\0132\013.label_stmt\022\023\n\004halt"
    "\030\005 \001(\0132\005.halt\022!\n\013assert_stmt\030\006 \001(\0132\014.ass"
    "ert_stmt\022\027\n\006assume\030\007 \001(\0132\007.assume\022\031\n\007com"
    "ment\030\010 \001(\0132\010.comment\022\031\n\007special\030\t \001(\0132\010."
    "special\"M\n\004move\022\021\n\003var\030\001 \002(\0132\004.var\022\021\n\003ex"
    "p\030\002 \002(\0132\004.exp\022\037\n\nattributes\030\003 \002(\0132\013.attr"
    "ibutes\"9\n\003jmp\022\021\n\003exp\030\001 \002(\0132\004.exp\022\037\n\nattr"
    "ibutes\030\002 \002(\0132\013.attributes\"h\n\004cjmp\022\022\n\004con"
    "d\030\001 \002(\0132\004.exp\022\024\n\006iftrue\030\002 \002(\0132\004.exp\022\025\n\007i"
    "ffalse\030\003 \002(\0132\004.exp\022\037\n\nattributes\030\004 \002(\0132\013"
    ".attributes\"D\n\nlabel_stmt\022\025\n\005label\030\001 \002(\013"
    "2\006.label\022\037\n\nattributes\030\002 \002(\0132\013.attribute"
    "s\":\n\004halt\022\021\n\003exp\030\001 \002(\0132\004.exp\022\037\n\nattribut"
    "es\030\002 \002(\0132\013.attributes\"A\n\013assert_stmt\022\021\n\003"
    "exp\030\001 \002(\0132\004.exp\022\037\n\nattributes\030\002 \002(\0132\013.at"
    "tributes\"<\n\006assume\022\021\n\003exp\030\001 \002(\0132\004.exp\022\037\n"
    "\nattributes\030\002 \002(\0132\013.attributes\":\n\007commen"
    "t\022\016\n\006string\030\001 \002(\t\022\037\n\nattributes\030\002 \002(\0132\013."
    "attributes\":\n\007special\022\016\n\006string\030\001 \002(\t\022\037\n"
    "\nattributes\030\002 \002(\0132\013.attributes\">\n\003typ\022\013\n"
    "\003reg\030\001 \001(\021\022\023\n\004tmem\030\002 \001(\0132\005.tmem\022\025\n\005array"
    "\030\003 \001(\0132\006.array\" \n\004tmem\022\030\n\nindex_type\030\001 \002"
    "(\0132\004.typ\"=\n\005array\022\030\n\nindex_type\030\001 \002(\0132\004."
    "typ\022\032\n\014element_type\030\002 \002(\0132\004.typ\"#\n\005label"
    "\022\014\n\004name\030\001 \001(\t\022\014\n\004addr\030\002 \001(\022\"2\n\003var\022\014\n\004n"
    "ame\030\001 \002(\t\022\n\n\002id\030\002 \002(\021\022\021\n\003typ\030\003 \002(\0132\004.typ"
    "\"\261\001\n\tattribute\022\013\n\003asm\030\001 \001(\t\022\017\n\007address\030\002"
    " \001(\022\022\031\n\007liveout\030\003 \001(\0132\010.liveout\022\017\n\007strat"
    "tr\030\004 \001(\t\022\031\n\007context\030\005 \001(\0132\010.context\022\021\n\tt"
    "hread_id\030\006 \001(\004\022\035\n\tsynthetic\030\007 \001(\0132\n.synt"
    "hetic\022\r\n\005other\030\010 \001(\t\"&\n\nattributes\022\030\n\004el"
    "em\030\001 \003(\0132\n.attribute\"\t\n\007liveout\"\013\n\tsynth"
    "etic\"]\n\025operand_info_specific\022!\n\013mem_ope"
    "rand\030\001 \001(\0132\014.mem_operand\022!\n\013reg_operand\030"
    "\002 \001(\0132\014.reg_operand\"\033\n\013reg_operand\022\014\n\004na"
    "me\030\001 \002(\t\"K\n\roperand_usage\022\014\n\004read\030\001 \002(\010\022"
    "\017\n\007written\030\002 \002(\010\022\r\n\005index\030\003 \002(\010\022\014\n\004base\030"
    "\004 \002(\010\"\036\n\013mem_operand\022\017\n\007address\030\001 \002(\022\"H\n"
    "\ntaint_info\022\020\n\010no_taint\030\001 \001(\010\022\020\n\010taint_i"
    "d\030\002 \001(\004\022\026\n\016taint_multiple\030\003 \001(\010\"\253\001\n\007cont"
    "ext\0225\n\025operand_info_specific\030\001 \002(\0132\026.ope"
    "rand_info_specific\022\022\n\nbit_length\030\002 \002(\021\022%"
    "\n\roperand_usage\030\003 \002(\0132\016.operand_usage\022\037\n"
    "\ntaint_info\030\004 \002(\0132\013.taint_info\022\r\n\005value\030"
    "\005 \002(\t\"\244\002\n\003exp\022\023\n\004load\030\001 \001(\0132\005.load\022\025\n\005st"
    "ore\030\002 \001(\0132\006.store\022\025\n\005binop\030\003 \001(\0132\006.binop"
    "\022\023\n\004unop\030\004 \001(\0132\005.unop\022\021\n\003var\030\005 \001(\0132\004.var"
    "\022\013\n\003lab\030\006 \001(\t\022\023\n\004inte\030\007 \001(\0132\005.inte\022\023\n\004ca"
    "st\030\010 \001(\0132\005.cast\022\031\n\007let_exp\030\t \001(\0132\010.let_e"
    "xp\022\031\n\007unknown\030\n \001(\0132\010.unknown\022\021\n\003ite\030\013 \001"
    "(\0132\004.ite\022\031\n\007extract\030\014 \001(\0132\010.extract\022\027\n\006c"
    "oncat\030\r \001(\0132\007.concat\"\\\n\004load\022\024\n\006memory\030\001"
    " \002(\0132\004.exp\022\025\n\007address\030\002 \002(\0132\004.exp\022\024\n\006end"
    "ian\030\003 \002(\0132\004.exp\022\021\n\003typ\030\004 \002(\0132\004.typ\"r\n\005st"
    "ore\022\024\n\006memory\030\001 \002(\0132\004.exp\022\025\n\007address\030\002 \002"
    "(\0132\004.exp\022\023\n\005value\030\003 \002(\0132\004.exp\022\024\n\006endian\030"
    "\004 \002(\0132\004.exp\022\021\n\003typ\030\005 \002(\0132\004.typ\"P\n\005binop\022"
    "\037\n\nbinop_type\030\001 \002(\0162\013.binop_type\022\022\n\004lexp"
    "\030\002 \002(\0132\004.exp\022\022\n\004rexp\030\003 \002(\0132\004.exp\"8\n\004unop"
    "\022\035\n\tunop_type\030\001 \002(\0162\n.unop_type\022\021\n\003exp\030\002"
    " \002(\0132\004.exp\"&\n\004inte\022\013\n\003int\030\001 \002(\t\022\021\n\003typ\030\002"
    " \002(\0132\004.typ\"P\n\004cast\022\035\n\tcast_type\030\001 \002(\0162\n."
    "cast_type\022\026\n\010new_type\030\002 \002(\0132\004.typ\022\021\n\003exp"
    "\030\003 \002(\0132\004.exp\"@\n\007let_exp\022\021\n\003var\030\001 \002(\0132\004.v"
    "ar\022\020\n\002e1\030\002 \002(\0132\004.exp\022\020\n\002e2\030\003 \002(\0132\004.exp\","
    "\n\007unknown\022\016\n\006string\030\001 \002(\t\022\021\n\003typ\030\002 \002(\0132\004"
    ".typ\"K\n\003ite\022\027\n\tcondition\030\001 \002(\0132\004.exp\022\024\n\006"
    "iftrue\030\002 \002(\0132\004.exp\022\025\n\007iffalse\030\003 \002(\0132\004.ex"
    "p\"8\n\007extract\022\014\n\004hbit\030\001 \002(\021\022\014\n\004lbit\030\002 \002(\021"
    "\022\021\n\003exp\030\003 \002(\0132\004.exp\",\n\006concat\022\020\n\002le\030\001 \002("
    "\0132\004.exp\022\020\n\002re\030\002 \002(\0132\004.exp*L\n\tcast_type\022\021"
    "\n\rcast_unsigned\020\001\022\017\n\013cast_signed\020\002\022\r\n\tca"
    "st_high\020\003\022\014\n\010cast_low\020\004*\323\001\n\nbinop_type\022\010"
    "\n\004plus\020\001\022\t\n\005minus\020\002\022\t\n\005times\020\003\022\n\n\006divide"
    "\020\004\022\013\n\007sdivide\020\005\022\n\n\006modbop\020\006\022\010\n\004smod\020\007\022\n\n"
    "\006lshift\020\010\022\n\n\006rshift\020\t\022\013\n\007arshift\020\n\022\n\n\006an"
    "dbop\020\013\022\t\n\005orbop\020\014\022\007\n\003xor\020\r\022\006\n\002eq\020\016\022\007\n\003ne"
    "q\020\017\022\006\n\002lt\020\020\022\006\n\002le\020\021\022\007\n\003slt\020\022\022\007\n\003sle\020\023*\035\n"
    "\tunop_type\022\007\n\003neg\020\001\022\007\n\003not\020\002", 3268);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "stmt.piqi.proto", &protobuf_RegisterTypes);
  program::default_instance_ = new program();
  stmt::default_instance_ = new stmt();
  move::default_instance_ = new move();
  jmp::default_instance_ = new jmp();
  cjmp::default_instance_ = new cjmp();
  label_stmt::default_instance_ = new label_stmt();
  halt::default_instance_ = new halt();
  assert_stmt::default_instance_ = new assert_stmt();
  assume::default_instance_ = new assume();
  comment::default_instance_ = new comment();
  special::default_instance_ = new special();
  typ::default_instance_ = new typ();
  tmem::default_instance_ = new tmem();
  array::default_instance_ = new array();
  label::default_instance_ = new label();
  var::default_instance_ = new var();
  attribute::default_instance_ = new attribute();
  attributes::default_instance_ = new attributes();
  liveout::default_instance_ = new liveout();
  synthetic::default_instance_ = new synthetic();
  operand_info_specific::default_instance_ = new operand_info_specific();
  reg_operand::default_instance_ = new reg_operand();
  operand_usage::default_instance_ = new operand_usage();
  mem_operand::default_instance_ = new mem_operand();
  taint_info::default_instance_ = new taint_info();
  context::default_instance_ = new context();
  exp::default_instance_ = new exp();
  load::default_instance_ = new load();
  store::default_instance_ = new store();
  binop::default_instance_ = new binop();
  unop::default_instance_ = new unop();
  inte::default_instance_ = new inte();
  cast::default_instance_ = new cast();
  let_exp::default_instance_ = new let_exp();
  unknown::default_instance_ = new unknown();
  ite::default_instance_ = new ite();
  extract::default_instance_ = new extract();
  concat::default_instance_ = new concat();
  program::default_instance_->InitAsDefaultInstance();
  stmt::default_instance_->InitAsDefaultInstance();
  move::default_instance_->InitAsDefaultInstance();
  jmp::default_instance_->InitAsDefaultInstance();
  cjmp::default_instance_->InitAsDefaultInstance();
  label_stmt::default_instance_->InitAsDefaultInstance();
  halt::default_instance_->InitAsDefaultInstance();
  assert_stmt::default_instance_->InitAsDefaultInstance();
  assume::default_instance_->InitAsDefaultInstance();
  comment::default_instance_->InitAsDefaultInstance();
  special::default_instance_->InitAsDefaultInstance();
  typ::default_instance_->InitAsDefaultInstance();
  tmem::default_instance_->InitAsDefaultInstance();
  array::default_instance_->InitAsDefaultInstance();
  label::default_instance_->InitAsDefaultInstance();
  var::default_instance_->InitAsDefaultInstance();
  attribute::default_instance_->InitAsDefaultInstance();
  attributes::default_instance_->InitAsDefaultInstance();
  liveout::default_instance_->InitAsDefaultInstance();
  synthetic::default_instance_->InitAsDefaultInstance();
  operand_info_specific::default_instance_->InitAsDefaultInstance();
  reg_operand::default_instance_->InitAsDefaultInstance();
  operand_usage::default_instance_->InitAsDefaultInstance();
  mem_operand::default_instance_->InitAsDefaultInstance();
  taint_info::default_instance_->InitAsDefaultInstance();
  context::default_instance_->InitAsDefaultInstance();
  exp::default_instance_->InitAsDefaultInstance();
  load::default_instance_->InitAsDefaultInstance();
  store::default_instance_->InitAsDefaultInstance();
  binop::default_instance_->InitAsDefaultInstance();
  unop::default_instance_->InitAsDefaultInstance();
  inte::default_instance_->InitAsDefaultInstance();
  cast::default_instance_->InitAsDefaultInstance();
  let_exp::default_instance_->InitAsDefaultInstance();
  unknown::default_instance_->InitAsDefaultInstance();
  ite::default_instance_->InitAsDefaultInstance();
  extract::default_instance_->InitAsDefaultInstance();
  concat::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_stmt_2epiqi_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_stmt_2epiqi_2eproto {
  StaticDescriptorInitializer_stmt_2epiqi_2eproto() {
    protobuf_AddDesc_stmt_2epiqi_2eproto();
  }
} static_descriptor_initializer_stmt_2epiqi_2eproto_;

const ::google::protobuf::EnumDescriptor* cast_type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return cast_type_descriptor_;
}
bool cast_type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* binop_type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return binop_type_descriptor_;
}
bool binop_type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* unop_type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return unop_type_descriptor_;
}
bool unop_type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int program::kElemFieldNumber;
#endif  // !_MSC_VER

program::program()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void program::InitAsDefaultInstance() {
}

program::program(const program& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void program::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

program::~program() {
  SharedDtor();
}

void program::SharedDtor() {
  if (this != default_instance_) {
  }
}

void program::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* program::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return program_descriptor_;
}

const program& program::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

program* program::default_instance_ = NULL;

program* program::New() const {
  return new program;
}

void program::Clear() {
  elem_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool program::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .stmt elem = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_elem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_elem()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_elem;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void program::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .stmt elem = 1;
  for (int i = 0; i < this->elem_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->elem(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* program::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .stmt elem = 1;
  for (int i = 0; i < this->elem_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->elem(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int program::ByteSize() const {
  int total_size = 0;
  
  // repeated .stmt elem = 1;
  total_size += 1 * this->elem_size();
  for (int i = 0; i < this->elem_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->elem(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void program::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const program* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const program*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void program::MergeFrom(const program& from) {
  GOOGLE_CHECK_NE(&from, this);
  elem_.MergeFrom(from.elem_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void program::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void program::CopyFrom(const program& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool program::IsInitialized() const {
  
  for (int i = 0; i < elem_size(); i++) {
    if (!this->elem(i).IsInitialized()) return false;
  }
  return true;
}

void program::Swap(program* other) {
  if (other != this) {
    elem_.Swap(&other->elem_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata program::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = program_descriptor_;
  metadata.reflection = program_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int stmt::kMoveFieldNumber;
const int stmt::kJmpFieldNumber;
const int stmt::kCjmpFieldNumber;
const int stmt::kLabelStmtFieldNumber;
const int stmt::kHaltFieldNumber;
const int stmt::kAssertStmtFieldNumber;
const int stmt::kAssumeFieldNumber;
const int stmt::kCommentFieldNumber;
const int stmt::kSpecialFieldNumber;
#endif  // !_MSC_VER

stmt::stmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void stmt::InitAsDefaultInstance() {
  move_ = const_cast< ::move*>(&::move::default_instance());
  jmp_ = const_cast< ::jmp*>(&::jmp::default_instance());
  cjmp_ = const_cast< ::cjmp*>(&::cjmp::default_instance());
  label_stmt_ = const_cast< ::label_stmt*>(&::label_stmt::default_instance());
  halt_ = const_cast< ::halt*>(&::halt::default_instance());
  assert_stmt_ = const_cast< ::assert_stmt*>(&::assert_stmt::default_instance());
  assume_ = const_cast< ::assume*>(&::assume::default_instance());
  comment_ = const_cast< ::comment*>(&::comment::default_instance());
  special_ = const_cast< ::special*>(&::special::default_instance());
}

stmt::stmt(const stmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void stmt::SharedCtor() {
  _cached_size_ = 0;
  move_ = NULL;
  jmp_ = NULL;
  cjmp_ = NULL;
  label_stmt_ = NULL;
  halt_ = NULL;
  assert_stmt_ = NULL;
  assume_ = NULL;
  comment_ = NULL;
  special_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

stmt::~stmt() {
  SharedDtor();
}

void stmt::SharedDtor() {
  if (this != default_instance_) {
    delete move_;
    delete jmp_;
    delete cjmp_;
    delete label_stmt_;
    delete halt_;
    delete assert_stmt_;
    delete assume_;
    delete comment_;
    delete special_;
  }
}

void stmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* stmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return stmt_descriptor_;
}

const stmt& stmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

stmt* stmt::default_instance_ = NULL;

stmt* stmt::New() const {
  return new stmt;
}

void stmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_move()) {
      if (move_ != NULL) move_->::move::Clear();
    }
    if (has_jmp()) {
      if (jmp_ != NULL) jmp_->::jmp::Clear();
    }
    if (has_cjmp()) {
      if (cjmp_ != NULL) cjmp_->::cjmp::Clear();
    }
    if (has_label_stmt()) {
      if (label_stmt_ != NULL) label_stmt_->::label_stmt::Clear();
    }
    if (has_halt()) {
      if (halt_ != NULL) halt_->::halt::Clear();
    }
    if (has_assert_stmt()) {
      if (assert_stmt_ != NULL) assert_stmt_->::assert_stmt::Clear();
    }
    if (has_assume()) {
      if (assume_ != NULL) assume_->::assume::Clear();
    }
    if (has_comment()) {
      if (comment_ != NULL) comment_->::comment::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_special()) {
      if (special_ != NULL) special_->::special::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool stmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .move move = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_move()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_jmp;
        break;
      }
      
      // optional .jmp jmp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_jmp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_jmp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_cjmp;
        break;
      }
      
      // optional .cjmp cjmp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cjmp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cjmp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_label_stmt;
        break;
      }
      
      // optional .label_stmt label_stmt = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label_stmt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_label_stmt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_halt;
        break;
      }
      
      // optional .halt halt = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_halt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_halt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_assert_stmt;
        break;
      }
      
      // optional .assert_stmt assert_stmt = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_assert_stmt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_assert_stmt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_assume;
        break;
      }
      
      // optional .assume assume = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_assume:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_assume()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_comment;
        break;
      }
      
      // optional .comment comment = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_comment()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_special;
        break;
      }
      
      // optional .special special = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_special:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_special()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void stmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .move move = 1;
  if (has_move()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->move(), output);
  }
  
  // optional .jmp jmp = 2;
  if (has_jmp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->jmp(), output);
  }
  
  // optional .cjmp cjmp = 3;
  if (has_cjmp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->cjmp(), output);
  }
  
  // optional .label_stmt label_stmt = 4;
  if (has_label_stmt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->label_stmt(), output);
  }
  
  // optional .halt halt = 5;
  if (has_halt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->halt(), output);
  }
  
  // optional .assert_stmt assert_stmt = 6;
  if (has_assert_stmt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->assert_stmt(), output);
  }
  
  // optional .assume assume = 7;
  if (has_assume()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->assume(), output);
  }
  
  // optional .comment comment = 8;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->comment(), output);
  }
  
  // optional .special special = 9;
  if (has_special()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->special(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* stmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .move move = 1;
  if (has_move()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->move(), target);
  }
  
  // optional .jmp jmp = 2;
  if (has_jmp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->jmp(), target);
  }
  
  // optional .cjmp cjmp = 3;
  if (has_cjmp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->cjmp(), target);
  }
  
  // optional .label_stmt label_stmt = 4;
  if (has_label_stmt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->label_stmt(), target);
  }
  
  // optional .halt halt = 5;
  if (has_halt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->halt(), target);
  }
  
  // optional .assert_stmt assert_stmt = 6;
  if (has_assert_stmt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->assert_stmt(), target);
  }
  
  // optional .assume assume = 7;
  if (has_assume()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->assume(), target);
  }
  
  // optional .comment comment = 8;
  if (has_comment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->comment(), target);
  }
  
  // optional .special special = 9;
  if (has_special()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->special(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int stmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .move move = 1;
    if (has_move()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->move());
    }
    
    // optional .jmp jmp = 2;
    if (has_jmp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->jmp());
    }
    
    // optional .cjmp cjmp = 3;
    if (has_cjmp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cjmp());
    }
    
    // optional .label_stmt label_stmt = 4;
    if (has_label_stmt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->label_stmt());
    }
    
    // optional .halt halt = 5;
    if (has_halt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->halt());
    }
    
    // optional .assert_stmt assert_stmt = 6;
    if (has_assert_stmt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->assert_stmt());
    }
    
    // optional .assume assume = 7;
    if (has_assume()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->assume());
    }
    
    // optional .comment comment = 8;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->comment());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .special special = 9;
    if (has_special()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->special());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void stmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const stmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const stmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void stmt::MergeFrom(const stmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_move()) {
      mutable_move()->::move::MergeFrom(from.move());
    }
    if (from.has_jmp()) {
      mutable_jmp()->::jmp::MergeFrom(from.jmp());
    }
    if (from.has_cjmp()) {
      mutable_cjmp()->::cjmp::MergeFrom(from.cjmp());
    }
    if (from.has_label_stmt()) {
      mutable_label_stmt()->::label_stmt::MergeFrom(from.label_stmt());
    }
    if (from.has_halt()) {
      mutable_halt()->::halt::MergeFrom(from.halt());
    }
    if (from.has_assert_stmt()) {
      mutable_assert_stmt()->::assert_stmt::MergeFrom(from.assert_stmt());
    }
    if (from.has_assume()) {
      mutable_assume()->::assume::MergeFrom(from.assume());
    }
    if (from.has_comment()) {
      mutable_comment()->::comment::MergeFrom(from.comment());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_special()) {
      mutable_special()->::special::MergeFrom(from.special());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void stmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void stmt::CopyFrom(const stmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool stmt::IsInitialized() const {
  
  if (has_move()) {
    if (!this->move().IsInitialized()) return false;
  }
  if (has_jmp()) {
    if (!this->jmp().IsInitialized()) return false;
  }
  if (has_cjmp()) {
    if (!this->cjmp().IsInitialized()) return false;
  }
  if (has_label_stmt()) {
    if (!this->label_stmt().IsInitialized()) return false;
  }
  if (has_halt()) {
    if (!this->halt().IsInitialized()) return false;
  }
  if (has_assert_stmt()) {
    if (!this->assert_stmt().IsInitialized()) return false;
  }
  if (has_assume()) {
    if (!this->assume().IsInitialized()) return false;
  }
  if (has_comment()) {
    if (!this->comment().IsInitialized()) return false;
  }
  if (has_special()) {
    if (!this->special().IsInitialized()) return false;
  }
  return true;
}

void stmt::Swap(stmt* other) {
  if (other != this) {
    std::swap(move_, other->move_);
    std::swap(jmp_, other->jmp_);
    std::swap(cjmp_, other->cjmp_);
    std::swap(label_stmt_, other->label_stmt_);
    std::swap(halt_, other->halt_);
    std::swap(assert_stmt_, other->assert_stmt_);
    std::swap(assume_, other->assume_);
    std::swap(comment_, other->comment_);
    std::swap(special_, other->special_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata stmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = stmt_descriptor_;
  metadata.reflection = stmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int move::kVarFieldNumber;
const int move::kExpFieldNumber;
const int move::kAttributesFieldNumber;
#endif  // !_MSC_VER

move::move()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void move::InitAsDefaultInstance() {
  var_ = const_cast< ::var*>(&::var::default_instance());
  exp_ = const_cast< ::exp*>(&::exp::default_instance());
  attributes_ = const_cast< ::attributes*>(&::attributes::default_instance());
}

move::move(const move& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void move::SharedCtor() {
  _cached_size_ = 0;
  var_ = NULL;
  exp_ = NULL;
  attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

move::~move() {
  SharedDtor();
}

void move::SharedDtor() {
  if (this != default_instance_) {
    delete var_;
    delete exp_;
    delete attributes_;
  }
}

void move::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* move::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return move_descriptor_;
}

const move& move::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

move* move::default_instance_ = NULL;

move* move::New() const {
  return new move;
}

void move::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_var()) {
      if (var_ != NULL) var_->::var::Clear();
    }
    if (has_exp()) {
      if (exp_ != NULL) exp_->::exp::Clear();
    }
    if (has_attributes()) {
      if (attributes_ != NULL) attributes_->::attributes::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool move::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .var var = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_var()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_exp;
        break;
      }
      
      // required .exp exp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_attributes;
        break;
      }
      
      // required .attributes attributes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void move::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .var var = 1;
  if (has_var()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->var(), output);
  }
  
  // required .exp exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->exp(), output);
  }
  
  // required .attributes attributes = 3;
  if (has_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->attributes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* move::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .var var = 1;
  if (has_var()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->var(), target);
  }
  
  // required .exp exp = 2;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->exp(), target);
  }
  
  // required .attributes attributes = 3;
  if (has_attributes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->attributes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int move::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .var var = 1;
    if (has_var()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->var());
    }
    
    // required .exp exp = 2;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp());
    }
    
    // required .attributes attributes = 3;
    if (has_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attributes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void move::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const move* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const move*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void move::MergeFrom(const move& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_var()) {
      mutable_var()->::var::MergeFrom(from.var());
    }
    if (from.has_exp()) {
      mutable_exp()->::exp::MergeFrom(from.exp());
    }
    if (from.has_attributes()) {
      mutable_attributes()->::attributes::MergeFrom(from.attributes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void move::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void move::CopyFrom(const move& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool move::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_var()) {
    if (!this->var().IsInitialized()) return false;
  }
  if (has_exp()) {
    if (!this->exp().IsInitialized()) return false;
  }
  if (has_attributes()) {
    if (!this->attributes().IsInitialized()) return false;
  }
  return true;
}

void move::Swap(move* other) {
  if (other != this) {
    std::swap(var_, other->var_);
    std::swap(exp_, other->exp_);
    std::swap(attributes_, other->attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata move::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = move_descriptor_;
  metadata.reflection = move_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int jmp::kExpFieldNumber;
const int jmp::kAttributesFieldNumber;
#endif  // !_MSC_VER

jmp::jmp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void jmp::InitAsDefaultInstance() {
  exp_ = const_cast< ::exp*>(&::exp::default_instance());
  attributes_ = const_cast< ::attributes*>(&::attributes::default_instance());
}

jmp::jmp(const jmp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void jmp::SharedCtor() {
  _cached_size_ = 0;
  exp_ = NULL;
  attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

jmp::~jmp() {
  SharedDtor();
}

void jmp::SharedDtor() {
  if (this != default_instance_) {
    delete exp_;
    delete attributes_;
  }
}

void jmp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* jmp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return jmp_descriptor_;
}

const jmp& jmp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

jmp* jmp::default_instance_ = NULL;

jmp* jmp::New() const {
  return new jmp;
}

void jmp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_exp()) {
      if (exp_ != NULL) exp_->::exp::Clear();
    }
    if (has_attributes()) {
      if (attributes_ != NULL) attributes_->::attributes::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool jmp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .exp exp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_attributes;
        break;
      }
      
      // required .attributes attributes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void jmp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .exp exp = 1;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->exp(), output);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->attributes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* jmp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .exp exp = 1;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->exp(), target);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->attributes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int jmp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .exp exp = 1;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp());
    }
    
    // required .attributes attributes = 2;
    if (has_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attributes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void jmp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const jmp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const jmp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void jmp::MergeFrom(const jmp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exp()) {
      mutable_exp()->::exp::MergeFrom(from.exp());
    }
    if (from.has_attributes()) {
      mutable_attributes()->::attributes::MergeFrom(from.attributes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void jmp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void jmp::CopyFrom(const jmp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool jmp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_exp()) {
    if (!this->exp().IsInitialized()) return false;
  }
  if (has_attributes()) {
    if (!this->attributes().IsInitialized()) return false;
  }
  return true;
}

void jmp::Swap(jmp* other) {
  if (other != this) {
    std::swap(exp_, other->exp_);
    std::swap(attributes_, other->attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata jmp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = jmp_descriptor_;
  metadata.reflection = jmp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int cjmp::kCondFieldNumber;
const int cjmp::kIftrueFieldNumber;
const int cjmp::kIffalseFieldNumber;
const int cjmp::kAttributesFieldNumber;
#endif  // !_MSC_VER

cjmp::cjmp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void cjmp::InitAsDefaultInstance() {
  cond_ = const_cast< ::exp*>(&::exp::default_instance());
  iftrue_ = const_cast< ::exp*>(&::exp::default_instance());
  iffalse_ = const_cast< ::exp*>(&::exp::default_instance());
  attributes_ = const_cast< ::attributes*>(&::attributes::default_instance());
}

cjmp::cjmp(const cjmp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void cjmp::SharedCtor() {
  _cached_size_ = 0;
  cond_ = NULL;
  iftrue_ = NULL;
  iffalse_ = NULL;
  attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

cjmp::~cjmp() {
  SharedDtor();
}

void cjmp::SharedDtor() {
  if (this != default_instance_) {
    delete cond_;
    delete iftrue_;
    delete iffalse_;
    delete attributes_;
  }
}

void cjmp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* cjmp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return cjmp_descriptor_;
}

const cjmp& cjmp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

cjmp* cjmp::default_instance_ = NULL;

cjmp* cjmp::New() const {
  return new cjmp;
}

void cjmp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_cond()) {
      if (cond_ != NULL) cond_->::exp::Clear();
    }
    if (has_iftrue()) {
      if (iftrue_ != NULL) iftrue_->::exp::Clear();
    }
    if (has_iffalse()) {
      if (iffalse_ != NULL) iffalse_->::exp::Clear();
    }
    if (has_attributes()) {
      if (attributes_ != NULL) attributes_->::attributes::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool cjmp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .exp cond = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cond()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_iftrue;
        break;
      }
      
      // required .exp iftrue = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iftrue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iftrue()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_iffalse;
        break;
      }
      
      // required .exp iffalse = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iffalse:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iffalse()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_attributes;
        break;
      }
      
      // required .attributes attributes = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void cjmp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .exp cond = 1;
  if (has_cond()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cond(), output);
  }
  
  // required .exp iftrue = 2;
  if (has_iftrue()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->iftrue(), output);
  }
  
  // required .exp iffalse = 3;
  if (has_iffalse()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->iffalse(), output);
  }
  
  // required .attributes attributes = 4;
  if (has_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->attributes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* cjmp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .exp cond = 1;
  if (has_cond()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->cond(), target);
  }
  
  // required .exp iftrue = 2;
  if (has_iftrue()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->iftrue(), target);
  }
  
  // required .exp iffalse = 3;
  if (has_iffalse()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->iffalse(), target);
  }
  
  // required .attributes attributes = 4;
  if (has_attributes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->attributes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int cjmp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .exp cond = 1;
    if (has_cond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cond());
    }
    
    // required .exp iftrue = 2;
    if (has_iftrue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iftrue());
    }
    
    // required .exp iffalse = 3;
    if (has_iffalse()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iffalse());
    }
    
    // required .attributes attributes = 4;
    if (has_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attributes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void cjmp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const cjmp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const cjmp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void cjmp::MergeFrom(const cjmp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cond()) {
      mutable_cond()->::exp::MergeFrom(from.cond());
    }
    if (from.has_iftrue()) {
      mutable_iftrue()->::exp::MergeFrom(from.iftrue());
    }
    if (from.has_iffalse()) {
      mutable_iffalse()->::exp::MergeFrom(from.iffalse());
    }
    if (from.has_attributes()) {
      mutable_attributes()->::attributes::MergeFrom(from.attributes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void cjmp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void cjmp::CopyFrom(const cjmp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool cjmp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_cond()) {
    if (!this->cond().IsInitialized()) return false;
  }
  if (has_iftrue()) {
    if (!this->iftrue().IsInitialized()) return false;
  }
  if (has_iffalse()) {
    if (!this->iffalse().IsInitialized()) return false;
  }
  if (has_attributes()) {
    if (!this->attributes().IsInitialized()) return false;
  }
  return true;
}

void cjmp::Swap(cjmp* other) {
  if (other != this) {
    std::swap(cond_, other->cond_);
    std::swap(iftrue_, other->iftrue_);
    std::swap(iffalse_, other->iffalse_);
    std::swap(attributes_, other->attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata cjmp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = cjmp_descriptor_;
  metadata.reflection = cjmp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int label_stmt::kLabelFieldNumber;
const int label_stmt::kAttributesFieldNumber;
#endif  // !_MSC_VER

label_stmt::label_stmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void label_stmt::InitAsDefaultInstance() {
  label_ = const_cast< ::label*>(&::label::default_instance());
  attributes_ = const_cast< ::attributes*>(&::attributes::default_instance());
}

label_stmt::label_stmt(const label_stmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void label_stmt::SharedCtor() {
  _cached_size_ = 0;
  label_ = NULL;
  attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

label_stmt::~label_stmt() {
  SharedDtor();
}

void label_stmt::SharedDtor() {
  if (this != default_instance_) {
    delete label_;
    delete attributes_;
  }
}

void label_stmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* label_stmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return label_stmt_descriptor_;
}

const label_stmt& label_stmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

label_stmt* label_stmt::default_instance_ = NULL;

label_stmt* label_stmt::New() const {
  return new label_stmt;
}

void label_stmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_label()) {
      if (label_ != NULL) label_->::label::Clear();
    }
    if (has_attributes()) {
      if (attributes_ != NULL) attributes_->::attributes::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool label_stmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .label label = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_attributes;
        break;
      }
      
      // required .attributes attributes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void label_stmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .label label = 1;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->label(), output);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->attributes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* label_stmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .label label = 1;
  if (has_label()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->label(), target);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->attributes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int label_stmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .label label = 1;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->label());
    }
    
    // required .attributes attributes = 2;
    if (has_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attributes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void label_stmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const label_stmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const label_stmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void label_stmt::MergeFrom(const label_stmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_label()) {
      mutable_label()->::label::MergeFrom(from.label());
    }
    if (from.has_attributes()) {
      mutable_attributes()->::attributes::MergeFrom(from.attributes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void label_stmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void label_stmt::CopyFrom(const label_stmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool label_stmt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_attributes()) {
    if (!this->attributes().IsInitialized()) return false;
  }
  return true;
}

void label_stmt::Swap(label_stmt* other) {
  if (other != this) {
    std::swap(label_, other->label_);
    std::swap(attributes_, other->attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata label_stmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = label_stmt_descriptor_;
  metadata.reflection = label_stmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int halt::kExpFieldNumber;
const int halt::kAttributesFieldNumber;
#endif  // !_MSC_VER

halt::halt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void halt::InitAsDefaultInstance() {
  exp_ = const_cast< ::exp*>(&::exp::default_instance());
  attributes_ = const_cast< ::attributes*>(&::attributes::default_instance());
}

halt::halt(const halt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void halt::SharedCtor() {
  _cached_size_ = 0;
  exp_ = NULL;
  attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

halt::~halt() {
  SharedDtor();
}

void halt::SharedDtor() {
  if (this != default_instance_) {
    delete exp_;
    delete attributes_;
  }
}

void halt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* halt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return halt_descriptor_;
}

const halt& halt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

halt* halt::default_instance_ = NULL;

halt* halt::New() const {
  return new halt;
}

void halt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_exp()) {
      if (exp_ != NULL) exp_->::exp::Clear();
    }
    if (has_attributes()) {
      if (attributes_ != NULL) attributes_->::attributes::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool halt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .exp exp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_attributes;
        break;
      }
      
      // required .attributes attributes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void halt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .exp exp = 1;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->exp(), output);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->attributes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* halt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .exp exp = 1;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->exp(), target);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->attributes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int halt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .exp exp = 1;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp());
    }
    
    // required .attributes attributes = 2;
    if (has_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attributes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void halt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const halt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const halt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void halt::MergeFrom(const halt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exp()) {
      mutable_exp()->::exp::MergeFrom(from.exp());
    }
    if (from.has_attributes()) {
      mutable_attributes()->::attributes::MergeFrom(from.attributes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void halt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void halt::CopyFrom(const halt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool halt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_exp()) {
    if (!this->exp().IsInitialized()) return false;
  }
  if (has_attributes()) {
    if (!this->attributes().IsInitialized()) return false;
  }
  return true;
}

void halt::Swap(halt* other) {
  if (other != this) {
    std::swap(exp_, other->exp_);
    std::swap(attributes_, other->attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata halt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = halt_descriptor_;
  metadata.reflection = halt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int assert_stmt::kExpFieldNumber;
const int assert_stmt::kAttributesFieldNumber;
#endif  // !_MSC_VER

assert_stmt::assert_stmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void assert_stmt::InitAsDefaultInstance() {
  exp_ = const_cast< ::exp*>(&::exp::default_instance());
  attributes_ = const_cast< ::attributes*>(&::attributes::default_instance());
}

assert_stmt::assert_stmt(const assert_stmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void assert_stmt::SharedCtor() {
  _cached_size_ = 0;
  exp_ = NULL;
  attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

assert_stmt::~assert_stmt() {
  SharedDtor();
}

void assert_stmt::SharedDtor() {
  if (this != default_instance_) {
    delete exp_;
    delete attributes_;
  }
}

void assert_stmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* assert_stmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return assert_stmt_descriptor_;
}

const assert_stmt& assert_stmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

assert_stmt* assert_stmt::default_instance_ = NULL;

assert_stmt* assert_stmt::New() const {
  return new assert_stmt;
}

void assert_stmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_exp()) {
      if (exp_ != NULL) exp_->::exp::Clear();
    }
    if (has_attributes()) {
      if (attributes_ != NULL) attributes_->::attributes::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool assert_stmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .exp exp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_attributes;
        break;
      }
      
      // required .attributes attributes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void assert_stmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .exp exp = 1;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->exp(), output);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->attributes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* assert_stmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .exp exp = 1;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->exp(), target);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->attributes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int assert_stmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .exp exp = 1;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp());
    }
    
    // required .attributes attributes = 2;
    if (has_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attributes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void assert_stmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const assert_stmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const assert_stmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void assert_stmt::MergeFrom(const assert_stmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exp()) {
      mutable_exp()->::exp::MergeFrom(from.exp());
    }
    if (from.has_attributes()) {
      mutable_attributes()->::attributes::MergeFrom(from.attributes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void assert_stmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void assert_stmt::CopyFrom(const assert_stmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool assert_stmt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_exp()) {
    if (!this->exp().IsInitialized()) return false;
  }
  if (has_attributes()) {
    if (!this->attributes().IsInitialized()) return false;
  }
  return true;
}

void assert_stmt::Swap(assert_stmt* other) {
  if (other != this) {
    std::swap(exp_, other->exp_);
    std::swap(attributes_, other->attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata assert_stmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = assert_stmt_descriptor_;
  metadata.reflection = assert_stmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int assume::kExpFieldNumber;
const int assume::kAttributesFieldNumber;
#endif  // !_MSC_VER

assume::assume()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void assume::InitAsDefaultInstance() {
  exp_ = const_cast< ::exp*>(&::exp::default_instance());
  attributes_ = const_cast< ::attributes*>(&::attributes::default_instance());
}

assume::assume(const assume& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void assume::SharedCtor() {
  _cached_size_ = 0;
  exp_ = NULL;
  attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

assume::~assume() {
  SharedDtor();
}

void assume::SharedDtor() {
  if (this != default_instance_) {
    delete exp_;
    delete attributes_;
  }
}

void assume::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* assume::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return assume_descriptor_;
}

const assume& assume::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

assume* assume::default_instance_ = NULL;

assume* assume::New() const {
  return new assume;
}

void assume::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_exp()) {
      if (exp_ != NULL) exp_->::exp::Clear();
    }
    if (has_attributes()) {
      if (attributes_ != NULL) attributes_->::attributes::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool assume::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .exp exp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_attributes;
        break;
      }
      
      // required .attributes attributes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void assume::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .exp exp = 1;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->exp(), output);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->attributes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* assume::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .exp exp = 1;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->exp(), target);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->attributes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int assume::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .exp exp = 1;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp());
    }
    
    // required .attributes attributes = 2;
    if (has_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attributes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void assume::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const assume* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const assume*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void assume::MergeFrom(const assume& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exp()) {
      mutable_exp()->::exp::MergeFrom(from.exp());
    }
    if (from.has_attributes()) {
      mutable_attributes()->::attributes::MergeFrom(from.attributes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void assume::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void assume::CopyFrom(const assume& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool assume::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_exp()) {
    if (!this->exp().IsInitialized()) return false;
  }
  if (has_attributes()) {
    if (!this->attributes().IsInitialized()) return false;
  }
  return true;
}

void assume::Swap(assume* other) {
  if (other != this) {
    std::swap(exp_, other->exp_);
    std::swap(attributes_, other->attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata assume::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = assume_descriptor_;
  metadata.reflection = assume_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int comment::kStringFieldNumber;
const int comment::kAttributesFieldNumber;
#endif  // !_MSC_VER

comment::comment()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void comment::InitAsDefaultInstance() {
  attributes_ = const_cast< ::attributes*>(&::attributes::default_instance());
}

comment::comment(const comment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void comment::SharedCtor() {
  _cached_size_ = 0;
  string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

comment::~comment() {
  SharedDtor();
}

void comment::SharedDtor() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    delete string_;
  }
  if (this != default_instance_) {
    delete attributes_;
  }
}

void comment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* comment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return comment_descriptor_;
}

const comment& comment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

comment* comment::default_instance_ = NULL;

comment* comment::New() const {
  return new comment;
}

void comment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_string()) {
      if (string_ != &::google::protobuf::internal::kEmptyString) {
        string_->clear();
      }
    }
    if (has_attributes()) {
      if (attributes_ != NULL) attributes_->::attributes::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool comment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string string = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_string()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->string().data(), this->string().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_attributes;
        break;
      }
      
      // required .attributes attributes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void comment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string string = 1;
  if (has_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->string().data(), this->string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->string(), output);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->attributes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* comment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string string = 1;
  if (has_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->string().data(), this->string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->string(), target);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->attributes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int comment::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string string = 1;
    if (has_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->string());
    }
    
    // required .attributes attributes = 2;
    if (has_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attributes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void comment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const comment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const comment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void comment::MergeFrom(const comment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_string()) {
      set_string(from.string());
    }
    if (from.has_attributes()) {
      mutable_attributes()->::attributes::MergeFrom(from.attributes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void comment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void comment::CopyFrom(const comment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool comment::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_attributes()) {
    if (!this->attributes().IsInitialized()) return false;
  }
  return true;
}

void comment::Swap(comment* other) {
  if (other != this) {
    std::swap(string_, other->string_);
    std::swap(attributes_, other->attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata comment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = comment_descriptor_;
  metadata.reflection = comment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int special::kStringFieldNumber;
const int special::kAttributesFieldNumber;
#endif  // !_MSC_VER

special::special()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void special::InitAsDefaultInstance() {
  attributes_ = const_cast< ::attributes*>(&::attributes::default_instance());
}

special::special(const special& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void special::SharedCtor() {
  _cached_size_ = 0;
  string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

special::~special() {
  SharedDtor();
}

void special::SharedDtor() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    delete string_;
  }
  if (this != default_instance_) {
    delete attributes_;
  }
}

void special::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* special::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return special_descriptor_;
}

const special& special::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

special* special::default_instance_ = NULL;

special* special::New() const {
  return new special;
}

void special::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_string()) {
      if (string_ != &::google::protobuf::internal::kEmptyString) {
        string_->clear();
      }
    }
    if (has_attributes()) {
      if (attributes_ != NULL) attributes_->::attributes::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool special::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string string = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_string()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->string().data(), this->string().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_attributes;
        break;
      }
      
      // required .attributes attributes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void special::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string string = 1;
  if (has_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->string().data(), this->string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->string(), output);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->attributes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* special::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string string = 1;
  if (has_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->string().data(), this->string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->string(), target);
  }
  
  // required .attributes attributes = 2;
  if (has_attributes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->attributes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int special::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string string = 1;
    if (has_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->string());
    }
    
    // required .attributes attributes = 2;
    if (has_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attributes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void special::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const special* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const special*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void special::MergeFrom(const special& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_string()) {
      set_string(from.string());
    }
    if (from.has_attributes()) {
      mutable_attributes()->::attributes::MergeFrom(from.attributes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void special::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void special::CopyFrom(const special& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool special::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_attributes()) {
    if (!this->attributes().IsInitialized()) return false;
  }
  return true;
}

void special::Swap(special* other) {
  if (other != this) {
    std::swap(string_, other->string_);
    std::swap(attributes_, other->attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata special::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = special_descriptor_;
  metadata.reflection = special_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int typ::kRegFieldNumber;
const int typ::kTmemFieldNumber;
const int typ::kArrayFieldNumber;
#endif  // !_MSC_VER

typ::typ()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void typ::InitAsDefaultInstance() {
  tmem_ = const_cast< ::tmem*>(&::tmem::default_instance());
  array_ = const_cast< ::array*>(&::array::default_instance());
}

typ::typ(const typ& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void typ::SharedCtor() {
  _cached_size_ = 0;
  reg_ = 0;
  tmem_ = NULL;
  array_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

typ::~typ() {
  SharedDtor();
}

void typ::SharedDtor() {
  if (this != default_instance_) {
    delete tmem_;
    delete array_;
  }
}

void typ::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* typ::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return typ_descriptor_;
}

const typ& typ::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

typ* typ::default_instance_ = NULL;

typ* typ::New() const {
  return new typ;
}

void typ::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reg_ = 0;
    if (has_tmem()) {
      if (tmem_ != NULL) tmem_->::tmem::Clear();
    }
    if (has_array()) {
      if (array_ != NULL) array_->::array::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool typ::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 reg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &reg_)));
          set_has_reg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tmem;
        break;
      }
      
      // optional .tmem tmem = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tmem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tmem()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_array;
        break;
      }
      
      // optional .array array = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_array:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_array()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void typ::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 reg = 1;
  if (has_reg()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->reg(), output);
  }
  
  // optional .tmem tmem = 2;
  if (has_tmem()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->tmem(), output);
  }
  
  // optional .array array = 3;
  if (has_array()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->array(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* typ::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 reg = 1;
  if (has_reg()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->reg(), target);
  }
  
  // optional .tmem tmem = 2;
  if (has_tmem()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->tmem(), target);
  }
  
  // optional .array array = 3;
  if (has_array()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->array(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int typ::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 reg = 1;
    if (has_reg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->reg());
    }
    
    // optional .tmem tmem = 2;
    if (has_tmem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tmem());
    }
    
    // optional .array array = 3;
    if (has_array()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->array());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void typ::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const typ* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const typ*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void typ::MergeFrom(const typ& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reg()) {
      set_reg(from.reg());
    }
    if (from.has_tmem()) {
      mutable_tmem()->::tmem::MergeFrom(from.tmem());
    }
    if (from.has_array()) {
      mutable_array()->::array::MergeFrom(from.array());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void typ::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void typ::CopyFrom(const typ& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool typ::IsInitialized() const {
  
  if (has_tmem()) {
    if (!this->tmem().IsInitialized()) return false;
  }
  if (has_array()) {
    if (!this->array().IsInitialized()) return false;
  }
  return true;
}

void typ::Swap(typ* other) {
  if (other != this) {
    std::swap(reg_, other->reg_);
    std::swap(tmem_, other->tmem_);
    std::swap(array_, other->array_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata typ::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = typ_descriptor_;
  metadata.reflection = typ_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int tmem::kIndexTypeFieldNumber;
#endif  // !_MSC_VER

tmem::tmem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void tmem::InitAsDefaultInstance() {
  index_type_ = const_cast< ::typ*>(&::typ::default_instance());
}

tmem::tmem(const tmem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void tmem::SharedCtor() {
  _cached_size_ = 0;
  index_type_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tmem::~tmem() {
  SharedDtor();
}

void tmem::SharedDtor() {
  if (this != default_instance_) {
    delete index_type_;
  }
}

void tmem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tmem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tmem_descriptor_;
}

const tmem& tmem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

tmem* tmem::default_instance_ = NULL;

tmem* tmem::New() const {
  return new tmem;
}

void tmem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_index_type()) {
      if (index_type_ != NULL) index_type_->::typ::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tmem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .typ index_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_index_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void tmem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .typ index_type = 1;
  if (has_index_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->index_type(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* tmem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .typ index_type = 1;
  if (has_index_type()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->index_type(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int tmem::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .typ index_type = 1;
    if (has_index_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->index_type());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tmem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tmem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tmem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tmem::MergeFrom(const tmem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index_type()) {
      mutable_index_type()->::typ::MergeFrom(from.index_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tmem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tmem::CopyFrom(const tmem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tmem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_index_type()) {
    if (!this->index_type().IsInitialized()) return false;
  }
  return true;
}

void tmem::Swap(tmem* other) {
  if (other != this) {
    std::swap(index_type_, other->index_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tmem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tmem_descriptor_;
  metadata.reflection = tmem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int array::kIndexTypeFieldNumber;
const int array::kElementTypeFieldNumber;
#endif  // !_MSC_VER

array::array()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void array::InitAsDefaultInstance() {
  index_type_ = const_cast< ::typ*>(&::typ::default_instance());
  element_type_ = const_cast< ::typ*>(&::typ::default_instance());
}

array::array(const array& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void array::SharedCtor() {
  _cached_size_ = 0;
  index_type_ = NULL;
  element_type_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

array::~array() {
  SharedDtor();
}

void array::SharedDtor() {
  if (this != default_instance_) {
    delete index_type_;
    delete element_type_;
  }
}

void array::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* array::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return array_descriptor_;
}

const array& array::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

array* array::default_instance_ = NULL;

array* array::New() const {
  return new array;
}

void array::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_index_type()) {
      if (index_type_ != NULL) index_type_->::typ::Clear();
    }
    if (has_element_type()) {
      if (element_type_ != NULL) element_type_->::typ::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool array::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .typ index_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_index_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_element_type;
        break;
      }
      
      // required .typ element_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_element_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_element_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void array::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .typ index_type = 1;
  if (has_index_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->index_type(), output);
  }
  
  // required .typ element_type = 2;
  if (has_element_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->element_type(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* array::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .typ index_type = 1;
  if (has_index_type()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->index_type(), target);
  }
  
  // required .typ element_type = 2;
  if (has_element_type()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->element_type(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int array::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .typ index_type = 1;
    if (has_index_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->index_type());
    }
    
    // required .typ element_type = 2;
    if (has_element_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->element_type());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void array::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const array* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const array*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void array::MergeFrom(const array& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index_type()) {
      mutable_index_type()->::typ::MergeFrom(from.index_type());
    }
    if (from.has_element_type()) {
      mutable_element_type()->::typ::MergeFrom(from.element_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void array::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void array::CopyFrom(const array& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool array::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_index_type()) {
    if (!this->index_type().IsInitialized()) return false;
  }
  if (has_element_type()) {
    if (!this->element_type().IsInitialized()) return false;
  }
  return true;
}

void array::Swap(array* other) {
  if (other != this) {
    std::swap(index_type_, other->index_type_);
    std::swap(element_type_, other->element_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata array::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = array_descriptor_;
  metadata.reflection = array_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int label::kNameFieldNumber;
const int label::kAddrFieldNumber;
#endif  // !_MSC_VER

label::label()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void label::InitAsDefaultInstance() {
}

label::label(const label& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void label::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  addr_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

label::~label() {
  SharedDtor();
}

void label::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void label::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* label::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return label_descriptor_;
}

const label& label::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

label* label::default_instance_ = NULL;

label* label::New() const {
  return new label;
}

void label::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    addr_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool label::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_addr;
        break;
      }
      
      // optional sint64 addr = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_addr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &addr_)));
          set_has_addr();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void label::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional sint64 addr = 2;
  if (has_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(2, this->addr(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* label::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional sint64 addr = 2;
  if (has_addr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(2, this->addr(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int label::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional sint64 addr = 2;
    if (has_addr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->addr());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void label::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const label* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const label*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void label::MergeFrom(const label& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_addr()) {
      set_addr(from.addr());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void label::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void label::CopyFrom(const label& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool label::IsInitialized() const {
  
  return true;
}

void label::Swap(label* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(addr_, other->addr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata label::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = label_descriptor_;
  metadata.reflection = label_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int var::kNameFieldNumber;
const int var::kIdFieldNumber;
const int var::kTypFieldNumber;
#endif  // !_MSC_VER

var::var()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void var::InitAsDefaultInstance() {
  typ_ = const_cast< ::typ*>(&::typ::default_instance());
}

var::var(const var& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void var::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  id_ = 0;
  typ_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

var::~var() {
  SharedDtor();
}

void var::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete typ_;
  }
}

void var::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* var::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return var_descriptor_;
}

const var& var::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

var* var::default_instance_ = NULL;

var* var::New() const {
  return new var;
}

void var::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    id_ = 0;
    if (has_typ()) {
      if (typ_ != NULL) typ_->::typ::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool var::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }
      
      // required sint32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_typ;
        break;
      }
      
      // required .typ typ = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_typ:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_typ()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void var::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required sint32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->id(), output);
  }
  
  // required .typ typ = 3;
  if (has_typ()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->typ(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* var::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required sint32 id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->id(), target);
  }
  
  // required .typ typ = 3;
  if (has_typ()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->typ(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int var::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required sint32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->id());
    }
    
    // required .typ typ = 3;
    if (has_typ()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->typ());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void var::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const var* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const var*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void var::MergeFrom(const var& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_typ()) {
      mutable_typ()->::typ::MergeFrom(from.typ());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void var::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void var::CopyFrom(const var& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool var::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_typ()) {
    if (!this->typ().IsInitialized()) return false;
  }
  return true;
}

void var::Swap(var* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(id_, other->id_);
    std::swap(typ_, other->typ_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata var::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = var_descriptor_;
  metadata.reflection = var_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int attribute::kAsmFieldNumber;
const int attribute::kAddressFieldNumber;
const int attribute::kLiveoutFieldNumber;
const int attribute::kStrattrFieldNumber;
const int attribute::kContextFieldNumber;
const int attribute::kThreadIdFieldNumber;
const int attribute::kSyntheticFieldNumber;
const int attribute::kOtherFieldNumber;
#endif  // !_MSC_VER

attribute::attribute()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void attribute::InitAsDefaultInstance() {
  liveout_ = const_cast< ::liveout*>(&::liveout::default_instance());
  context_ = const_cast< ::context*>(&::context::default_instance());
  synthetic_ = const_cast< ::synthetic*>(&::synthetic::default_instance());
}

attribute::attribute(const attribute& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void attribute::SharedCtor() {
  _cached_size_ = 0;
  asm__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  address_ = GOOGLE_LONGLONG(0);
  liveout_ = NULL;
  strattr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  context_ = NULL;
  thread_id_ = GOOGLE_ULONGLONG(0);
  synthetic_ = NULL;
  other_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

attribute::~attribute() {
  SharedDtor();
}

void attribute::SharedDtor() {
  if (asm__ != &::google::protobuf::internal::kEmptyString) {
    delete asm__;
  }
  if (strattr_ != &::google::protobuf::internal::kEmptyString) {
    delete strattr_;
  }
  if (other_ != &::google::protobuf::internal::kEmptyString) {
    delete other_;
  }
  if (this != default_instance_) {
    delete liveout_;
    delete context_;
    delete synthetic_;
  }
}

void attribute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* attribute::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return attribute_descriptor_;
}

const attribute& attribute::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

attribute* attribute::default_instance_ = NULL;

attribute* attribute::New() const {
  return new attribute;
}

void attribute::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_asm_()) {
      if (asm__ != &::google::protobuf::internal::kEmptyString) {
        asm__->clear();
      }
    }
    address_ = GOOGLE_LONGLONG(0);
    if (has_liveout()) {
      if (liveout_ != NULL) liveout_->::liveout::Clear();
    }
    if (has_strattr()) {
      if (strattr_ != &::google::protobuf::internal::kEmptyString) {
        strattr_->clear();
      }
    }
    if (has_context()) {
      if (context_ != NULL) context_->::context::Clear();
    }
    thread_id_ = GOOGLE_ULONGLONG(0);
    if (has_synthetic()) {
      if (synthetic_ != NULL) synthetic_->::synthetic::Clear();
    }
    if (has_other()) {
      if (other_ != &::google::protobuf::internal::kEmptyString) {
        other_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool attribute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string asm = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_asm_()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->asm_().data(), this->asm_().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_address;
        break;
      }
      
      // optional sint64 address = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &address_)));
          set_has_address();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_liveout;
        break;
      }
      
      // optional .liveout liveout = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_liveout:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_liveout()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_strattr;
        break;
      }
      
      // optional string strattr = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_strattr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_strattr()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->strattr().data(), this->strattr().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_context;
        break;
      }
      
      // optional .context context = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_context()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_thread_id;
        break;
      }
      
      // optional uint64 thread_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_thread_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &thread_id_)));
          set_has_thread_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_synthetic;
        break;
      }
      
      // optional .synthetic synthetic = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_synthetic:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_synthetic()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_other;
        break;
      }
      
      // optional string other = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_other:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_other()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->other().data(), this->other().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void attribute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string asm = 1;
  if (has_asm_()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->asm_().data(), this->asm_().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->asm_(), output);
  }
  
  // optional sint64 address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(2, this->address(), output);
  }
  
  // optional .liveout liveout = 3;
  if (has_liveout()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->liveout(), output);
  }
  
  // optional string strattr = 4;
  if (has_strattr()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->strattr().data(), this->strattr().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->strattr(), output);
  }
  
  // optional .context context = 5;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->context(), output);
  }
  
  // optional uint64 thread_id = 6;
  if (has_thread_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->thread_id(), output);
  }
  
  // optional .synthetic synthetic = 7;
  if (has_synthetic()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->synthetic(), output);
  }
  
  // optional string other = 8;
  if (has_other()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->other().data(), this->other().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->other(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* attribute::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string asm = 1;
  if (has_asm_()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->asm_().data(), this->asm_().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->asm_(), target);
  }
  
  // optional sint64 address = 2;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(2, this->address(), target);
  }
  
  // optional .liveout liveout = 3;
  if (has_liveout()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->liveout(), target);
  }
  
  // optional string strattr = 4;
  if (has_strattr()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->strattr().data(), this->strattr().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->strattr(), target);
  }
  
  // optional .context context = 5;
  if (has_context()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->context(), target);
  }
  
  // optional uint64 thread_id = 6;
  if (has_thread_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->thread_id(), target);
  }
  
  // optional .synthetic synthetic = 7;
  if (has_synthetic()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->synthetic(), target);
  }
  
  // optional string other = 8;
  if (has_other()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->other().data(), this->other().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->other(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int attribute::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string asm = 1;
    if (has_asm_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->asm_());
    }
    
    // optional sint64 address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->address());
    }
    
    // optional .liveout liveout = 3;
    if (has_liveout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->liveout());
    }
    
    // optional string strattr = 4;
    if (has_strattr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->strattr());
    }
    
    // optional .context context = 5;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->context());
    }
    
    // optional uint64 thread_id = 6;
    if (has_thread_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->thread_id());
    }
    
    // optional .synthetic synthetic = 7;
    if (has_synthetic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->synthetic());
    }
    
    // optional string other = 8;
    if (has_other()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->other());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void attribute::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const attribute* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const attribute*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void attribute::MergeFrom(const attribute& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_asm_()) {
      set_asm_(from.asm_());
    }
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_liveout()) {
      mutable_liveout()->::liveout::MergeFrom(from.liveout());
    }
    if (from.has_strattr()) {
      set_strattr(from.strattr());
    }
    if (from.has_context()) {
      mutable_context()->::context::MergeFrom(from.context());
    }
    if (from.has_thread_id()) {
      set_thread_id(from.thread_id());
    }
    if (from.has_synthetic()) {
      mutable_synthetic()->::synthetic::MergeFrom(from.synthetic());
    }
    if (from.has_other()) {
      set_other(from.other());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void attribute::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void attribute::CopyFrom(const attribute& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool attribute::IsInitialized() const {
  
  if (has_context()) {
    if (!this->context().IsInitialized()) return false;
  }
  return true;
}

void attribute::Swap(attribute* other) {
  if (other != this) {
    std::swap(asm__, other->asm__);
    std::swap(address_, other->address_);
    std::swap(liveout_, other->liveout_);
    std::swap(strattr_, other->strattr_);
    std::swap(context_, other->context_);
    std::swap(thread_id_, other->thread_id_);
    std::swap(synthetic_, other->synthetic_);
    std::swap(other_, other->other_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata attribute::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = attribute_descriptor_;
  metadata.reflection = attribute_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int attributes::kElemFieldNumber;
#endif  // !_MSC_VER

attributes::attributes()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void attributes::InitAsDefaultInstance() {
}

attributes::attributes(const attributes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void attributes::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

attributes::~attributes() {
  SharedDtor();
}

void attributes::SharedDtor() {
  if (this != default_instance_) {
  }
}

void attributes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* attributes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return attributes_descriptor_;
}

const attributes& attributes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

attributes* attributes::default_instance_ = NULL;

attributes* attributes::New() const {
  return new attributes;
}

void attributes::Clear() {
  elem_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool attributes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .attribute elem = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_elem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_elem()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_elem;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void attributes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .attribute elem = 1;
  for (int i = 0; i < this->elem_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->elem(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* attributes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .attribute elem = 1;
  for (int i = 0; i < this->elem_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->elem(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int attributes::ByteSize() const {
  int total_size = 0;
  
  // repeated .attribute elem = 1;
  total_size += 1 * this->elem_size();
  for (int i = 0; i < this->elem_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->elem(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void attributes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const attributes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const attributes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void attributes::MergeFrom(const attributes& from) {
  GOOGLE_CHECK_NE(&from, this);
  elem_.MergeFrom(from.elem_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void attributes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void attributes::CopyFrom(const attributes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool attributes::IsInitialized() const {
  
  for (int i = 0; i < elem_size(); i++) {
    if (!this->elem(i).IsInitialized()) return false;
  }
  return true;
}

void attributes::Swap(attributes* other) {
  if (other != this) {
    elem_.Swap(&other->elem_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata attributes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = attributes_descriptor_;
  metadata.reflection = attributes_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

liveout::liveout()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void liveout::InitAsDefaultInstance() {
}

liveout::liveout(const liveout& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void liveout::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

liveout::~liveout() {
  SharedDtor();
}

void liveout::SharedDtor() {
  if (this != default_instance_) {
  }
}

void liveout::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* liveout::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return liveout_descriptor_;
}

const liveout& liveout::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

liveout* liveout::default_instance_ = NULL;

liveout* liveout::New() const {
  return new liveout;
}

void liveout::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool liveout::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void liveout::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* liveout::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int liveout::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void liveout::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const liveout* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const liveout*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void liveout::MergeFrom(const liveout& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void liveout::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void liveout::CopyFrom(const liveout& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool liveout::IsInitialized() const {
  
  return true;
}

void liveout::Swap(liveout* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata liveout::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = liveout_descriptor_;
  metadata.reflection = liveout_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

synthetic::synthetic()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void synthetic::InitAsDefaultInstance() {
}

synthetic::synthetic(const synthetic& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void synthetic::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

synthetic::~synthetic() {
  SharedDtor();
}

void synthetic::SharedDtor() {
  if (this != default_instance_) {
  }
}

void synthetic::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* synthetic::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return synthetic_descriptor_;
}

const synthetic& synthetic::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

synthetic* synthetic::default_instance_ = NULL;

synthetic* synthetic::New() const {
  return new synthetic;
}

void synthetic::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool synthetic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void synthetic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* synthetic::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int synthetic::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void synthetic::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const synthetic* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const synthetic*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void synthetic::MergeFrom(const synthetic& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void synthetic::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void synthetic::CopyFrom(const synthetic& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool synthetic::IsInitialized() const {
  
  return true;
}

void synthetic::Swap(synthetic* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata synthetic::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = synthetic_descriptor_;
  metadata.reflection = synthetic_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int operand_info_specific::kMemOperandFieldNumber;
const int operand_info_specific::kRegOperandFieldNumber;
#endif  // !_MSC_VER

operand_info_specific::operand_info_specific()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void operand_info_specific::InitAsDefaultInstance() {
  mem_operand_ = const_cast< ::mem_operand*>(&::mem_operand::default_instance());
  reg_operand_ = const_cast< ::reg_operand*>(&::reg_operand::default_instance());
}

operand_info_specific::operand_info_specific(const operand_info_specific& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void operand_info_specific::SharedCtor() {
  _cached_size_ = 0;
  mem_operand_ = NULL;
  reg_operand_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

operand_info_specific::~operand_info_specific() {
  SharedDtor();
}

void operand_info_specific::SharedDtor() {
  if (this != default_instance_) {
    delete mem_operand_;
    delete reg_operand_;
  }
}

void operand_info_specific::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* operand_info_specific::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return operand_info_specific_descriptor_;
}

const operand_info_specific& operand_info_specific::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

operand_info_specific* operand_info_specific::default_instance_ = NULL;

operand_info_specific* operand_info_specific::New() const {
  return new operand_info_specific;
}

void operand_info_specific::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mem_operand()) {
      if (mem_operand_ != NULL) mem_operand_->::mem_operand::Clear();
    }
    if (has_reg_operand()) {
      if (reg_operand_ != NULL) reg_operand_->::reg_operand::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool operand_info_specific::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mem_operand mem_operand = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mem_operand()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reg_operand;
        break;
      }
      
      // optional .reg_operand reg_operand = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reg_operand:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reg_operand()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void operand_info_specific::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mem_operand mem_operand = 1;
  if (has_mem_operand()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->mem_operand(), output);
  }
  
  // optional .reg_operand reg_operand = 2;
  if (has_reg_operand()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->reg_operand(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* operand_info_specific::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .mem_operand mem_operand = 1;
  if (has_mem_operand()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->mem_operand(), target);
  }
  
  // optional .reg_operand reg_operand = 2;
  if (has_reg_operand()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->reg_operand(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int operand_info_specific::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mem_operand mem_operand = 1;
    if (has_mem_operand()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mem_operand());
    }
    
    // optional .reg_operand reg_operand = 2;
    if (has_reg_operand()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reg_operand());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void operand_info_specific::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const operand_info_specific* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const operand_info_specific*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void operand_info_specific::MergeFrom(const operand_info_specific& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mem_operand()) {
      mutable_mem_operand()->::mem_operand::MergeFrom(from.mem_operand());
    }
    if (from.has_reg_operand()) {
      mutable_reg_operand()->::reg_operand::MergeFrom(from.reg_operand());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void operand_info_specific::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void operand_info_specific::CopyFrom(const operand_info_specific& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool operand_info_specific::IsInitialized() const {
  
  if (has_mem_operand()) {
    if (!this->mem_operand().IsInitialized()) return false;
  }
  if (has_reg_operand()) {
    if (!this->reg_operand().IsInitialized()) return false;
  }
  return true;
}

void operand_info_specific::Swap(operand_info_specific* other) {
  if (other != this) {
    std::swap(mem_operand_, other->mem_operand_);
    std::swap(reg_operand_, other->reg_operand_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata operand_info_specific::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = operand_info_specific_descriptor_;
  metadata.reflection = operand_info_specific_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int reg_operand::kNameFieldNumber;
#endif  // !_MSC_VER

reg_operand::reg_operand()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void reg_operand::InitAsDefaultInstance() {
}

reg_operand::reg_operand(const reg_operand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void reg_operand::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

reg_operand::~reg_operand() {
  SharedDtor();
}

void reg_operand::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void reg_operand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* reg_operand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return reg_operand_descriptor_;
}

const reg_operand& reg_operand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

reg_operand* reg_operand::default_instance_ = NULL;

reg_operand* reg_operand::New() const {
  return new reg_operand;
}

void reg_operand::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool reg_operand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void reg_operand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* reg_operand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int reg_operand::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void reg_operand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const reg_operand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const reg_operand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void reg_operand::MergeFrom(const reg_operand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void reg_operand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void reg_operand::CopyFrom(const reg_operand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool reg_operand::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void reg_operand::Swap(reg_operand* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata reg_operand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = reg_operand_descriptor_;
  metadata.reflection = reg_operand_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int operand_usage::kReadFieldNumber;
const int operand_usage::kWrittenFieldNumber;
const int operand_usage::kIndexFieldNumber;
const int operand_usage::kBaseFieldNumber;
#endif  // !_MSC_VER

operand_usage::operand_usage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void operand_usage::InitAsDefaultInstance() {
}

operand_usage::operand_usage(const operand_usage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void operand_usage::SharedCtor() {
  _cached_size_ = 0;
  read_ = false;
  written_ = false;
  index_ = false;
  base_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

operand_usage::~operand_usage() {
  SharedDtor();
}

void operand_usage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void operand_usage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* operand_usage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return operand_usage_descriptor_;
}

const operand_usage& operand_usage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

operand_usage* operand_usage::default_instance_ = NULL;

operand_usage* operand_usage::New() const {
  return new operand_usage;
}

void operand_usage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    read_ = false;
    written_ = false;
    index_ = false;
    base_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool operand_usage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool read = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &read_)));
          set_has_read();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_written;
        break;
      }
      
      // required bool written = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_written:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &written_)));
          set_has_written();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }
      
      // required bool index = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_base;
        break;
      }
      
      // required bool base = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_base:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &base_)));
          set_has_base();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void operand_usage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool read = 1;
  if (has_read()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->read(), output);
  }
  
  // required bool written = 2;
  if (has_written()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->written(), output);
  }
  
  // required bool index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->index(), output);
  }
  
  // required bool base = 4;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->base(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* operand_usage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool read = 1;
  if (has_read()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->read(), target);
  }
  
  // required bool written = 2;
  if (has_written()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->written(), target);
  }
  
  // required bool index = 3;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->index(), target);
  }
  
  // required bool base = 4;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->base(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int operand_usage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool read = 1;
    if (has_read()) {
      total_size += 1 + 1;
    }
    
    // required bool written = 2;
    if (has_written()) {
      total_size += 1 + 1;
    }
    
    // required bool index = 3;
    if (has_index()) {
      total_size += 1 + 1;
    }
    
    // required bool base = 4;
    if (has_base()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void operand_usage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const operand_usage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const operand_usage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void operand_usage::MergeFrom(const operand_usage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_read()) {
      set_read(from.read());
    }
    if (from.has_written()) {
      set_written(from.written());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_base()) {
      set_base(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void operand_usage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void operand_usage::CopyFrom(const operand_usage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool operand_usage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void operand_usage::Swap(operand_usage* other) {
  if (other != this) {
    std::swap(read_, other->read_);
    std::swap(written_, other->written_);
    std::swap(index_, other->index_);
    std::swap(base_, other->base_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata operand_usage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = operand_usage_descriptor_;
  metadata.reflection = operand_usage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int mem_operand::kAddressFieldNumber;
#endif  // !_MSC_VER

mem_operand::mem_operand()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void mem_operand::InitAsDefaultInstance() {
}

mem_operand::mem_operand(const mem_operand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void mem_operand::SharedCtor() {
  _cached_size_ = 0;
  address_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

mem_operand::~mem_operand() {
  SharedDtor();
}

void mem_operand::SharedDtor() {
  if (this != default_instance_) {
  }
}

void mem_operand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* mem_operand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return mem_operand_descriptor_;
}

const mem_operand& mem_operand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

mem_operand* mem_operand::default_instance_ = NULL;

mem_operand* mem_operand::New() const {
  return new mem_operand;
}

void mem_operand::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    address_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool mem_operand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required sint64 address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &address_)));
          set_has_address();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void mem_operand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required sint64 address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(1, this->address(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* mem_operand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required sint64 address = 1;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(1, this->address(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int mem_operand::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required sint64 address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->address());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void mem_operand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const mem_operand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const mem_operand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void mem_operand::MergeFrom(const mem_operand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void mem_operand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void mem_operand::CopyFrom(const mem_operand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool mem_operand::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void mem_operand::Swap(mem_operand* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata mem_operand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = mem_operand_descriptor_;
  metadata.reflection = mem_operand_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int taint_info::kNoTaintFieldNumber;
const int taint_info::kTaintIdFieldNumber;
const int taint_info::kTaintMultipleFieldNumber;
#endif  // !_MSC_VER

taint_info::taint_info()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void taint_info::InitAsDefaultInstance() {
}

taint_info::taint_info(const taint_info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void taint_info::SharedCtor() {
  _cached_size_ = 0;
  no_taint_ = false;
  taint_id_ = GOOGLE_ULONGLONG(0);
  taint_multiple_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

taint_info::~taint_info() {
  SharedDtor();
}

void taint_info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void taint_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* taint_info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return taint_info_descriptor_;
}

const taint_info& taint_info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

taint_info* taint_info::default_instance_ = NULL;

taint_info* taint_info::New() const {
  return new taint_info;
}

void taint_info::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    no_taint_ = false;
    taint_id_ = GOOGLE_ULONGLONG(0);
    taint_multiple_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool taint_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool no_taint = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &no_taint_)));
          set_has_no_taint();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_taint_id;
        break;
      }
      
      // optional uint64 taint_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_taint_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &taint_id_)));
          set_has_taint_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_taint_multiple;
        break;
      }
      
      // optional bool taint_multiple = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_taint_multiple:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &taint_multiple_)));
          set_has_taint_multiple();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void taint_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool no_taint = 1;
  if (has_no_taint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->no_taint(), output);
  }
  
  // optional uint64 taint_id = 2;
  if (has_taint_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->taint_id(), output);
  }
  
  // optional bool taint_multiple = 3;
  if (has_taint_multiple()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->taint_multiple(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* taint_info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool no_taint = 1;
  if (has_no_taint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->no_taint(), target);
  }
  
  // optional uint64 taint_id = 2;
  if (has_taint_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->taint_id(), target);
  }
  
  // optional bool taint_multiple = 3;
  if (has_taint_multiple()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->taint_multiple(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int taint_info::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool no_taint = 1;
    if (has_no_taint()) {
      total_size += 1 + 1;
    }
    
    // optional uint64 taint_id = 2;
    if (has_taint_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->taint_id());
    }
    
    // optional bool taint_multiple = 3;
    if (has_taint_multiple()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void taint_info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const taint_info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const taint_info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void taint_info::MergeFrom(const taint_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_no_taint()) {
      set_no_taint(from.no_taint());
    }
    if (from.has_taint_id()) {
      set_taint_id(from.taint_id());
    }
    if (from.has_taint_multiple()) {
      set_taint_multiple(from.taint_multiple());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void taint_info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void taint_info::CopyFrom(const taint_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool taint_info::IsInitialized() const {
  
  return true;
}

void taint_info::Swap(taint_info* other) {
  if (other != this) {
    std::swap(no_taint_, other->no_taint_);
    std::swap(taint_id_, other->taint_id_);
    std::swap(taint_multiple_, other->taint_multiple_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata taint_info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = taint_info_descriptor_;
  metadata.reflection = taint_info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int context::kOperandInfoSpecificFieldNumber;
const int context::kBitLengthFieldNumber;
const int context::kOperandUsageFieldNumber;
const int context::kTaintInfoFieldNumber;
const int context::kValueFieldNumber;
#endif  // !_MSC_VER

context::context()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void context::InitAsDefaultInstance() {
  operand_info_specific_ = const_cast< ::operand_info_specific*>(&::operand_info_specific::default_instance());
  operand_usage_ = const_cast< ::operand_usage*>(&::operand_usage::default_instance());
  taint_info_ = const_cast< ::taint_info*>(&::taint_info::default_instance());
}

context::context(const context& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void context::SharedCtor() {
  _cached_size_ = 0;
  operand_info_specific_ = NULL;
  bit_length_ = 0;
  operand_usage_ = NULL;
  taint_info_ = NULL;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

context::~context() {
  SharedDtor();
}

void context::SharedDtor() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (this != default_instance_) {
    delete operand_info_specific_;
    delete operand_usage_;
    delete taint_info_;
  }
}

void context::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* context::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return context_descriptor_;
}

const context& context::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

context* context::default_instance_ = NULL;

context* context::New() const {
  return new context;
}

void context::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_operand_info_specific()) {
      if (operand_info_specific_ != NULL) operand_info_specific_->::operand_info_specific::Clear();
    }
    bit_length_ = 0;
    if (has_operand_usage()) {
      if (operand_usage_ != NULL) operand_usage_->::operand_usage::Clear();
    }
    if (has_taint_info()) {
      if (taint_info_ != NULL) taint_info_->::taint_info::Clear();
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool context::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .operand_info_specific operand_info_specific = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_operand_info_specific()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_bit_length;
        break;
      }
      
      // required sint32 bit_length = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bit_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &bit_length_)));
          set_has_bit_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_operand_usage;
        break;
      }
      
      // required .operand_usage operand_usage = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operand_usage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_operand_usage()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_taint_info;
        break;
      }
      
      // required .taint_info taint_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_taint_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_taint_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_value;
        break;
      }
      
      // required string value = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void context::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .operand_info_specific operand_info_specific = 1;
  if (has_operand_info_specific()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->operand_info_specific(), output);
  }
  
  // required sint32 bit_length = 2;
  if (has_bit_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->bit_length(), output);
  }
  
  // required .operand_usage operand_usage = 3;
  if (has_operand_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->operand_usage(), output);
  }
  
  // required .taint_info taint_info = 4;
  if (has_taint_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->taint_info(), output);
  }
  
  // required string value = 5;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->value(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* context::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .operand_info_specific operand_info_specific = 1;
  if (has_operand_info_specific()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->operand_info_specific(), target);
  }
  
  // required sint32 bit_length = 2;
  if (has_bit_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->bit_length(), target);
  }
  
  // required .operand_usage operand_usage = 3;
  if (has_operand_usage()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->operand_usage(), target);
  }
  
  // required .taint_info taint_info = 4;
  if (has_taint_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->taint_info(), target);
  }
  
  // required string value = 5;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->value(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int context::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .operand_info_specific operand_info_specific = 1;
    if (has_operand_info_specific()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->operand_info_specific());
    }
    
    // required sint32 bit_length = 2;
    if (has_bit_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->bit_length());
    }
    
    // required .operand_usage operand_usage = 3;
    if (has_operand_usage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->operand_usage());
    }
    
    // required .taint_info taint_info = 4;
    if (has_taint_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->taint_info());
    }
    
    // required string value = 5;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void context::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const context* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const context*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void context::MergeFrom(const context& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_operand_info_specific()) {
      mutable_operand_info_specific()->::operand_info_specific::MergeFrom(from.operand_info_specific());
    }
    if (from.has_bit_length()) {
      set_bit_length(from.bit_length());
    }
    if (from.has_operand_usage()) {
      mutable_operand_usage()->::operand_usage::MergeFrom(from.operand_usage());
    }
    if (from.has_taint_info()) {
      mutable_taint_info()->::taint_info::MergeFrom(from.taint_info());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void context::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void context::CopyFrom(const context& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool context::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  if (has_operand_info_specific()) {
    if (!this->operand_info_specific().IsInitialized()) return false;
  }
  if (has_operand_usage()) {
    if (!this->operand_usage().IsInitialized()) return false;
  }
  return true;
}

void context::Swap(context* other) {
  if (other != this) {
    std::swap(operand_info_specific_, other->operand_info_specific_);
    std::swap(bit_length_, other->bit_length_);
    std::swap(operand_usage_, other->operand_usage_);
    std::swap(taint_info_, other->taint_info_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata context::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = context_descriptor_;
  metadata.reflection = context_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int exp::kLoadFieldNumber;
const int exp::kStoreFieldNumber;
const int exp::kBinopFieldNumber;
const int exp::kUnopFieldNumber;
const int exp::kVarFieldNumber;
const int exp::kLabFieldNumber;
const int exp::kInteFieldNumber;
const int exp::kCastFieldNumber;
const int exp::kLetExpFieldNumber;
const int exp::kUnknownFieldNumber;
const int exp::kIteFieldNumber;
const int exp::kExtractFieldNumber;
const int exp::kConcatFieldNumber;
#endif  // !_MSC_VER

exp::exp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void exp::InitAsDefaultInstance() {
  load_ = const_cast< ::load*>(&::load::default_instance());
  store_ = const_cast< ::store*>(&::store::default_instance());
  binop_ = const_cast< ::binop*>(&::binop::default_instance());
  unop_ = const_cast< ::unop*>(&::unop::default_instance());
  var_ = const_cast< ::var*>(&::var::default_instance());
  inte_ = const_cast< ::inte*>(&::inte::default_instance());
  cast_ = const_cast< ::cast*>(&::cast::default_instance());
  let_exp_ = const_cast< ::let_exp*>(&::let_exp::default_instance());
  unknown_ = const_cast< ::unknown*>(&::unknown::default_instance());
  ite_ = const_cast< ::ite*>(&::ite::default_instance());
  extract_ = const_cast< ::extract*>(&::extract::default_instance());
  concat_ = const_cast< ::concat*>(&::concat::default_instance());
}

exp::exp(const exp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void exp::SharedCtor() {
  _cached_size_ = 0;
  load_ = NULL;
  store_ = NULL;
  binop_ = NULL;
  unop_ = NULL;
  var_ = NULL;
  lab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  inte_ = NULL;
  cast_ = NULL;
  let_exp_ = NULL;
  unknown_ = NULL;
  ite_ = NULL;
  extract_ = NULL;
  concat_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

exp::~exp() {
  SharedDtor();
}

void exp::SharedDtor() {
  if (lab_ != &::google::protobuf::internal::kEmptyString) {
    delete lab_;
  }
  if (this != default_instance_) {
    delete load_;
    delete store_;
    delete binop_;
    delete unop_;
    delete var_;
    delete inte_;
    delete cast_;
    delete let_exp_;
    delete unknown_;
    delete ite_;
    delete extract_;
    delete concat_;
  }
}

void exp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* exp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return exp_descriptor_;
}

const exp& exp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

exp* exp::default_instance_ = NULL;

exp* exp::New() const {
  return new exp;
}

void exp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_load()) {
      if (load_ != NULL) load_->::load::Clear();
    }
    if (has_store()) {
      if (store_ != NULL) store_->::store::Clear();
    }
    if (has_binop()) {
      if (binop_ != NULL) binop_->::binop::Clear();
    }
    if (has_unop()) {
      if (unop_ != NULL) unop_->::unop::Clear();
    }
    if (has_var()) {
      if (var_ != NULL) var_->::var::Clear();
    }
    if (has_lab()) {
      if (lab_ != &::google::protobuf::internal::kEmptyString) {
        lab_->clear();
      }
    }
    if (has_inte()) {
      if (inte_ != NULL) inte_->::inte::Clear();
    }
    if (has_cast()) {
      if (cast_ != NULL) cast_->::cast::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_let_exp()) {
      if (let_exp_ != NULL) let_exp_->::let_exp::Clear();
    }
    if (has_unknown()) {
      if (unknown_ != NULL) unknown_->::unknown::Clear();
    }
    if (has_ite()) {
      if (ite_ != NULL) ite_->::ite::Clear();
    }
    if (has_extract()) {
      if (extract_ != NULL) extract_->::extract::Clear();
    }
    if (has_concat()) {
      if (concat_ != NULL) concat_->::concat::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool exp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .load load = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_load()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_store;
        break;
      }
      
      // optional .store store = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_store:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_store()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_binop;
        break;
      }
      
      // optional .binop binop = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_binop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_binop()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_unop;
        break;
      }
      
      // optional .unop unop = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_unop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unop()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_var;
        break;
      }
      
      // optional .var var = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_var:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_var()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_lab;
        break;
      }
      
      // optional string lab = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lab:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_lab()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->lab().data(), this->lab().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_inte;
        break;
      }
      
      // optional .inte inte = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inte:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inte()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_cast;
        break;
      }
      
      // optional .cast cast = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cast:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cast()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_let_exp;
        break;
      }
      
      // optional .let_exp let_exp = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_let_exp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_let_exp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_unknown;
        break;
      }
      
      // optional .unknown unknown = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_unknown:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unknown()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_ite;
        break;
      }
      
      // optional .ite ite = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ite:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ite()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_extract;
        break;
      }
      
      // optional .extract extract = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_extract:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_extract()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_concat;
        break;
      }
      
      // optional .concat concat = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_concat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_concat()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void exp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .load load = 1;
  if (has_load()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->load(), output);
  }
  
  // optional .store store = 2;
  if (has_store()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->store(), output);
  }
  
  // optional .binop binop = 3;
  if (has_binop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->binop(), output);
  }
  
  // optional .unop unop = 4;
  if (has_unop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->unop(), output);
  }
  
  // optional .var var = 5;
  if (has_var()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->var(), output);
  }
  
  // optional string lab = 6;
  if (has_lab()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->lab().data(), this->lab().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->lab(), output);
  }
  
  // optional .inte inte = 7;
  if (has_inte()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->inte(), output);
  }
  
  // optional .cast cast = 8;
  if (has_cast()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->cast(), output);
  }
  
  // optional .let_exp let_exp = 9;
  if (has_let_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->let_exp(), output);
  }
  
  // optional .unknown unknown = 10;
  if (has_unknown()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->unknown(), output);
  }
  
  // optional .ite ite = 11;
  if (has_ite()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->ite(), output);
  }
  
  // optional .extract extract = 12;
  if (has_extract()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->extract(), output);
  }
  
  // optional .concat concat = 13;
  if (has_concat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->concat(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* exp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .load load = 1;
  if (has_load()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->load(), target);
  }
  
  // optional .store store = 2;
  if (has_store()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->store(), target);
  }
  
  // optional .binop binop = 3;
  if (has_binop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->binop(), target);
  }
  
  // optional .unop unop = 4;
  if (has_unop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->unop(), target);
  }
  
  // optional .var var = 5;
  if (has_var()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->var(), target);
  }
  
  // optional string lab = 6;
  if (has_lab()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->lab().data(), this->lab().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->lab(), target);
  }
  
  // optional .inte inte = 7;
  if (has_inte()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->inte(), target);
  }
  
  // optional .cast cast = 8;
  if (has_cast()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->cast(), target);
  }
  
  // optional .let_exp let_exp = 9;
  if (has_let_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->let_exp(), target);
  }
  
  // optional .unknown unknown = 10;
  if (has_unknown()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->unknown(), target);
  }
  
  // optional .ite ite = 11;
  if (has_ite()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->ite(), target);
  }
  
  // optional .extract extract = 12;
  if (has_extract()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->extract(), target);
  }
  
  // optional .concat concat = 13;
  if (has_concat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->concat(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int exp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .load load = 1;
    if (has_load()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->load());
    }
    
    // optional .store store = 2;
    if (has_store()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->store());
    }
    
    // optional .binop binop = 3;
    if (has_binop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->binop());
    }
    
    // optional .unop unop = 4;
    if (has_unop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unop());
    }
    
    // optional .var var = 5;
    if (has_var()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->var());
    }
    
    // optional string lab = 6;
    if (has_lab()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->lab());
    }
    
    // optional .inte inte = 7;
    if (has_inte()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inte());
    }
    
    // optional .cast cast = 8;
    if (has_cast()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cast());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .let_exp let_exp = 9;
    if (has_let_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->let_exp());
    }
    
    // optional .unknown unknown = 10;
    if (has_unknown()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unknown());
    }
    
    // optional .ite ite = 11;
    if (has_ite()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ite());
    }
    
    // optional .extract extract = 12;
    if (has_extract()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->extract());
    }
    
    // optional .concat concat = 13;
    if (has_concat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->concat());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void exp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const exp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const exp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void exp::MergeFrom(const exp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_load()) {
      mutable_load()->::load::MergeFrom(from.load());
    }
    if (from.has_store()) {
      mutable_store()->::store::MergeFrom(from.store());
    }
    if (from.has_binop()) {
      mutable_binop()->::binop::MergeFrom(from.binop());
    }
    if (from.has_unop()) {
      mutable_unop()->::unop::MergeFrom(from.unop());
    }
    if (from.has_var()) {
      mutable_var()->::var::MergeFrom(from.var());
    }
    if (from.has_lab()) {
      set_lab(from.lab());
    }
    if (from.has_inte()) {
      mutable_inte()->::inte::MergeFrom(from.inte());
    }
    if (from.has_cast()) {
      mutable_cast()->::cast::MergeFrom(from.cast());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_let_exp()) {
      mutable_let_exp()->::let_exp::MergeFrom(from.let_exp());
    }
    if (from.has_unknown()) {
      mutable_unknown()->::unknown::MergeFrom(from.unknown());
    }
    if (from.has_ite()) {
      mutable_ite()->::ite::MergeFrom(from.ite());
    }
    if (from.has_extract()) {
      mutable_extract()->::extract::MergeFrom(from.extract());
    }
    if (from.has_concat()) {
      mutable_concat()->::concat::MergeFrom(from.concat());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void exp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void exp::CopyFrom(const exp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool exp::IsInitialized() const {
  
  if (has_load()) {
    if (!this->load().IsInitialized()) return false;
  }
  if (has_store()) {
    if (!this->store().IsInitialized()) return false;
  }
  if (has_binop()) {
    if (!this->binop().IsInitialized()) return false;
  }
  if (has_unop()) {
    if (!this->unop().IsInitialized()) return false;
  }
  if (has_var()) {
    if (!this->var().IsInitialized()) return false;
  }
  if (has_inte()) {
    if (!this->inte().IsInitialized()) return false;
  }
  if (has_cast()) {
    if (!this->cast().IsInitialized()) return false;
  }
  if (has_let_exp()) {
    if (!this->let_exp().IsInitialized()) return false;
  }
  if (has_unknown()) {
    if (!this->unknown().IsInitialized()) return false;
  }
  if (has_ite()) {
    if (!this->ite().IsInitialized()) return false;
  }
  if (has_extract()) {
    if (!this->extract().IsInitialized()) return false;
  }
  if (has_concat()) {
    if (!this->concat().IsInitialized()) return false;
  }
  return true;
}

void exp::Swap(exp* other) {
  if (other != this) {
    std::swap(load_, other->load_);
    std::swap(store_, other->store_);
    std::swap(binop_, other->binop_);
    std::swap(unop_, other->unop_);
    std::swap(var_, other->var_);
    std::swap(lab_, other->lab_);
    std::swap(inte_, other->inte_);
    std::swap(cast_, other->cast_);
    std::swap(let_exp_, other->let_exp_);
    std::swap(unknown_, other->unknown_);
    std::swap(ite_, other->ite_);
    std::swap(extract_, other->extract_);
    std::swap(concat_, other->concat_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata exp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = exp_descriptor_;
  metadata.reflection = exp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int load::kMemoryFieldNumber;
const int load::kAddressFieldNumber;
const int load::kEndianFieldNumber;
const int load::kTypFieldNumber;
#endif  // !_MSC_VER

load::load()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void load::InitAsDefaultInstance() {
  memory_ = const_cast< ::exp*>(&::exp::default_instance());
  address_ = const_cast< ::exp*>(&::exp::default_instance());
  endian_ = const_cast< ::exp*>(&::exp::default_instance());
  typ_ = const_cast< ::typ*>(&::typ::default_instance());
}

load::load(const load& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void load::SharedCtor() {
  _cached_size_ = 0;
  memory_ = NULL;
  address_ = NULL;
  endian_ = NULL;
  typ_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

load::~load() {
  SharedDtor();
}

void load::SharedDtor() {
  if (this != default_instance_) {
    delete memory_;
    delete address_;
    delete endian_;
    delete typ_;
  }
}

void load::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* load::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return load_descriptor_;
}

const load& load::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

load* load::default_instance_ = NULL;

load* load::New() const {
  return new load;
}

void load::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_memory()) {
      if (memory_ != NULL) memory_->::exp::Clear();
    }
    if (has_address()) {
      if (address_ != NULL) address_->::exp::Clear();
    }
    if (has_endian()) {
      if (endian_ != NULL) endian_->::exp::Clear();
    }
    if (has_typ()) {
      if (typ_ != NULL) typ_->::typ::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool load::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .exp memory = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_memory()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_address;
        break;
      }
      
      // required .exp address = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_endian;
        break;
      }
      
      // required .exp endian = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_endian:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_endian()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_typ;
        break;
      }
      
      // required .typ typ = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_typ:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_typ()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void load::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .exp memory = 1;
  if (has_memory()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->memory(), output);
  }
  
  // required .exp address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->address(), output);
  }
  
  // required .exp endian = 3;
  if (has_endian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->endian(), output);
  }
  
  // required .typ typ = 4;
  if (has_typ()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->typ(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* load::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .exp memory = 1;
  if (has_memory()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->memory(), target);
  }
  
  // required .exp address = 2;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->address(), target);
  }
  
  // required .exp endian = 3;
  if (has_endian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->endian(), target);
  }
  
  // required .typ typ = 4;
  if (has_typ()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->typ(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int load::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .exp memory = 1;
    if (has_memory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->memory());
    }
    
    // required .exp address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->address());
    }
    
    // required .exp endian = 3;
    if (has_endian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->endian());
    }
    
    // required .typ typ = 4;
    if (has_typ()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->typ());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void load::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const load* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const load*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void load::MergeFrom(const load& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_memory()) {
      mutable_memory()->::exp::MergeFrom(from.memory());
    }
    if (from.has_address()) {
      mutable_address()->::exp::MergeFrom(from.address());
    }
    if (from.has_endian()) {
      mutable_endian()->::exp::MergeFrom(from.endian());
    }
    if (from.has_typ()) {
      mutable_typ()->::typ::MergeFrom(from.typ());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void load::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void load::CopyFrom(const load& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool load::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_memory()) {
    if (!this->memory().IsInitialized()) return false;
  }
  if (has_address()) {
    if (!this->address().IsInitialized()) return false;
  }
  if (has_endian()) {
    if (!this->endian().IsInitialized()) return false;
  }
  if (has_typ()) {
    if (!this->typ().IsInitialized()) return false;
  }
  return true;
}

void load::Swap(load* other) {
  if (other != this) {
    std::swap(memory_, other->memory_);
    std::swap(address_, other->address_);
    std::swap(endian_, other->endian_);
    std::swap(typ_, other->typ_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata load::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = load_descriptor_;
  metadata.reflection = load_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int store::kMemoryFieldNumber;
const int store::kAddressFieldNumber;
const int store::kValueFieldNumber;
const int store::kEndianFieldNumber;
const int store::kTypFieldNumber;
#endif  // !_MSC_VER

store::store()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void store::InitAsDefaultInstance() {
  memory_ = const_cast< ::exp*>(&::exp::default_instance());
  address_ = const_cast< ::exp*>(&::exp::default_instance());
  value_ = const_cast< ::exp*>(&::exp::default_instance());
  endian_ = const_cast< ::exp*>(&::exp::default_instance());
  typ_ = const_cast< ::typ*>(&::typ::default_instance());
}

store::store(const store& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void store::SharedCtor() {
  _cached_size_ = 0;
  memory_ = NULL;
  address_ = NULL;
  value_ = NULL;
  endian_ = NULL;
  typ_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

store::~store() {
  SharedDtor();
}

void store::SharedDtor() {
  if (this != default_instance_) {
    delete memory_;
    delete address_;
    delete value_;
    delete endian_;
    delete typ_;
  }
}

void store::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* store::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return store_descriptor_;
}

const store& store::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

store* store::default_instance_ = NULL;

store* store::New() const {
  return new store;
}

void store::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_memory()) {
      if (memory_ != NULL) memory_->::exp::Clear();
    }
    if (has_address()) {
      if (address_ != NULL) address_->::exp::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::exp::Clear();
    }
    if (has_endian()) {
      if (endian_ != NULL) endian_->::exp::Clear();
    }
    if (has_typ()) {
      if (typ_ != NULL) typ_->::typ::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool store::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .exp memory = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_memory()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_address;
        break;
      }
      
      // required .exp address = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }
      
      // required .exp value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_endian;
        break;
      }
      
      // required .exp endian = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_endian:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_endian()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_typ;
        break;
      }
      
      // required .typ typ = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_typ:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_typ()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void store::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .exp memory = 1;
  if (has_memory()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->memory(), output);
  }
  
  // required .exp address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->address(), output);
  }
  
  // required .exp value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->value(), output);
  }
  
  // required .exp endian = 4;
  if (has_endian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->endian(), output);
  }
  
  // required .typ typ = 5;
  if (has_typ()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->typ(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* store::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .exp memory = 1;
  if (has_memory()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->memory(), target);
  }
  
  // required .exp address = 2;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->address(), target);
  }
  
  // required .exp value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->value(), target);
  }
  
  // required .exp endian = 4;
  if (has_endian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->endian(), target);
  }
  
  // required .typ typ = 5;
  if (has_typ()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->typ(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int store::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .exp memory = 1;
    if (has_memory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->memory());
    }
    
    // required .exp address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->address());
    }
    
    // required .exp value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }
    
    // required .exp endian = 4;
    if (has_endian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->endian());
    }
    
    // required .typ typ = 5;
    if (has_typ()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->typ());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void store::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const store* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const store*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void store::MergeFrom(const store& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_memory()) {
      mutable_memory()->::exp::MergeFrom(from.memory());
    }
    if (from.has_address()) {
      mutable_address()->::exp::MergeFrom(from.address());
    }
    if (from.has_value()) {
      mutable_value()->::exp::MergeFrom(from.value());
    }
    if (from.has_endian()) {
      mutable_endian()->::exp::MergeFrom(from.endian());
    }
    if (from.has_typ()) {
      mutable_typ()->::typ::MergeFrom(from.typ());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void store::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void store::CopyFrom(const store& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool store::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  if (has_memory()) {
    if (!this->memory().IsInitialized()) return false;
  }
  if (has_address()) {
    if (!this->address().IsInitialized()) return false;
  }
  if (has_value()) {
    if (!this->value().IsInitialized()) return false;
  }
  if (has_endian()) {
    if (!this->endian().IsInitialized()) return false;
  }
  if (has_typ()) {
    if (!this->typ().IsInitialized()) return false;
  }
  return true;
}

void store::Swap(store* other) {
  if (other != this) {
    std::swap(memory_, other->memory_);
    std::swap(address_, other->address_);
    std::swap(value_, other->value_);
    std::swap(endian_, other->endian_);
    std::swap(typ_, other->typ_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata store::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = store_descriptor_;
  metadata.reflection = store_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int binop::kBinopTypeFieldNumber;
const int binop::kLexpFieldNumber;
const int binop::kRexpFieldNumber;
#endif  // !_MSC_VER

binop::binop()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void binop::InitAsDefaultInstance() {
  lexp_ = const_cast< ::exp*>(&::exp::default_instance());
  rexp_ = const_cast< ::exp*>(&::exp::default_instance());
}

binop::binop(const binop& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void binop::SharedCtor() {
  _cached_size_ = 0;
  binop_type_ = 1;
  lexp_ = NULL;
  rexp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

binop::~binop() {
  SharedDtor();
}

void binop::SharedDtor() {
  if (this != default_instance_) {
    delete lexp_;
    delete rexp_;
  }
}

void binop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* binop::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return binop_descriptor_;
}

const binop& binop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

binop* binop::default_instance_ = NULL;

binop* binop::New() const {
  return new binop;
}

void binop::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    binop_type_ = 1;
    if (has_lexp()) {
      if (lexp_ != NULL) lexp_->::exp::Clear();
    }
    if (has_rexp()) {
      if (rexp_ != NULL) rexp_->::exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool binop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .binop_type binop_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (binop_type_IsValid(value)) {
            set_binop_type(static_cast< binop_type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_lexp;
        break;
      }
      
      // required .exp lexp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lexp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lexp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_rexp;
        break;
      }
      
      // required .exp rexp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rexp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rexp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void binop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .binop_type binop_type = 1;
  if (has_binop_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->binop_type(), output);
  }
  
  // required .exp lexp = 2;
  if (has_lexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->lexp(), output);
  }
  
  // required .exp rexp = 3;
  if (has_rexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->rexp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* binop::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .binop_type binop_type = 1;
  if (has_binop_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->binop_type(), target);
  }
  
  // required .exp lexp = 2;
  if (has_lexp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->lexp(), target);
  }
  
  // required .exp rexp = 3;
  if (has_rexp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->rexp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int binop::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .binop_type binop_type = 1;
    if (has_binop_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->binop_type());
    }
    
    // required .exp lexp = 2;
    if (has_lexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lexp());
    }
    
    // required .exp rexp = 3;
    if (has_rexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rexp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void binop::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const binop* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const binop*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void binop::MergeFrom(const binop& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_binop_type()) {
      set_binop_type(from.binop_type());
    }
    if (from.has_lexp()) {
      mutable_lexp()->::exp::MergeFrom(from.lexp());
    }
    if (from.has_rexp()) {
      mutable_rexp()->::exp::MergeFrom(from.rexp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void binop::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void binop::CopyFrom(const binop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool binop::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_lexp()) {
    if (!this->lexp().IsInitialized()) return false;
  }
  if (has_rexp()) {
    if (!this->rexp().IsInitialized()) return false;
  }
  return true;
}

void binop::Swap(binop* other) {
  if (other != this) {
    std::swap(binop_type_, other->binop_type_);
    std::swap(lexp_, other->lexp_);
    std::swap(rexp_, other->rexp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata binop::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = binop_descriptor_;
  metadata.reflection = binop_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int unop::kUnopTypeFieldNumber;
const int unop::kExpFieldNumber;
#endif  // !_MSC_VER

unop::unop()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void unop::InitAsDefaultInstance() {
  exp_ = const_cast< ::exp*>(&::exp::default_instance());
}

unop::unop(const unop& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void unop::SharedCtor() {
  _cached_size_ = 0;
  unop_type_ = 1;
  exp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

unop::~unop() {
  SharedDtor();
}

void unop::SharedDtor() {
  if (this != default_instance_) {
    delete exp_;
  }
}

void unop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* unop::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return unop_descriptor_;
}

const unop& unop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

unop* unop::default_instance_ = NULL;

unop* unop::New() const {
  return new unop;
}

void unop::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    unop_type_ = 1;
    if (has_exp()) {
      if (exp_ != NULL) exp_->::exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool unop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .unop_type unop_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (unop_type_IsValid(value)) {
            set_unop_type(static_cast< unop_type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_exp;
        break;
      }
      
      // required .exp exp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void unop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .unop_type unop_type = 1;
  if (has_unop_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->unop_type(), output);
  }
  
  // required .exp exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->exp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* unop::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .unop_type unop_type = 1;
  if (has_unop_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->unop_type(), target);
  }
  
  // required .exp exp = 2;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->exp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int unop::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .unop_type unop_type = 1;
    if (has_unop_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->unop_type());
    }
    
    // required .exp exp = 2;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void unop::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const unop* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const unop*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void unop::MergeFrom(const unop& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unop_type()) {
      set_unop_type(from.unop_type());
    }
    if (from.has_exp()) {
      mutable_exp()->::exp::MergeFrom(from.exp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void unop::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void unop::CopyFrom(const unop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool unop::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_exp()) {
    if (!this->exp().IsInitialized()) return false;
  }
  return true;
}

void unop::Swap(unop* other) {
  if (other != this) {
    std::swap(unop_type_, other->unop_type_);
    std::swap(exp_, other->exp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata unop::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = unop_descriptor_;
  metadata.reflection = unop_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int inte::kIntFieldNumber;
const int inte::kTypFieldNumber;
#endif  // !_MSC_VER

inte::inte()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void inte::InitAsDefaultInstance() {
  typ_ = const_cast< ::typ*>(&::typ::default_instance());
}

inte::inte(const inte& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void inte::SharedCtor() {
  _cached_size_ = 0;
  int__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  typ_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

inte::~inte() {
  SharedDtor();
}

void inte::SharedDtor() {
  if (int__ != &::google::protobuf::internal::kEmptyString) {
    delete int__;
  }
  if (this != default_instance_) {
    delete typ_;
  }
}

void inte::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* inte::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return inte_descriptor_;
}

const inte& inte::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

inte* inte::default_instance_ = NULL;

inte* inte::New() const {
  return new inte;
}

void inte::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_int_()) {
      if (int__ != &::google::protobuf::internal::kEmptyString) {
        int__->clear();
      }
    }
    if (has_typ()) {
      if (typ_ != NULL) typ_->::typ::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool inte::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string int = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_int_()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->int_().data(), this->int_().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_typ;
        break;
      }
      
      // required .typ typ = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_typ:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_typ()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void inte::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string int = 1;
  if (has_int_()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->int_().data(), this->int_().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->int_(), output);
  }
  
  // required .typ typ = 2;
  if (has_typ()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->typ(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* inte::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string int = 1;
  if (has_int_()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->int_().data(), this->int_().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->int_(), target);
  }
  
  // required .typ typ = 2;
  if (has_typ()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->typ(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int inte::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string int = 1;
    if (has_int_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->int_());
    }
    
    // required .typ typ = 2;
    if (has_typ()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->typ());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void inte::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const inte* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const inte*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void inte::MergeFrom(const inte& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_int_()) {
      set_int_(from.int_());
    }
    if (from.has_typ()) {
      mutable_typ()->::typ::MergeFrom(from.typ());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void inte::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void inte::CopyFrom(const inte& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool inte::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_typ()) {
    if (!this->typ().IsInitialized()) return false;
  }
  return true;
}

void inte::Swap(inte* other) {
  if (other != this) {
    std::swap(int__, other->int__);
    std::swap(typ_, other->typ_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata inte::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = inte_descriptor_;
  metadata.reflection = inte_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int cast::kCastTypeFieldNumber;
const int cast::kNewTypeFieldNumber;
const int cast::kExpFieldNumber;
#endif  // !_MSC_VER

cast::cast()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void cast::InitAsDefaultInstance() {
  new_type_ = const_cast< ::typ*>(&::typ::default_instance());
  exp_ = const_cast< ::exp*>(&::exp::default_instance());
}

cast::cast(const cast& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void cast::SharedCtor() {
  _cached_size_ = 0;
  cast_type_ = 1;
  new_type_ = NULL;
  exp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

cast::~cast() {
  SharedDtor();
}

void cast::SharedDtor() {
  if (this != default_instance_) {
    delete new_type_;
    delete exp_;
  }
}

void cast::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* cast::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return cast_descriptor_;
}

const cast& cast::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

cast* cast::default_instance_ = NULL;

cast* cast::New() const {
  return new cast;
}

void cast::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cast_type_ = 1;
    if (has_new_type()) {
      if (new_type_ != NULL) new_type_->::typ::Clear();
    }
    if (has_exp()) {
      if (exp_ != NULL) exp_->::exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool cast::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .cast_type cast_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (cast_type_IsValid(value)) {
            set_cast_type(static_cast< cast_type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_new_type;
        break;
      }
      
      // required .typ new_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_new_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_new_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_exp;
        break;
      }
      
      // required .exp exp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void cast::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .cast_type cast_type = 1;
  if (has_cast_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cast_type(), output);
  }
  
  // required .typ new_type = 2;
  if (has_new_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->new_type(), output);
  }
  
  // required .exp exp = 3;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->exp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* cast::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .cast_type cast_type = 1;
  if (has_cast_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cast_type(), target);
  }
  
  // required .typ new_type = 2;
  if (has_new_type()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->new_type(), target);
  }
  
  // required .exp exp = 3;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->exp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int cast::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .cast_type cast_type = 1;
    if (has_cast_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cast_type());
    }
    
    // required .typ new_type = 2;
    if (has_new_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->new_type());
    }
    
    // required .exp exp = 3;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void cast::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const cast* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const cast*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void cast::MergeFrom(const cast& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cast_type()) {
      set_cast_type(from.cast_type());
    }
    if (from.has_new_type()) {
      mutable_new_type()->::typ::MergeFrom(from.new_type());
    }
    if (from.has_exp()) {
      mutable_exp()->::exp::MergeFrom(from.exp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void cast::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void cast::CopyFrom(const cast& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool cast::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_new_type()) {
    if (!this->new_type().IsInitialized()) return false;
  }
  if (has_exp()) {
    if (!this->exp().IsInitialized()) return false;
  }
  return true;
}

void cast::Swap(cast* other) {
  if (other != this) {
    std::swap(cast_type_, other->cast_type_);
    std::swap(new_type_, other->new_type_);
    std::swap(exp_, other->exp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata cast::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = cast_descriptor_;
  metadata.reflection = cast_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int let_exp::kVarFieldNumber;
const int let_exp::kE1FieldNumber;
const int let_exp::kE2FieldNumber;
#endif  // !_MSC_VER

let_exp::let_exp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void let_exp::InitAsDefaultInstance() {
  var_ = const_cast< ::var*>(&::var::default_instance());
  e1_ = const_cast< ::exp*>(&::exp::default_instance());
  e2_ = const_cast< ::exp*>(&::exp::default_instance());
}

let_exp::let_exp(const let_exp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void let_exp::SharedCtor() {
  _cached_size_ = 0;
  var_ = NULL;
  e1_ = NULL;
  e2_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

let_exp::~let_exp() {
  SharedDtor();
}

void let_exp::SharedDtor() {
  if (this != default_instance_) {
    delete var_;
    delete e1_;
    delete e2_;
  }
}

void let_exp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* let_exp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return let_exp_descriptor_;
}

const let_exp& let_exp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

let_exp* let_exp::default_instance_ = NULL;

let_exp* let_exp::New() const {
  return new let_exp;
}

void let_exp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_var()) {
      if (var_ != NULL) var_->::var::Clear();
    }
    if (has_e1()) {
      if (e1_ != NULL) e1_->::exp::Clear();
    }
    if (has_e2()) {
      if (e2_ != NULL) e2_->::exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool let_exp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .var var = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_var()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_e1;
        break;
      }
      
      // required .exp e1 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_e1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_e1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_e2;
        break;
      }
      
      // required .exp e2 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_e2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_e2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void let_exp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .var var = 1;
  if (has_var()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->var(), output);
  }
  
  // required .exp e1 = 2;
  if (has_e1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->e1(), output);
  }
  
  // required .exp e2 = 3;
  if (has_e2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->e2(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* let_exp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .var var = 1;
  if (has_var()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->var(), target);
  }
  
  // required .exp e1 = 2;
  if (has_e1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->e1(), target);
  }
  
  // required .exp e2 = 3;
  if (has_e2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->e2(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int let_exp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .var var = 1;
    if (has_var()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->var());
    }
    
    // required .exp e1 = 2;
    if (has_e1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->e1());
    }
    
    // required .exp e2 = 3;
    if (has_e2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->e2());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void let_exp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const let_exp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const let_exp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void let_exp::MergeFrom(const let_exp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_var()) {
      mutable_var()->::var::MergeFrom(from.var());
    }
    if (from.has_e1()) {
      mutable_e1()->::exp::MergeFrom(from.e1());
    }
    if (from.has_e2()) {
      mutable_e2()->::exp::MergeFrom(from.e2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void let_exp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void let_exp::CopyFrom(const let_exp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool let_exp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_var()) {
    if (!this->var().IsInitialized()) return false;
  }
  if (has_e1()) {
    if (!this->e1().IsInitialized()) return false;
  }
  if (has_e2()) {
    if (!this->e2().IsInitialized()) return false;
  }
  return true;
}

void let_exp::Swap(let_exp* other) {
  if (other != this) {
    std::swap(var_, other->var_);
    std::swap(e1_, other->e1_);
    std::swap(e2_, other->e2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata let_exp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = let_exp_descriptor_;
  metadata.reflection = let_exp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int unknown::kStringFieldNumber;
const int unknown::kTypFieldNumber;
#endif  // !_MSC_VER

unknown::unknown()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void unknown::InitAsDefaultInstance() {
  typ_ = const_cast< ::typ*>(&::typ::default_instance());
}

unknown::unknown(const unknown& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void unknown::SharedCtor() {
  _cached_size_ = 0;
  string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  typ_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

unknown::~unknown() {
  SharedDtor();
}

void unknown::SharedDtor() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    delete string_;
  }
  if (this != default_instance_) {
    delete typ_;
  }
}

void unknown::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* unknown::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return unknown_descriptor_;
}

const unknown& unknown::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

unknown* unknown::default_instance_ = NULL;

unknown* unknown::New() const {
  return new unknown;
}

void unknown::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_string()) {
      if (string_ != &::google::protobuf::internal::kEmptyString) {
        string_->clear();
      }
    }
    if (has_typ()) {
      if (typ_ != NULL) typ_->::typ::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool unknown::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string string = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_string()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->string().data(), this->string().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_typ;
        break;
      }
      
      // required .typ typ = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_typ:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_typ()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void unknown::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string string = 1;
  if (has_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->string().data(), this->string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->string(), output);
  }
  
  // required .typ typ = 2;
  if (has_typ()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->typ(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* unknown::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string string = 1;
  if (has_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->string().data(), this->string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->string(), target);
  }
  
  // required .typ typ = 2;
  if (has_typ()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->typ(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int unknown::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string string = 1;
    if (has_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->string());
    }
    
    // required .typ typ = 2;
    if (has_typ()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->typ());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void unknown::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const unknown* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const unknown*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void unknown::MergeFrom(const unknown& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_string()) {
      set_string(from.string());
    }
    if (from.has_typ()) {
      mutable_typ()->::typ::MergeFrom(from.typ());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void unknown::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void unknown::CopyFrom(const unknown& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool unknown::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_typ()) {
    if (!this->typ().IsInitialized()) return false;
  }
  return true;
}

void unknown::Swap(unknown* other) {
  if (other != this) {
    std::swap(string_, other->string_);
    std::swap(typ_, other->typ_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata unknown::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = unknown_descriptor_;
  metadata.reflection = unknown_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ite::kConditionFieldNumber;
const int ite::kIftrueFieldNumber;
const int ite::kIffalseFieldNumber;
#endif  // !_MSC_VER

ite::ite()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ite::InitAsDefaultInstance() {
  condition_ = const_cast< ::exp*>(&::exp::default_instance());
  iftrue_ = const_cast< ::exp*>(&::exp::default_instance());
  iffalse_ = const_cast< ::exp*>(&::exp::default_instance());
}

ite::ite(const ite& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ite::SharedCtor() {
  _cached_size_ = 0;
  condition_ = NULL;
  iftrue_ = NULL;
  iffalse_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ite::~ite() {
  SharedDtor();
}

void ite::SharedDtor() {
  if (this != default_instance_) {
    delete condition_;
    delete iftrue_;
    delete iffalse_;
  }
}

void ite::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ite::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ite_descriptor_;
}

const ite& ite::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

ite* ite::default_instance_ = NULL;

ite* ite::New() const {
  return new ite;
}

void ite::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_condition()) {
      if (condition_ != NULL) condition_->::exp::Clear();
    }
    if (has_iftrue()) {
      if (iftrue_ != NULL) iftrue_->::exp::Clear();
    }
    if (has_iffalse()) {
      if (iffalse_ != NULL) iffalse_->::exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ite::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .exp condition = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_condition()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_iftrue;
        break;
      }
      
      // required .exp iftrue = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iftrue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iftrue()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_iffalse;
        break;
      }
      
      // required .exp iffalse = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iffalse:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iffalse()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ite::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .exp condition = 1;
  if (has_condition()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->condition(), output);
  }
  
  // required .exp iftrue = 2;
  if (has_iftrue()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->iftrue(), output);
  }
  
  // required .exp iffalse = 3;
  if (has_iffalse()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->iffalse(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ite::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .exp condition = 1;
  if (has_condition()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->condition(), target);
  }
  
  // required .exp iftrue = 2;
  if (has_iftrue()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->iftrue(), target);
  }
  
  // required .exp iffalse = 3;
  if (has_iffalse()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->iffalse(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ite::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .exp condition = 1;
    if (has_condition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->condition());
    }
    
    // required .exp iftrue = 2;
    if (has_iftrue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iftrue());
    }
    
    // required .exp iffalse = 3;
    if (has_iffalse()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iffalse());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ite::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ite* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ite*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ite::MergeFrom(const ite& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_condition()) {
      mutable_condition()->::exp::MergeFrom(from.condition());
    }
    if (from.has_iftrue()) {
      mutable_iftrue()->::exp::MergeFrom(from.iftrue());
    }
    if (from.has_iffalse()) {
      mutable_iffalse()->::exp::MergeFrom(from.iffalse());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ite::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ite::CopyFrom(const ite& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ite::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_condition()) {
    if (!this->condition().IsInitialized()) return false;
  }
  if (has_iftrue()) {
    if (!this->iftrue().IsInitialized()) return false;
  }
  if (has_iffalse()) {
    if (!this->iffalse().IsInitialized()) return false;
  }
  return true;
}

void ite::Swap(ite* other) {
  if (other != this) {
    std::swap(condition_, other->condition_);
    std::swap(iftrue_, other->iftrue_);
    std::swap(iffalse_, other->iffalse_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ite::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ite_descriptor_;
  metadata.reflection = ite_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int extract::kHbitFieldNumber;
const int extract::kLbitFieldNumber;
const int extract::kExpFieldNumber;
#endif  // !_MSC_VER

extract::extract()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void extract::InitAsDefaultInstance() {
  exp_ = const_cast< ::exp*>(&::exp::default_instance());
}

extract::extract(const extract& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void extract::SharedCtor() {
  _cached_size_ = 0;
  hbit_ = 0;
  lbit_ = 0;
  exp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

extract::~extract() {
  SharedDtor();
}

void extract::SharedDtor() {
  if (this != default_instance_) {
    delete exp_;
  }
}

void extract::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* extract::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return extract_descriptor_;
}

const extract& extract::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

extract* extract::default_instance_ = NULL;

extract* extract::New() const {
  return new extract;
}

void extract::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    hbit_ = 0;
    lbit_ = 0;
    if (has_exp()) {
      if (exp_ != NULL) exp_->::exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool extract::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required sint32 hbit = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &hbit_)));
          set_has_hbit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_lbit;
        break;
      }
      
      // required sint32 lbit = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lbit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &lbit_)));
          set_has_lbit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_exp;
        break;
      }
      
      // required .exp exp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void extract::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required sint32 hbit = 1;
  if (has_hbit()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->hbit(), output);
  }
  
  // required sint32 lbit = 2;
  if (has_lbit()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->lbit(), output);
  }
  
  // required .exp exp = 3;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->exp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* extract::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required sint32 hbit = 1;
  if (has_hbit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->hbit(), target);
  }
  
  // required sint32 lbit = 2;
  if (has_lbit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->lbit(), target);
  }
  
  // required .exp exp = 3;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->exp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int extract::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required sint32 hbit = 1;
    if (has_hbit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->hbit());
    }
    
    // required sint32 lbit = 2;
    if (has_lbit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->lbit());
    }
    
    // required .exp exp = 3;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void extract::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const extract* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const extract*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void extract::MergeFrom(const extract& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hbit()) {
      set_hbit(from.hbit());
    }
    if (from.has_lbit()) {
      set_lbit(from.lbit());
    }
    if (from.has_exp()) {
      mutable_exp()->::exp::MergeFrom(from.exp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void extract::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void extract::CopyFrom(const extract& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool extract::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_exp()) {
    if (!this->exp().IsInitialized()) return false;
  }
  return true;
}

void extract::Swap(extract* other) {
  if (other != this) {
    std::swap(hbit_, other->hbit_);
    std::swap(lbit_, other->lbit_);
    std::swap(exp_, other->exp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata extract::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = extract_descriptor_;
  metadata.reflection = extract_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int concat::kLeFieldNumber;
const int concat::kReFieldNumber;
#endif  // !_MSC_VER

concat::concat()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void concat::InitAsDefaultInstance() {
  le_ = const_cast< ::exp*>(&::exp::default_instance());
  re_ = const_cast< ::exp*>(&::exp::default_instance());
}

concat::concat(const concat& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void concat::SharedCtor() {
  _cached_size_ = 0;
  le_ = NULL;
  re_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

concat::~concat() {
  SharedDtor();
}

void concat::SharedDtor() {
  if (this != default_instance_) {
    delete le_;
    delete re_;
  }
}

void concat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* concat::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return concat_descriptor_;
}

const concat& concat::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stmt_2epiqi_2eproto();  return *default_instance_;
}

concat* concat::default_instance_ = NULL;

concat* concat::New() const {
  return new concat;
}

void concat::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_le()) {
      if (le_ != NULL) le_->::exp::Clear();
    }
    if (has_re()) {
      if (re_ != NULL) re_->::exp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool concat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .exp le = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_le()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_re;
        break;
      }
      
      // required .exp re = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_re:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_re()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void concat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .exp le = 1;
  if (has_le()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->le(), output);
  }
  
  // required .exp re = 2;
  if (has_re()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->re(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* concat::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .exp le = 1;
  if (has_le()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->le(), target);
  }
  
  // required .exp re = 2;
  if (has_re()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->re(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int concat::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .exp le = 1;
    if (has_le()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->le());
    }
    
    // required .exp re = 2;
    if (has_re()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->re());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void concat::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const concat* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const concat*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void concat::MergeFrom(const concat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_le()) {
      mutable_le()->::exp::MergeFrom(from.le());
    }
    if (from.has_re()) {
      mutable_re()->::exp::MergeFrom(from.re());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void concat::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void concat::CopyFrom(const concat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool concat::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_le()) {
    if (!this->le().IsInitialized()) return false;
  }
  if (has_re()) {
    if (!this->re().IsInitialized()) return false;
  }
  return true;
}

void concat::Swap(concat* other) {
  if (other != this) {
    std::swap(le_, other->le_);
    std::swap(re_, other->re_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata concat::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = concat_descriptor_;
  metadata.reflection = concat_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
