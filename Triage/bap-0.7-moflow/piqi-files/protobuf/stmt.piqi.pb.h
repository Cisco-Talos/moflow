// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stmt.piqi.proto

#ifndef PROTOBUF_stmt_2epiqi_2eproto__INCLUDED
#define PROTOBUF_stmt_2epiqi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_stmt_2epiqi_2eproto();
void protobuf_AssignDesc_stmt_2epiqi_2eproto();
void protobuf_ShutdownFile_stmt_2epiqi_2eproto();

class program;
class stmt;
class move;
class jmp;
class cjmp;
class label_stmt;
class halt;
class assert_stmt;
class assume;
class comment;
class special;
class typ;
class tmem;
class array;
class label;
class var;
class attribute;
class attributes;
class liveout;
class synthetic;
class operand_info_specific;
class reg_operand;
class operand_usage;
class mem_operand;
class taint_info;
class context;
class exp;
class load;
class store;
class binop;
class unop;
class inte;
class cast;
class let_exp;
class unknown;
class ite;
class extract;
class concat;

enum cast_type {
  cast_unsigned = 1,
  cast_signed = 2,
  cast_high = 3,
  cast_low = 4
};
bool cast_type_IsValid(int value);
const cast_type cast_type_MIN = cast_unsigned;
const cast_type cast_type_MAX = cast_low;
const int cast_type_ARRAYSIZE = cast_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* cast_type_descriptor();
inline const ::std::string& cast_type_Name(cast_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    cast_type_descriptor(), value);
}
inline bool cast_type_Parse(
    const ::std::string& name, cast_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<cast_type>(
    cast_type_descriptor(), name, value);
}
enum binop_type {
  plus = 1,
  minus = 2,
  times = 3,
  divide = 4,
  sdivide = 5,
  modbop = 6,
  smod = 7,
  lshift = 8,
  rshift = 9,
  arshift = 10,
  andbop = 11,
  orbop = 12,
  xor = 13,
  eq = 14,
  neq = 15,
  lt = 16,
  le = 17,
  slt = 18,
  sle = 19
};
bool binop_type_IsValid(int value);
const binop_type binop_type_MIN = plus;
const binop_type binop_type_MAX = sle;
const int binop_type_ARRAYSIZE = binop_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* binop_type_descriptor();
inline const ::std::string& binop_type_Name(binop_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    binop_type_descriptor(), value);
}
inline bool binop_type_Parse(
    const ::std::string& name, binop_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<binop_type>(
    binop_type_descriptor(), name, value);
}
enum unop_type {
  neg = 1,
  not = 2
};
bool unop_type_IsValid(int value);
const unop_type unop_type_MIN = neg;
const unop_type unop_type_MAX = not;
const int unop_type_ARRAYSIZE = unop_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* unop_type_descriptor();
inline const ::std::string& unop_type_Name(unop_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    unop_type_descriptor(), value);
}
inline bool unop_type_Parse(
    const ::std::string& name, unop_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<unop_type>(
    unop_type_descriptor(), name, value);
}
// ===================================================================

class program : public ::google::protobuf::Message {
 public:
  program();
  virtual ~program();
  
  program(const program& from);
  
  inline program& operator=(const program& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const program& default_instance();
  
  void Swap(program* other);
  
  // implements Message ----------------------------------------------
  
  program* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const program& from);
  void MergeFrom(const program& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .stmt elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::stmt& elem(int index) const;
  inline ::stmt* mutable_elem(int index);
  inline ::stmt* add_elem();
  inline const ::google::protobuf::RepeatedPtrField< ::stmt >&
      elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::stmt >*
      mutable_elem();
  
  // @@protoc_insertion_point(class_scope:program)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::stmt > elem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static program* default_instance_;
};
// -------------------------------------------------------------------

class stmt : public ::google::protobuf::Message {
 public:
  stmt();
  virtual ~stmt();
  
  stmt(const stmt& from);
  
  inline stmt& operator=(const stmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const stmt& default_instance();
  
  void Swap(stmt* other);
  
  // implements Message ----------------------------------------------
  
  stmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stmt& from);
  void MergeFrom(const stmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .move move = 1;
  inline bool has_move() const;
  inline void clear_move();
  static const int kMoveFieldNumber = 1;
  inline const ::move& move() const;
  inline ::move* mutable_move();
  inline ::move* release_move();
  
  // optional .jmp jmp = 2;
  inline bool has_jmp() const;
  inline void clear_jmp();
  static const int kJmpFieldNumber = 2;
  inline const ::jmp& jmp() const;
  inline ::jmp* mutable_jmp();
  inline ::jmp* release_jmp();
  
  // optional .cjmp cjmp = 3;
  inline bool has_cjmp() const;
  inline void clear_cjmp();
  static const int kCjmpFieldNumber = 3;
  inline const ::cjmp& cjmp() const;
  inline ::cjmp* mutable_cjmp();
  inline ::cjmp* release_cjmp();
  
  // optional .label_stmt label_stmt = 4;
  inline bool has_label_stmt() const;
  inline void clear_label_stmt();
  static const int kLabelStmtFieldNumber = 4;
  inline const ::label_stmt& label_stmt() const;
  inline ::label_stmt* mutable_label_stmt();
  inline ::label_stmt* release_label_stmt();
  
  // optional .halt halt = 5;
  inline bool has_halt() const;
  inline void clear_halt();
  static const int kHaltFieldNumber = 5;
  inline const ::halt& halt() const;
  inline ::halt* mutable_halt();
  inline ::halt* release_halt();
  
  // optional .assert_stmt assert_stmt = 6;
  inline bool has_assert_stmt() const;
  inline void clear_assert_stmt();
  static const int kAssertStmtFieldNumber = 6;
  inline const ::assert_stmt& assert_stmt() const;
  inline ::assert_stmt* mutable_assert_stmt();
  inline ::assert_stmt* release_assert_stmt();
  
  // optional .assume assume = 7;
  inline bool has_assume() const;
  inline void clear_assume();
  static const int kAssumeFieldNumber = 7;
  inline const ::assume& assume() const;
  inline ::assume* mutable_assume();
  inline ::assume* release_assume();
  
  // optional .comment comment = 8;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 8;
  inline const ::comment& comment() const;
  inline ::comment* mutable_comment();
  inline ::comment* release_comment();
  
  // optional .special special = 9;
  inline bool has_special() const;
  inline void clear_special();
  static const int kSpecialFieldNumber = 9;
  inline const ::special& special() const;
  inline ::special* mutable_special();
  inline ::special* release_special();
  
  // @@protoc_insertion_point(class_scope:stmt)
 private:
  inline void set_has_move();
  inline void clear_has_move();
  inline void set_has_jmp();
  inline void clear_has_jmp();
  inline void set_has_cjmp();
  inline void clear_has_cjmp();
  inline void set_has_label_stmt();
  inline void clear_has_label_stmt();
  inline void set_has_halt();
  inline void clear_has_halt();
  inline void set_has_assert_stmt();
  inline void clear_has_assert_stmt();
  inline void set_has_assume();
  inline void clear_has_assume();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_special();
  inline void clear_has_special();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::move* move_;
  ::jmp* jmp_;
  ::cjmp* cjmp_;
  ::label_stmt* label_stmt_;
  ::halt* halt_;
  ::assert_stmt* assert_stmt_;
  ::assume* assume_;
  ::comment* comment_;
  ::special* special_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static stmt* default_instance_;
};
// -------------------------------------------------------------------

class move : public ::google::protobuf::Message {
 public:
  move();
  virtual ~move();
  
  move(const move& from);
  
  inline move& operator=(const move& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const move& default_instance();
  
  void Swap(move* other);
  
  // implements Message ----------------------------------------------
  
  move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const move& from);
  void MergeFrom(const move& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .var var = 1;
  inline bool has_var() const;
  inline void clear_var();
  static const int kVarFieldNumber = 1;
  inline const ::var& var() const;
  inline ::var* mutable_var();
  inline ::var* release_var();
  
  // required .exp exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline const ::exp& exp() const;
  inline ::exp* mutable_exp();
  inline ::exp* release_exp();
  
  // required .attributes attributes = 3;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  inline const ::attributes& attributes() const;
  inline ::attributes* mutable_attributes();
  inline ::attributes* release_attributes();
  
  // @@protoc_insertion_point(class_scope:move)
 private:
  inline void set_has_var();
  inline void clear_has_var();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::var* var_;
  ::exp* exp_;
  ::attributes* attributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static move* default_instance_;
};
// -------------------------------------------------------------------

class jmp : public ::google::protobuf::Message {
 public:
  jmp();
  virtual ~jmp();
  
  jmp(const jmp& from);
  
  inline jmp& operator=(const jmp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const jmp& default_instance();
  
  void Swap(jmp* other);
  
  // implements Message ----------------------------------------------
  
  jmp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const jmp& from);
  void MergeFrom(const jmp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .exp exp = 1;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 1;
  inline const ::exp& exp() const;
  inline ::exp* mutable_exp();
  inline ::exp* release_exp();
  
  // required .attributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::attributes& attributes() const;
  inline ::attributes* mutable_attributes();
  inline ::attributes* release_attributes();
  
  // @@protoc_insertion_point(class_scope:jmp)
 private:
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* exp_;
  ::attributes* attributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static jmp* default_instance_;
};
// -------------------------------------------------------------------

class cjmp : public ::google::protobuf::Message {
 public:
  cjmp();
  virtual ~cjmp();
  
  cjmp(const cjmp& from);
  
  inline cjmp& operator=(const cjmp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const cjmp& default_instance();
  
  void Swap(cjmp* other);
  
  // implements Message ----------------------------------------------
  
  cjmp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cjmp& from);
  void MergeFrom(const cjmp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .exp cond = 1;
  inline bool has_cond() const;
  inline void clear_cond();
  static const int kCondFieldNumber = 1;
  inline const ::exp& cond() const;
  inline ::exp* mutable_cond();
  inline ::exp* release_cond();
  
  // required .exp iftrue = 2;
  inline bool has_iftrue() const;
  inline void clear_iftrue();
  static const int kIftrueFieldNumber = 2;
  inline const ::exp& iftrue() const;
  inline ::exp* mutable_iftrue();
  inline ::exp* release_iftrue();
  
  // required .exp iffalse = 3;
  inline bool has_iffalse() const;
  inline void clear_iffalse();
  static const int kIffalseFieldNumber = 3;
  inline const ::exp& iffalse() const;
  inline ::exp* mutable_iffalse();
  inline ::exp* release_iffalse();
  
  // required .attributes attributes = 4;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  inline const ::attributes& attributes() const;
  inline ::attributes* mutable_attributes();
  inline ::attributes* release_attributes();
  
  // @@protoc_insertion_point(class_scope:cjmp)
 private:
  inline void set_has_cond();
  inline void clear_has_cond();
  inline void set_has_iftrue();
  inline void clear_has_iftrue();
  inline void set_has_iffalse();
  inline void clear_has_iffalse();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* cond_;
  ::exp* iftrue_;
  ::exp* iffalse_;
  ::attributes* attributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static cjmp* default_instance_;
};
// -------------------------------------------------------------------

class label_stmt : public ::google::protobuf::Message {
 public:
  label_stmt();
  virtual ~label_stmt();
  
  label_stmt(const label_stmt& from);
  
  inline label_stmt& operator=(const label_stmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const label_stmt& default_instance();
  
  void Swap(label_stmt* other);
  
  // implements Message ----------------------------------------------
  
  label_stmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const label_stmt& from);
  void MergeFrom(const label_stmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .label label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::label& label() const;
  inline ::label* mutable_label();
  inline ::label* release_label();
  
  // required .attributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::attributes& attributes() const;
  inline ::attributes* mutable_attributes();
  inline ::attributes* release_attributes();
  
  // @@protoc_insertion_point(class_scope:label_stmt)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::label* label_;
  ::attributes* attributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static label_stmt* default_instance_;
};
// -------------------------------------------------------------------

class halt : public ::google::protobuf::Message {
 public:
  halt();
  virtual ~halt();
  
  halt(const halt& from);
  
  inline halt& operator=(const halt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const halt& default_instance();
  
  void Swap(halt* other);
  
  // implements Message ----------------------------------------------
  
  halt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const halt& from);
  void MergeFrom(const halt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .exp exp = 1;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 1;
  inline const ::exp& exp() const;
  inline ::exp* mutable_exp();
  inline ::exp* release_exp();
  
  // required .attributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::attributes& attributes() const;
  inline ::attributes* mutable_attributes();
  inline ::attributes* release_attributes();
  
  // @@protoc_insertion_point(class_scope:halt)
 private:
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* exp_;
  ::attributes* attributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static halt* default_instance_;
};
// -------------------------------------------------------------------

class assert_stmt : public ::google::protobuf::Message {
 public:
  assert_stmt();
  virtual ~assert_stmt();
  
  assert_stmt(const assert_stmt& from);
  
  inline assert_stmt& operator=(const assert_stmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const assert_stmt& default_instance();
  
  void Swap(assert_stmt* other);
  
  // implements Message ----------------------------------------------
  
  assert_stmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const assert_stmt& from);
  void MergeFrom(const assert_stmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .exp exp = 1;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 1;
  inline const ::exp& exp() const;
  inline ::exp* mutable_exp();
  inline ::exp* release_exp();
  
  // required .attributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::attributes& attributes() const;
  inline ::attributes* mutable_attributes();
  inline ::attributes* release_attributes();
  
  // @@protoc_insertion_point(class_scope:assert_stmt)
 private:
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* exp_;
  ::attributes* attributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static assert_stmt* default_instance_;
};
// -------------------------------------------------------------------

class assume : public ::google::protobuf::Message {
 public:
  assume();
  virtual ~assume();
  
  assume(const assume& from);
  
  inline assume& operator=(const assume& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const assume& default_instance();
  
  void Swap(assume* other);
  
  // implements Message ----------------------------------------------
  
  assume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const assume& from);
  void MergeFrom(const assume& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .exp exp = 1;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 1;
  inline const ::exp& exp() const;
  inline ::exp* mutable_exp();
  inline ::exp* release_exp();
  
  // required .attributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::attributes& attributes() const;
  inline ::attributes* mutable_attributes();
  inline ::attributes* release_attributes();
  
  // @@protoc_insertion_point(class_scope:assume)
 private:
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* exp_;
  ::attributes* attributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static assume* default_instance_;
};
// -------------------------------------------------------------------

class comment : public ::google::protobuf::Message {
 public:
  comment();
  virtual ~comment();
  
  comment(const comment& from);
  
  inline comment& operator=(const comment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const comment& default_instance();
  
  void Swap(comment* other);
  
  // implements Message ----------------------------------------------
  
  comment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comment& from);
  void MergeFrom(const comment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string string = 1;
  inline bool has_string() const;
  inline void clear_string();
  static const int kStringFieldNumber = 1;
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline void set_string(const char* value, size_t size);
  inline ::std::string* mutable_string();
  inline ::std::string* release_string();
  
  // required .attributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::attributes& attributes() const;
  inline ::attributes* mutable_attributes();
  inline ::attributes* release_attributes();
  
  // @@protoc_insertion_point(class_scope:comment)
 private:
  inline void set_has_string();
  inline void clear_has_string();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* string_;
  ::attributes* attributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static comment* default_instance_;
};
// -------------------------------------------------------------------

class special : public ::google::protobuf::Message {
 public:
  special();
  virtual ~special();
  
  special(const special& from);
  
  inline special& operator=(const special& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const special& default_instance();
  
  void Swap(special* other);
  
  // implements Message ----------------------------------------------
  
  special* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const special& from);
  void MergeFrom(const special& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string string = 1;
  inline bool has_string() const;
  inline void clear_string();
  static const int kStringFieldNumber = 1;
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline void set_string(const char* value, size_t size);
  inline ::std::string* mutable_string();
  inline ::std::string* release_string();
  
  // required .attributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::attributes& attributes() const;
  inline ::attributes* mutable_attributes();
  inline ::attributes* release_attributes();
  
  // @@protoc_insertion_point(class_scope:special)
 private:
  inline void set_has_string();
  inline void clear_has_string();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* string_;
  ::attributes* attributes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static special* default_instance_;
};
// -------------------------------------------------------------------

class typ : public ::google::protobuf::Message {
 public:
  typ();
  virtual ~typ();
  
  typ(const typ& from);
  
  inline typ& operator=(const typ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const typ& default_instance();
  
  void Swap(typ* other);
  
  // implements Message ----------------------------------------------
  
  typ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const typ& from);
  void MergeFrom(const typ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional sint32 reg = 1;
  inline bool has_reg() const;
  inline void clear_reg();
  static const int kRegFieldNumber = 1;
  inline ::google::protobuf::int32 reg() const;
  inline void set_reg(::google::protobuf::int32 value);
  
  // optional .tmem tmem = 2;
  inline bool has_tmem() const;
  inline void clear_tmem();
  static const int kTmemFieldNumber = 2;
  inline const ::tmem& tmem() const;
  inline ::tmem* mutable_tmem();
  inline ::tmem* release_tmem();
  
  // optional .array array = 3;
  inline bool has_array() const;
  inline void clear_array();
  static const int kArrayFieldNumber = 3;
  inline const ::array& array() const;
  inline ::array* mutable_array();
  inline ::array* release_array();
  
  // @@protoc_insertion_point(class_scope:typ)
 private:
  inline void set_has_reg();
  inline void clear_has_reg();
  inline void set_has_tmem();
  inline void clear_has_tmem();
  inline void set_has_array();
  inline void clear_has_array();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::tmem* tmem_;
  ::array* array_;
  ::google::protobuf::int32 reg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static typ* default_instance_;
};
// -------------------------------------------------------------------

class tmem : public ::google::protobuf::Message {
 public:
  tmem();
  virtual ~tmem();
  
  tmem(const tmem& from);
  
  inline tmem& operator=(const tmem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const tmem& default_instance();
  
  void Swap(tmem* other);
  
  // implements Message ----------------------------------------------
  
  tmem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tmem& from);
  void MergeFrom(const tmem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .typ index_type = 1;
  inline bool has_index_type() const;
  inline void clear_index_type();
  static const int kIndexTypeFieldNumber = 1;
  inline const ::typ& index_type() const;
  inline ::typ* mutable_index_type();
  inline ::typ* release_index_type();
  
  // @@protoc_insertion_point(class_scope:tmem)
 private:
  inline void set_has_index_type();
  inline void clear_has_index_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::typ* index_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static tmem* default_instance_;
};
// -------------------------------------------------------------------

class array : public ::google::protobuf::Message {
 public:
  array();
  virtual ~array();
  
  array(const array& from);
  
  inline array& operator=(const array& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const array& default_instance();
  
  void Swap(array* other);
  
  // implements Message ----------------------------------------------
  
  array* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const array& from);
  void MergeFrom(const array& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .typ index_type = 1;
  inline bool has_index_type() const;
  inline void clear_index_type();
  static const int kIndexTypeFieldNumber = 1;
  inline const ::typ& index_type() const;
  inline ::typ* mutable_index_type();
  inline ::typ* release_index_type();
  
  // required .typ element_type = 2;
  inline bool has_element_type() const;
  inline void clear_element_type();
  static const int kElementTypeFieldNumber = 2;
  inline const ::typ& element_type() const;
  inline ::typ* mutable_element_type();
  inline ::typ* release_element_type();
  
  // @@protoc_insertion_point(class_scope:array)
 private:
  inline void set_has_index_type();
  inline void clear_has_index_type();
  inline void set_has_element_type();
  inline void clear_has_element_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::typ* index_type_;
  ::typ* element_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static array* default_instance_;
};
// -------------------------------------------------------------------

class label : public ::google::protobuf::Message {
 public:
  label();
  virtual ~label();
  
  label(const label& from);
  
  inline label& operator=(const label& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const label& default_instance();
  
  void Swap(label* other);
  
  // implements Message ----------------------------------------------
  
  label* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const label& from);
  void MergeFrom(const label& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional sint64 addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 2;
  inline ::google::protobuf::int64 addr() const;
  inline void set_addr(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:label)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_addr();
  inline void clear_has_addr();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int64 addr_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static label* default_instance_;
};
// -------------------------------------------------------------------

class var : public ::google::protobuf::Message {
 public:
  var();
  virtual ~var();
  
  var(const var& from);
  
  inline var& operator=(const var& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const var& default_instance();
  
  void Swap(var* other);
  
  // implements Message ----------------------------------------------
  
  var* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const var& from);
  void MergeFrom(const var& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required sint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required .typ typ = 3;
  inline bool has_typ() const;
  inline void clear_typ();
  static const int kTypFieldNumber = 3;
  inline const ::typ& typ() const;
  inline ::typ* mutable_typ();
  inline ::typ* release_typ();
  
  // @@protoc_insertion_point(class_scope:var)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_typ();
  inline void clear_has_typ();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::typ* typ_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static var* default_instance_;
};
// -------------------------------------------------------------------

class attribute : public ::google::protobuf::Message {
 public:
  attribute();
  virtual ~attribute();
  
  attribute(const attribute& from);
  
  inline attribute& operator=(const attribute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const attribute& default_instance();
  
  void Swap(attribute* other);
  
  // implements Message ----------------------------------------------
  
  attribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const attribute& from);
  void MergeFrom(const attribute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string asm = 1;
  inline bool has_asm_() const;
  inline void clear_asm_();
  static const int kAsmFieldNumber = 1;
  inline const ::std::string& asm_() const;
  inline void set_asm_(const ::std::string& value);
  inline void set_asm_(const char* value);
  inline void set_asm_(const char* value, size_t size);
  inline ::std::string* mutable_asm_();
  inline ::std::string* release_asm_();
  
  // optional sint64 address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline ::google::protobuf::int64 address() const;
  inline void set_address(::google::protobuf::int64 value);
  
  // optional .liveout liveout = 3;
  inline bool has_liveout() const;
  inline void clear_liveout();
  static const int kLiveoutFieldNumber = 3;
  inline const ::liveout& liveout() const;
  inline ::liveout* mutable_liveout();
  inline ::liveout* release_liveout();
  
  // optional string strattr = 4;
  inline bool has_strattr() const;
  inline void clear_strattr();
  static const int kStrattrFieldNumber = 4;
  inline const ::std::string& strattr() const;
  inline void set_strattr(const ::std::string& value);
  inline void set_strattr(const char* value);
  inline void set_strattr(const char* value, size_t size);
  inline ::std::string* mutable_strattr();
  inline ::std::string* release_strattr();
  
  // optional .context context = 5;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 5;
  inline const ::context& context() const;
  inline ::context* mutable_context();
  inline ::context* release_context();
  
  // optional uint64 thread_id = 6;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 6;
  inline ::google::protobuf::uint64 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint64 value);
  
  // optional .synthetic synthetic = 7;
  inline bool has_synthetic() const;
  inline void clear_synthetic();
  static const int kSyntheticFieldNumber = 7;
  inline const ::synthetic& synthetic() const;
  inline ::synthetic* mutable_synthetic();
  inline ::synthetic* release_synthetic();
  
  // optional string other = 8;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 8;
  inline const ::std::string& other() const;
  inline void set_other(const ::std::string& value);
  inline void set_other(const char* value);
  inline void set_other(const char* value, size_t size);
  inline ::std::string* mutable_other();
  inline ::std::string* release_other();
  
  // @@protoc_insertion_point(class_scope:attribute)
 private:
  inline void set_has_asm_();
  inline void clear_has_asm_();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_liveout();
  inline void clear_has_liveout();
  inline void set_has_strattr();
  inline void clear_has_strattr();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_synthetic();
  inline void clear_has_synthetic();
  inline void set_has_other();
  inline void clear_has_other();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* asm__;
  ::google::protobuf::int64 address_;
  ::liveout* liveout_;
  ::std::string* strattr_;
  ::context* context_;
  ::google::protobuf::uint64 thread_id_;
  ::synthetic* synthetic_;
  ::std::string* other_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static attribute* default_instance_;
};
// -------------------------------------------------------------------

class attributes : public ::google::protobuf::Message {
 public:
  attributes();
  virtual ~attributes();
  
  attributes(const attributes& from);
  
  inline attributes& operator=(const attributes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const attributes& default_instance();
  
  void Swap(attributes* other);
  
  // implements Message ----------------------------------------------
  
  attributes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const attributes& from);
  void MergeFrom(const attributes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .attribute elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::attribute& elem(int index) const;
  inline ::attribute* mutable_elem(int index);
  inline ::attribute* add_elem();
  inline const ::google::protobuf::RepeatedPtrField< ::attribute >&
      elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::attribute >*
      mutable_elem();
  
  // @@protoc_insertion_point(class_scope:attributes)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::attribute > elem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static attributes* default_instance_;
};
// -------------------------------------------------------------------

class liveout : public ::google::protobuf::Message {
 public:
  liveout();
  virtual ~liveout();
  
  liveout(const liveout& from);
  
  inline liveout& operator=(const liveout& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const liveout& default_instance();
  
  void Swap(liveout* other);
  
  // implements Message ----------------------------------------------
  
  liveout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const liveout& from);
  void MergeFrom(const liveout& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:liveout)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static liveout* default_instance_;
};
// -------------------------------------------------------------------

class synthetic : public ::google::protobuf::Message {
 public:
  synthetic();
  virtual ~synthetic();
  
  synthetic(const synthetic& from);
  
  inline synthetic& operator=(const synthetic& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const synthetic& default_instance();
  
  void Swap(synthetic* other);
  
  // implements Message ----------------------------------------------
  
  synthetic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const synthetic& from);
  void MergeFrom(const synthetic& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:synthetic)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static synthetic* default_instance_;
};
// -------------------------------------------------------------------

class operand_info_specific : public ::google::protobuf::Message {
 public:
  operand_info_specific();
  virtual ~operand_info_specific();
  
  operand_info_specific(const operand_info_specific& from);
  
  inline operand_info_specific& operator=(const operand_info_specific& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const operand_info_specific& default_instance();
  
  void Swap(operand_info_specific* other);
  
  // implements Message ----------------------------------------------
  
  operand_info_specific* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operand_info_specific& from);
  void MergeFrom(const operand_info_specific& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .mem_operand mem_operand = 1;
  inline bool has_mem_operand() const;
  inline void clear_mem_operand();
  static const int kMemOperandFieldNumber = 1;
  inline const ::mem_operand& mem_operand() const;
  inline ::mem_operand* mutable_mem_operand();
  inline ::mem_operand* release_mem_operand();
  
  // optional .reg_operand reg_operand = 2;
  inline bool has_reg_operand() const;
  inline void clear_reg_operand();
  static const int kRegOperandFieldNumber = 2;
  inline const ::reg_operand& reg_operand() const;
  inline ::reg_operand* mutable_reg_operand();
  inline ::reg_operand* release_reg_operand();
  
  // @@protoc_insertion_point(class_scope:operand_info_specific)
 private:
  inline void set_has_mem_operand();
  inline void clear_has_mem_operand();
  inline void set_has_reg_operand();
  inline void clear_has_reg_operand();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mem_operand* mem_operand_;
  ::reg_operand* reg_operand_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static operand_info_specific* default_instance_;
};
// -------------------------------------------------------------------

class reg_operand : public ::google::protobuf::Message {
 public:
  reg_operand();
  virtual ~reg_operand();
  
  reg_operand(const reg_operand& from);
  
  inline reg_operand& operator=(const reg_operand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const reg_operand& default_instance();
  
  void Swap(reg_operand* other);
  
  // implements Message ----------------------------------------------
  
  reg_operand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reg_operand& from);
  void MergeFrom(const reg_operand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:reg_operand)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static reg_operand* default_instance_;
};
// -------------------------------------------------------------------

class operand_usage : public ::google::protobuf::Message {
 public:
  operand_usage();
  virtual ~operand_usage();
  
  operand_usage(const operand_usage& from);
  
  inline operand_usage& operator=(const operand_usage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const operand_usage& default_instance();
  
  void Swap(operand_usage* other);
  
  // implements Message ----------------------------------------------
  
  operand_usage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operand_usage& from);
  void MergeFrom(const operand_usage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool read = 1;
  inline bool has_read() const;
  inline void clear_read();
  static const int kReadFieldNumber = 1;
  inline bool read() const;
  inline void set_read(bool value);
  
  // required bool written = 2;
  inline bool has_written() const;
  inline void clear_written();
  static const int kWrittenFieldNumber = 2;
  inline bool written() const;
  inline void set_written(bool value);
  
  // required bool index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline bool index() const;
  inline void set_index(bool value);
  
  // required bool base = 4;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 4;
  inline bool base() const;
  inline void set_base(bool value);
  
  // @@protoc_insertion_point(class_scope:operand_usage)
 private:
  inline void set_has_read();
  inline void clear_has_read();
  inline void set_has_written();
  inline void clear_has_written();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_base();
  inline void clear_has_base();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool read_;
  bool written_;
  bool index_;
  bool base_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static operand_usage* default_instance_;
};
// -------------------------------------------------------------------

class mem_operand : public ::google::protobuf::Message {
 public:
  mem_operand();
  virtual ~mem_operand();
  
  mem_operand(const mem_operand& from);
  
  inline mem_operand& operator=(const mem_operand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mem_operand& default_instance();
  
  void Swap(mem_operand* other);
  
  // implements Message ----------------------------------------------
  
  mem_operand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mem_operand& from);
  void MergeFrom(const mem_operand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline ::google::protobuf::int64 address() const;
  inline void set_address(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:mem_operand)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 address_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static mem_operand* default_instance_;
};
// -------------------------------------------------------------------

class taint_info : public ::google::protobuf::Message {
 public:
  taint_info();
  virtual ~taint_info();
  
  taint_info(const taint_info& from);
  
  inline taint_info& operator=(const taint_info& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const taint_info& default_instance();
  
  void Swap(taint_info* other);
  
  // implements Message ----------------------------------------------
  
  taint_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const taint_info& from);
  void MergeFrom(const taint_info& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool no_taint = 1;
  inline bool has_no_taint() const;
  inline void clear_no_taint();
  static const int kNoTaintFieldNumber = 1;
  inline bool no_taint() const;
  inline void set_no_taint(bool value);
  
  // optional uint64 taint_id = 2;
  inline bool has_taint_id() const;
  inline void clear_taint_id();
  static const int kTaintIdFieldNumber = 2;
  inline ::google::protobuf::uint64 taint_id() const;
  inline void set_taint_id(::google::protobuf::uint64 value);
  
  // optional bool taint_multiple = 3;
  inline bool has_taint_multiple() const;
  inline void clear_taint_multiple();
  static const int kTaintMultipleFieldNumber = 3;
  inline bool taint_multiple() const;
  inline void set_taint_multiple(bool value);
  
  // @@protoc_insertion_point(class_scope:taint_info)
 private:
  inline void set_has_no_taint();
  inline void clear_has_no_taint();
  inline void set_has_taint_id();
  inline void clear_has_taint_id();
  inline void set_has_taint_multiple();
  inline void clear_has_taint_multiple();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 taint_id_;
  bool no_taint_;
  bool taint_multiple_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static taint_info* default_instance_;
};
// -------------------------------------------------------------------

class context : public ::google::protobuf::Message {
 public:
  context();
  virtual ~context();
  
  context(const context& from);
  
  inline context& operator=(const context& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const context& default_instance();
  
  void Swap(context* other);
  
  // implements Message ----------------------------------------------
  
  context* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const context& from);
  void MergeFrom(const context& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .operand_info_specific operand_info_specific = 1;
  inline bool has_operand_info_specific() const;
  inline void clear_operand_info_specific();
  static const int kOperandInfoSpecificFieldNumber = 1;
  inline const ::operand_info_specific& operand_info_specific() const;
  inline ::operand_info_specific* mutable_operand_info_specific();
  inline ::operand_info_specific* release_operand_info_specific();
  
  // required sint32 bit_length = 2;
  inline bool has_bit_length() const;
  inline void clear_bit_length();
  static const int kBitLengthFieldNumber = 2;
  inline ::google::protobuf::int32 bit_length() const;
  inline void set_bit_length(::google::protobuf::int32 value);
  
  // required .operand_usage operand_usage = 3;
  inline bool has_operand_usage() const;
  inline void clear_operand_usage();
  static const int kOperandUsageFieldNumber = 3;
  inline const ::operand_usage& operand_usage() const;
  inline ::operand_usage* mutable_operand_usage();
  inline ::operand_usage* release_operand_usage();
  
  // required .taint_info taint_info = 4;
  inline bool has_taint_info() const;
  inline void clear_taint_info();
  static const int kTaintInfoFieldNumber = 4;
  inline const ::taint_info& taint_info() const;
  inline ::taint_info* mutable_taint_info();
  inline ::taint_info* release_taint_info();
  
  // required string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:context)
 private:
  inline void set_has_operand_info_specific();
  inline void clear_has_operand_info_specific();
  inline void set_has_bit_length();
  inline void clear_has_bit_length();
  inline void set_has_operand_usage();
  inline void clear_has_operand_usage();
  inline void set_has_taint_info();
  inline void clear_has_taint_info();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::operand_info_specific* operand_info_specific_;
  ::operand_usage* operand_usage_;
  ::taint_info* taint_info_;
  ::std::string* value_;
  ::google::protobuf::int32 bit_length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static context* default_instance_;
};
// -------------------------------------------------------------------

class exp : public ::google::protobuf::Message {
 public:
  exp();
  virtual ~exp();
  
  exp(const exp& from);
  
  inline exp& operator=(const exp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const exp& default_instance();
  
  void Swap(exp* other);
  
  // implements Message ----------------------------------------------
  
  exp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exp& from);
  void MergeFrom(const exp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .load load = 1;
  inline bool has_load() const;
  inline void clear_load();
  static const int kLoadFieldNumber = 1;
  inline const ::load& load() const;
  inline ::load* mutable_load();
  inline ::load* release_load();
  
  // optional .store store = 2;
  inline bool has_store() const;
  inline void clear_store();
  static const int kStoreFieldNumber = 2;
  inline const ::store& store() const;
  inline ::store* mutable_store();
  inline ::store* release_store();
  
  // optional .binop binop = 3;
  inline bool has_binop() const;
  inline void clear_binop();
  static const int kBinopFieldNumber = 3;
  inline const ::binop& binop() const;
  inline ::binop* mutable_binop();
  inline ::binop* release_binop();
  
  // optional .unop unop = 4;
  inline bool has_unop() const;
  inline void clear_unop();
  static const int kUnopFieldNumber = 4;
  inline const ::unop& unop() const;
  inline ::unop* mutable_unop();
  inline ::unop* release_unop();
  
  // optional .var var = 5;
  inline bool has_var() const;
  inline void clear_var();
  static const int kVarFieldNumber = 5;
  inline const ::var& var() const;
  inline ::var* mutable_var();
  inline ::var* release_var();
  
  // optional string lab = 6;
  inline bool has_lab() const;
  inline void clear_lab();
  static const int kLabFieldNumber = 6;
  inline const ::std::string& lab() const;
  inline void set_lab(const ::std::string& value);
  inline void set_lab(const char* value);
  inline void set_lab(const char* value, size_t size);
  inline ::std::string* mutable_lab();
  inline ::std::string* release_lab();
  
  // optional .inte inte = 7;
  inline bool has_inte() const;
  inline void clear_inte();
  static const int kInteFieldNumber = 7;
  inline const ::inte& inte() const;
  inline ::inte* mutable_inte();
  inline ::inte* release_inte();
  
  // optional .cast cast = 8;
  inline bool has_cast() const;
  inline void clear_cast();
  static const int kCastFieldNumber = 8;
  inline const ::cast& cast() const;
  inline ::cast* mutable_cast();
  inline ::cast* release_cast();
  
  // optional .let_exp let_exp = 9;
  inline bool has_let_exp() const;
  inline void clear_let_exp();
  static const int kLetExpFieldNumber = 9;
  inline const ::let_exp& let_exp() const;
  inline ::let_exp* mutable_let_exp();
  inline ::let_exp* release_let_exp();
  
  // optional .unknown unknown = 10;
  inline bool has_unknown() const;
  inline void clear_unknown();
  static const int kUnknownFieldNumber = 10;
  inline const ::unknown& unknown() const;
  inline ::unknown* mutable_unknown();
  inline ::unknown* release_unknown();
  
  // optional .ite ite = 11;
  inline bool has_ite() const;
  inline void clear_ite();
  static const int kIteFieldNumber = 11;
  inline const ::ite& ite() const;
  inline ::ite* mutable_ite();
  inline ::ite* release_ite();
  
  // optional .extract extract = 12;
  inline bool has_extract() const;
  inline void clear_extract();
  static const int kExtractFieldNumber = 12;
  inline const ::extract& extract() const;
  inline ::extract* mutable_extract();
  inline ::extract* release_extract();
  
  // optional .concat concat = 13;
  inline bool has_concat() const;
  inline void clear_concat();
  static const int kConcatFieldNumber = 13;
  inline const ::concat& concat() const;
  inline ::concat* mutable_concat();
  inline ::concat* release_concat();
  
  // @@protoc_insertion_point(class_scope:exp)
 private:
  inline void set_has_load();
  inline void clear_has_load();
  inline void set_has_store();
  inline void clear_has_store();
  inline void set_has_binop();
  inline void clear_has_binop();
  inline void set_has_unop();
  inline void clear_has_unop();
  inline void set_has_var();
  inline void clear_has_var();
  inline void set_has_lab();
  inline void clear_has_lab();
  inline void set_has_inte();
  inline void clear_has_inte();
  inline void set_has_cast();
  inline void clear_has_cast();
  inline void set_has_let_exp();
  inline void clear_has_let_exp();
  inline void set_has_unknown();
  inline void clear_has_unknown();
  inline void set_has_ite();
  inline void clear_has_ite();
  inline void set_has_extract();
  inline void clear_has_extract();
  inline void set_has_concat();
  inline void clear_has_concat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::load* load_;
  ::store* store_;
  ::binop* binop_;
  ::unop* unop_;
  ::var* var_;
  ::std::string* lab_;
  ::inte* inte_;
  ::cast* cast_;
  ::let_exp* let_exp_;
  ::unknown* unknown_;
  ::ite* ite_;
  ::extract* extract_;
  ::concat* concat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static exp* default_instance_;
};
// -------------------------------------------------------------------

class load : public ::google::protobuf::Message {
 public:
  load();
  virtual ~load();
  
  load(const load& from);
  
  inline load& operator=(const load& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const load& default_instance();
  
  void Swap(load* other);
  
  // implements Message ----------------------------------------------
  
  load* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const load& from);
  void MergeFrom(const load& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .exp memory = 1;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 1;
  inline const ::exp& memory() const;
  inline ::exp* mutable_memory();
  inline ::exp* release_memory();
  
  // required .exp address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::exp& address() const;
  inline ::exp* mutable_address();
  inline ::exp* release_address();
  
  // required .exp endian = 3;
  inline bool has_endian() const;
  inline void clear_endian();
  static const int kEndianFieldNumber = 3;
  inline const ::exp& endian() const;
  inline ::exp* mutable_endian();
  inline ::exp* release_endian();
  
  // required .typ typ = 4;
  inline bool has_typ() const;
  inline void clear_typ();
  static const int kTypFieldNumber = 4;
  inline const ::typ& typ() const;
  inline ::typ* mutable_typ();
  inline ::typ* release_typ();
  
  // @@protoc_insertion_point(class_scope:load)
 private:
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_endian();
  inline void clear_has_endian();
  inline void set_has_typ();
  inline void clear_has_typ();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* memory_;
  ::exp* address_;
  ::exp* endian_;
  ::typ* typ_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static load* default_instance_;
};
// -------------------------------------------------------------------

class store : public ::google::protobuf::Message {
 public:
  store();
  virtual ~store();
  
  store(const store& from);
  
  inline store& operator=(const store& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const store& default_instance();
  
  void Swap(store* other);
  
  // implements Message ----------------------------------------------
  
  store* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const store& from);
  void MergeFrom(const store& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .exp memory = 1;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 1;
  inline const ::exp& memory() const;
  inline ::exp* mutable_memory();
  inline ::exp* release_memory();
  
  // required .exp address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::exp& address() const;
  inline ::exp* mutable_address();
  inline ::exp* release_address();
  
  // required .exp value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::exp& value() const;
  inline ::exp* mutable_value();
  inline ::exp* release_value();
  
  // required .exp endian = 4;
  inline bool has_endian() const;
  inline void clear_endian();
  static const int kEndianFieldNumber = 4;
  inline const ::exp& endian() const;
  inline ::exp* mutable_endian();
  inline ::exp* release_endian();
  
  // required .typ typ = 5;
  inline bool has_typ() const;
  inline void clear_typ();
  static const int kTypFieldNumber = 5;
  inline const ::typ& typ() const;
  inline ::typ* mutable_typ();
  inline ::typ* release_typ();
  
  // @@protoc_insertion_point(class_scope:store)
 private:
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_endian();
  inline void clear_has_endian();
  inline void set_has_typ();
  inline void clear_has_typ();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* memory_;
  ::exp* address_;
  ::exp* value_;
  ::exp* endian_;
  ::typ* typ_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static store* default_instance_;
};
// -------------------------------------------------------------------

class binop : public ::google::protobuf::Message {
 public:
  binop();
  virtual ~binop();
  
  binop(const binop& from);
  
  inline binop& operator=(const binop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const binop& default_instance();
  
  void Swap(binop* other);
  
  // implements Message ----------------------------------------------
  
  binop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const binop& from);
  void MergeFrom(const binop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .binop_type binop_type = 1;
  inline bool has_binop_type() const;
  inline void clear_binop_type();
  static const int kBinopTypeFieldNumber = 1;
  inline binop_type binop_type() const;
  inline void set_binop_type(binop_type value);
  
  // required .exp lexp = 2;
  inline bool has_lexp() const;
  inline void clear_lexp();
  static const int kLexpFieldNumber = 2;
  inline const ::exp& lexp() const;
  inline ::exp* mutable_lexp();
  inline ::exp* release_lexp();
  
  // required .exp rexp = 3;
  inline bool has_rexp() const;
  inline void clear_rexp();
  static const int kRexpFieldNumber = 3;
  inline const ::exp& rexp() const;
  inline ::exp* mutable_rexp();
  inline ::exp* release_rexp();
  
  // @@protoc_insertion_point(class_scope:binop)
 private:
  inline void set_has_binop_type();
  inline void clear_has_binop_type();
  inline void set_has_lexp();
  inline void clear_has_lexp();
  inline void set_has_rexp();
  inline void clear_has_rexp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* lexp_;
  ::exp* rexp_;
  int binop_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static binop* default_instance_;
};
// -------------------------------------------------------------------

class unop : public ::google::protobuf::Message {
 public:
  unop();
  virtual ~unop();
  
  unop(const unop& from);
  
  inline unop& operator=(const unop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const unop& default_instance();
  
  void Swap(unop* other);
  
  // implements Message ----------------------------------------------
  
  unop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unop& from);
  void MergeFrom(const unop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .unop_type unop_type = 1;
  inline bool has_unop_type() const;
  inline void clear_unop_type();
  static const int kUnopTypeFieldNumber = 1;
  inline unop_type unop_type() const;
  inline void set_unop_type(unop_type value);
  
  // required .exp exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline const ::exp& exp() const;
  inline ::exp* mutable_exp();
  inline ::exp* release_exp();
  
  // @@protoc_insertion_point(class_scope:unop)
 private:
  inline void set_has_unop_type();
  inline void clear_has_unop_type();
  inline void set_has_exp();
  inline void clear_has_exp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* exp_;
  int unop_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static unop* default_instance_;
};
// -------------------------------------------------------------------

class inte : public ::google::protobuf::Message {
 public:
  inte();
  virtual ~inte();
  
  inte(const inte& from);
  
  inline inte& operator=(const inte& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const inte& default_instance();
  
  void Swap(inte* other);
  
  // implements Message ----------------------------------------------
  
  inte* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const inte& from);
  void MergeFrom(const inte& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string int = 1;
  inline bool has_int_() const;
  inline void clear_int_();
  static const int kIntFieldNumber = 1;
  inline const ::std::string& int_() const;
  inline void set_int_(const ::std::string& value);
  inline void set_int_(const char* value);
  inline void set_int_(const char* value, size_t size);
  inline ::std::string* mutable_int_();
  inline ::std::string* release_int_();
  
  // required .typ typ = 2;
  inline bool has_typ() const;
  inline void clear_typ();
  static const int kTypFieldNumber = 2;
  inline const ::typ& typ() const;
  inline ::typ* mutable_typ();
  inline ::typ* release_typ();
  
  // @@protoc_insertion_point(class_scope:inte)
 private:
  inline void set_has_int_();
  inline void clear_has_int_();
  inline void set_has_typ();
  inline void clear_has_typ();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* int__;
  ::typ* typ_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static inte* default_instance_;
};
// -------------------------------------------------------------------

class cast : public ::google::protobuf::Message {
 public:
  cast();
  virtual ~cast();
  
  cast(const cast& from);
  
  inline cast& operator=(const cast& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const cast& default_instance();
  
  void Swap(cast* other);
  
  // implements Message ----------------------------------------------
  
  cast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cast& from);
  void MergeFrom(const cast& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .cast_type cast_type = 1;
  inline bool has_cast_type() const;
  inline void clear_cast_type();
  static const int kCastTypeFieldNumber = 1;
  inline cast_type cast_type() const;
  inline void set_cast_type(cast_type value);
  
  // required .typ new_type = 2;
  inline bool has_new_type() const;
  inline void clear_new_type();
  static const int kNewTypeFieldNumber = 2;
  inline const ::typ& new_type() const;
  inline ::typ* mutable_new_type();
  inline ::typ* release_new_type();
  
  // required .exp exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline const ::exp& exp() const;
  inline ::exp* mutable_exp();
  inline ::exp* release_exp();
  
  // @@protoc_insertion_point(class_scope:cast)
 private:
  inline void set_has_cast_type();
  inline void clear_has_cast_type();
  inline void set_has_new_type();
  inline void clear_has_new_type();
  inline void set_has_exp();
  inline void clear_has_exp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::typ* new_type_;
  ::exp* exp_;
  int cast_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static cast* default_instance_;
};
// -------------------------------------------------------------------

class let_exp : public ::google::protobuf::Message {
 public:
  let_exp();
  virtual ~let_exp();
  
  let_exp(const let_exp& from);
  
  inline let_exp& operator=(const let_exp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const let_exp& default_instance();
  
  void Swap(let_exp* other);
  
  // implements Message ----------------------------------------------
  
  let_exp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const let_exp& from);
  void MergeFrom(const let_exp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .var var = 1;
  inline bool has_var() const;
  inline void clear_var();
  static const int kVarFieldNumber = 1;
  inline const ::var& var() const;
  inline ::var* mutable_var();
  inline ::var* release_var();
  
  // required .exp e1 = 2;
  inline bool has_e1() const;
  inline void clear_e1();
  static const int kE1FieldNumber = 2;
  inline const ::exp& e1() const;
  inline ::exp* mutable_e1();
  inline ::exp* release_e1();
  
  // required .exp e2 = 3;
  inline bool has_e2() const;
  inline void clear_e2();
  static const int kE2FieldNumber = 3;
  inline const ::exp& e2() const;
  inline ::exp* mutable_e2();
  inline ::exp* release_e2();
  
  // @@protoc_insertion_point(class_scope:let_exp)
 private:
  inline void set_has_var();
  inline void clear_has_var();
  inline void set_has_e1();
  inline void clear_has_e1();
  inline void set_has_e2();
  inline void clear_has_e2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::var* var_;
  ::exp* e1_;
  ::exp* e2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static let_exp* default_instance_;
};
// -------------------------------------------------------------------

class unknown : public ::google::protobuf::Message {
 public:
  unknown();
  virtual ~unknown();
  
  unknown(const unknown& from);
  
  inline unknown& operator=(const unknown& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const unknown& default_instance();
  
  void Swap(unknown* other);
  
  // implements Message ----------------------------------------------
  
  unknown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unknown& from);
  void MergeFrom(const unknown& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string string = 1;
  inline bool has_string() const;
  inline void clear_string();
  static const int kStringFieldNumber = 1;
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline void set_string(const char* value, size_t size);
  inline ::std::string* mutable_string();
  inline ::std::string* release_string();
  
  // required .typ typ = 2;
  inline bool has_typ() const;
  inline void clear_typ();
  static const int kTypFieldNumber = 2;
  inline const ::typ& typ() const;
  inline ::typ* mutable_typ();
  inline ::typ* release_typ();
  
  // @@protoc_insertion_point(class_scope:unknown)
 private:
  inline void set_has_string();
  inline void clear_has_string();
  inline void set_has_typ();
  inline void clear_has_typ();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* string_;
  ::typ* typ_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static unknown* default_instance_;
};
// -------------------------------------------------------------------

class ite : public ::google::protobuf::Message {
 public:
  ite();
  virtual ~ite();
  
  ite(const ite& from);
  
  inline ite& operator=(const ite& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ite& default_instance();
  
  void Swap(ite* other);
  
  // implements Message ----------------------------------------------
  
  ite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ite& from);
  void MergeFrom(const ite& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .exp condition = 1;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 1;
  inline const ::exp& condition() const;
  inline ::exp* mutable_condition();
  inline ::exp* release_condition();
  
  // required .exp iftrue = 2;
  inline bool has_iftrue() const;
  inline void clear_iftrue();
  static const int kIftrueFieldNumber = 2;
  inline const ::exp& iftrue() const;
  inline ::exp* mutable_iftrue();
  inline ::exp* release_iftrue();
  
  // required .exp iffalse = 3;
  inline bool has_iffalse() const;
  inline void clear_iffalse();
  static const int kIffalseFieldNumber = 3;
  inline const ::exp& iffalse() const;
  inline ::exp* mutable_iffalse();
  inline ::exp* release_iffalse();
  
  // @@protoc_insertion_point(class_scope:ite)
 private:
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_iftrue();
  inline void clear_has_iftrue();
  inline void set_has_iffalse();
  inline void clear_has_iffalse();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* condition_;
  ::exp* iftrue_;
  ::exp* iffalse_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static ite* default_instance_;
};
// -------------------------------------------------------------------

class extract : public ::google::protobuf::Message {
 public:
  extract();
  virtual ~extract();
  
  extract(const extract& from);
  
  inline extract& operator=(const extract& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const extract& default_instance();
  
  void Swap(extract* other);
  
  // implements Message ----------------------------------------------
  
  extract* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const extract& from);
  void MergeFrom(const extract& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 hbit = 1;
  inline bool has_hbit() const;
  inline void clear_hbit();
  static const int kHbitFieldNumber = 1;
  inline ::google::protobuf::int32 hbit() const;
  inline void set_hbit(::google::protobuf::int32 value);
  
  // required sint32 lbit = 2;
  inline bool has_lbit() const;
  inline void clear_lbit();
  static const int kLbitFieldNumber = 2;
  inline ::google::protobuf::int32 lbit() const;
  inline void set_lbit(::google::protobuf::int32 value);
  
  // required .exp exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline const ::exp& exp() const;
  inline ::exp* mutable_exp();
  inline ::exp* release_exp();
  
  // @@protoc_insertion_point(class_scope:extract)
 private:
  inline void set_has_hbit();
  inline void clear_has_hbit();
  inline void set_has_lbit();
  inline void clear_has_lbit();
  inline void set_has_exp();
  inline void clear_has_exp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 hbit_;
  ::google::protobuf::int32 lbit_;
  ::exp* exp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static extract* default_instance_;
};
// -------------------------------------------------------------------

class concat : public ::google::protobuf::Message {
 public:
  concat();
  virtual ~concat();
  
  concat(const concat& from);
  
  inline concat& operator=(const concat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const concat& default_instance();
  
  void Swap(concat* other);
  
  // implements Message ----------------------------------------------
  
  concat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const concat& from);
  void MergeFrom(const concat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .exp le = 1;
  inline bool has_le() const;
  inline void clear_le();
  static const int kLeFieldNumber = 1;
  inline const ::exp& le() const;
  inline ::exp* mutable_le();
  inline ::exp* release_le();
  
  // required .exp re = 2;
  inline bool has_re() const;
  inline void clear_re();
  static const int kReFieldNumber = 2;
  inline const ::exp& re() const;
  inline ::exp* mutable_re();
  inline ::exp* release_re();
  
  // @@protoc_insertion_point(class_scope:concat)
 private:
  inline void set_has_le();
  inline void clear_has_le();
  inline void set_has_re();
  inline void clear_has_re();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::exp* le_;
  ::exp* re_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_stmt_2epiqi_2eproto();
  friend void protobuf_AssignDesc_stmt_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_stmt_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static concat* default_instance_;
};
// ===================================================================


// ===================================================================

// program

// repeated .stmt elem = 1;
inline int program::elem_size() const {
  return elem_.size();
}
inline void program::clear_elem() {
  elem_.Clear();
}
inline const ::stmt& program::elem(int index) const {
  return elem_.Get(index);
}
inline ::stmt* program::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::stmt* program::add_elem() {
  return elem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::stmt >&
program::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::stmt >*
program::mutable_elem() {
  return &elem_;
}

// -------------------------------------------------------------------

// stmt

// optional .move move = 1;
inline bool stmt::has_move() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stmt::set_has_move() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stmt::clear_has_move() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stmt::clear_move() {
  if (move_ != NULL) move_->::move::Clear();
  clear_has_move();
}
inline const ::move& stmt::move() const {
  return move_ != NULL ? *move_ : *default_instance_->move_;
}
inline ::move* stmt::mutable_move() {
  set_has_move();
  if (move_ == NULL) move_ = new ::move;
  return move_;
}
inline ::move* stmt::release_move() {
  clear_has_move();
  ::move* temp = move_;
  move_ = NULL;
  return temp;
}

// optional .jmp jmp = 2;
inline bool stmt::has_jmp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stmt::set_has_jmp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stmt::clear_has_jmp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stmt::clear_jmp() {
  if (jmp_ != NULL) jmp_->::jmp::Clear();
  clear_has_jmp();
}
inline const ::jmp& stmt::jmp() const {
  return jmp_ != NULL ? *jmp_ : *default_instance_->jmp_;
}
inline ::jmp* stmt::mutable_jmp() {
  set_has_jmp();
  if (jmp_ == NULL) jmp_ = new ::jmp;
  return jmp_;
}
inline ::jmp* stmt::release_jmp() {
  clear_has_jmp();
  ::jmp* temp = jmp_;
  jmp_ = NULL;
  return temp;
}

// optional .cjmp cjmp = 3;
inline bool stmt::has_cjmp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stmt::set_has_cjmp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stmt::clear_has_cjmp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stmt::clear_cjmp() {
  if (cjmp_ != NULL) cjmp_->::cjmp::Clear();
  clear_has_cjmp();
}
inline const ::cjmp& stmt::cjmp() const {
  return cjmp_ != NULL ? *cjmp_ : *default_instance_->cjmp_;
}
inline ::cjmp* stmt::mutable_cjmp() {
  set_has_cjmp();
  if (cjmp_ == NULL) cjmp_ = new ::cjmp;
  return cjmp_;
}
inline ::cjmp* stmt::release_cjmp() {
  clear_has_cjmp();
  ::cjmp* temp = cjmp_;
  cjmp_ = NULL;
  return temp;
}

// optional .label_stmt label_stmt = 4;
inline bool stmt::has_label_stmt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void stmt::set_has_label_stmt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void stmt::clear_has_label_stmt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void stmt::clear_label_stmt() {
  if (label_stmt_ != NULL) label_stmt_->::label_stmt::Clear();
  clear_has_label_stmt();
}
inline const ::label_stmt& stmt::label_stmt() const {
  return label_stmt_ != NULL ? *label_stmt_ : *default_instance_->label_stmt_;
}
inline ::label_stmt* stmt::mutable_label_stmt() {
  set_has_label_stmt();
  if (label_stmt_ == NULL) label_stmt_ = new ::label_stmt;
  return label_stmt_;
}
inline ::label_stmt* stmt::release_label_stmt() {
  clear_has_label_stmt();
  ::label_stmt* temp = label_stmt_;
  label_stmt_ = NULL;
  return temp;
}

// optional .halt halt = 5;
inline bool stmt::has_halt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void stmt::set_has_halt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void stmt::clear_has_halt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void stmt::clear_halt() {
  if (halt_ != NULL) halt_->::halt::Clear();
  clear_has_halt();
}
inline const ::halt& stmt::halt() const {
  return halt_ != NULL ? *halt_ : *default_instance_->halt_;
}
inline ::halt* stmt::mutable_halt() {
  set_has_halt();
  if (halt_ == NULL) halt_ = new ::halt;
  return halt_;
}
inline ::halt* stmt::release_halt() {
  clear_has_halt();
  ::halt* temp = halt_;
  halt_ = NULL;
  return temp;
}

// optional .assert_stmt assert_stmt = 6;
inline bool stmt::has_assert_stmt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void stmt::set_has_assert_stmt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void stmt::clear_has_assert_stmt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void stmt::clear_assert_stmt() {
  if (assert_stmt_ != NULL) assert_stmt_->::assert_stmt::Clear();
  clear_has_assert_stmt();
}
inline const ::assert_stmt& stmt::assert_stmt() const {
  return assert_stmt_ != NULL ? *assert_stmt_ : *default_instance_->assert_stmt_;
}
inline ::assert_stmt* stmt::mutable_assert_stmt() {
  set_has_assert_stmt();
  if (assert_stmt_ == NULL) assert_stmt_ = new ::assert_stmt;
  return assert_stmt_;
}
inline ::assert_stmt* stmt::release_assert_stmt() {
  clear_has_assert_stmt();
  ::assert_stmt* temp = assert_stmt_;
  assert_stmt_ = NULL;
  return temp;
}

// optional .assume assume = 7;
inline bool stmt::has_assume() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void stmt::set_has_assume() {
  _has_bits_[0] |= 0x00000040u;
}
inline void stmt::clear_has_assume() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void stmt::clear_assume() {
  if (assume_ != NULL) assume_->::assume::Clear();
  clear_has_assume();
}
inline const ::assume& stmt::assume() const {
  return assume_ != NULL ? *assume_ : *default_instance_->assume_;
}
inline ::assume* stmt::mutable_assume() {
  set_has_assume();
  if (assume_ == NULL) assume_ = new ::assume;
  return assume_;
}
inline ::assume* stmt::release_assume() {
  clear_has_assume();
  ::assume* temp = assume_;
  assume_ = NULL;
  return temp;
}

// optional .comment comment = 8;
inline bool stmt::has_comment() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void stmt::set_has_comment() {
  _has_bits_[0] |= 0x00000080u;
}
inline void stmt::clear_has_comment() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void stmt::clear_comment() {
  if (comment_ != NULL) comment_->::comment::Clear();
  clear_has_comment();
}
inline const ::comment& stmt::comment() const {
  return comment_ != NULL ? *comment_ : *default_instance_->comment_;
}
inline ::comment* stmt::mutable_comment() {
  set_has_comment();
  if (comment_ == NULL) comment_ = new ::comment;
  return comment_;
}
inline ::comment* stmt::release_comment() {
  clear_has_comment();
  ::comment* temp = comment_;
  comment_ = NULL;
  return temp;
}

// optional .special special = 9;
inline bool stmt::has_special() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void stmt::set_has_special() {
  _has_bits_[0] |= 0x00000100u;
}
inline void stmt::clear_has_special() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void stmt::clear_special() {
  if (special_ != NULL) special_->::special::Clear();
  clear_has_special();
}
inline const ::special& stmt::special() const {
  return special_ != NULL ? *special_ : *default_instance_->special_;
}
inline ::special* stmt::mutable_special() {
  set_has_special();
  if (special_ == NULL) special_ = new ::special;
  return special_;
}
inline ::special* stmt::release_special() {
  clear_has_special();
  ::special* temp = special_;
  special_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// move

// required .var var = 1;
inline bool move::has_var() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void move::set_has_var() {
  _has_bits_[0] |= 0x00000001u;
}
inline void move::clear_has_var() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void move::clear_var() {
  if (var_ != NULL) var_->::var::Clear();
  clear_has_var();
}
inline const ::var& move::var() const {
  return var_ != NULL ? *var_ : *default_instance_->var_;
}
inline ::var* move::mutable_var() {
  set_has_var();
  if (var_ == NULL) var_ = new ::var;
  return var_;
}
inline ::var* move::release_var() {
  clear_has_var();
  ::var* temp = var_;
  var_ = NULL;
  return temp;
}

// required .exp exp = 2;
inline bool move::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void move::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void move::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void move::clear_exp() {
  if (exp_ != NULL) exp_->::exp::Clear();
  clear_has_exp();
}
inline const ::exp& move::exp() const {
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::exp* move::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::exp;
  return exp_;
}
inline ::exp* move::release_exp() {
  clear_has_exp();
  ::exp* temp = exp_;
  exp_ = NULL;
  return temp;
}

// required .attributes attributes = 3;
inline bool move::has_attributes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void move::set_has_attributes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void move::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void move::clear_attributes() {
  if (attributes_ != NULL) attributes_->::attributes::Clear();
  clear_has_attributes();
}
inline const ::attributes& move::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::attributes* move::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::attributes;
  return attributes_;
}
inline ::attributes* move::release_attributes() {
  clear_has_attributes();
  ::attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// jmp

// required .exp exp = 1;
inline bool jmp::has_exp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void jmp::set_has_exp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void jmp::clear_has_exp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void jmp::clear_exp() {
  if (exp_ != NULL) exp_->::exp::Clear();
  clear_has_exp();
}
inline const ::exp& jmp::exp() const {
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::exp* jmp::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::exp;
  return exp_;
}
inline ::exp* jmp::release_exp() {
  clear_has_exp();
  ::exp* temp = exp_;
  exp_ = NULL;
  return temp;
}

// required .attributes attributes = 2;
inline bool jmp::has_attributes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void jmp::set_has_attributes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void jmp::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void jmp::clear_attributes() {
  if (attributes_ != NULL) attributes_->::attributes::Clear();
  clear_has_attributes();
}
inline const ::attributes& jmp::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::attributes* jmp::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::attributes;
  return attributes_;
}
inline ::attributes* jmp::release_attributes() {
  clear_has_attributes();
  ::attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// cjmp

// required .exp cond = 1;
inline bool cjmp::has_cond() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cjmp::set_has_cond() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cjmp::clear_has_cond() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cjmp::clear_cond() {
  if (cond_ != NULL) cond_->::exp::Clear();
  clear_has_cond();
}
inline const ::exp& cjmp::cond() const {
  return cond_ != NULL ? *cond_ : *default_instance_->cond_;
}
inline ::exp* cjmp::mutable_cond() {
  set_has_cond();
  if (cond_ == NULL) cond_ = new ::exp;
  return cond_;
}
inline ::exp* cjmp::release_cond() {
  clear_has_cond();
  ::exp* temp = cond_;
  cond_ = NULL;
  return temp;
}

// required .exp iftrue = 2;
inline bool cjmp::has_iftrue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cjmp::set_has_iftrue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cjmp::clear_has_iftrue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cjmp::clear_iftrue() {
  if (iftrue_ != NULL) iftrue_->::exp::Clear();
  clear_has_iftrue();
}
inline const ::exp& cjmp::iftrue() const {
  return iftrue_ != NULL ? *iftrue_ : *default_instance_->iftrue_;
}
inline ::exp* cjmp::mutable_iftrue() {
  set_has_iftrue();
  if (iftrue_ == NULL) iftrue_ = new ::exp;
  return iftrue_;
}
inline ::exp* cjmp::release_iftrue() {
  clear_has_iftrue();
  ::exp* temp = iftrue_;
  iftrue_ = NULL;
  return temp;
}

// required .exp iffalse = 3;
inline bool cjmp::has_iffalse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cjmp::set_has_iffalse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cjmp::clear_has_iffalse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cjmp::clear_iffalse() {
  if (iffalse_ != NULL) iffalse_->::exp::Clear();
  clear_has_iffalse();
}
inline const ::exp& cjmp::iffalse() const {
  return iffalse_ != NULL ? *iffalse_ : *default_instance_->iffalse_;
}
inline ::exp* cjmp::mutable_iffalse() {
  set_has_iffalse();
  if (iffalse_ == NULL) iffalse_ = new ::exp;
  return iffalse_;
}
inline ::exp* cjmp::release_iffalse() {
  clear_has_iffalse();
  ::exp* temp = iffalse_;
  iffalse_ = NULL;
  return temp;
}

// required .attributes attributes = 4;
inline bool cjmp::has_attributes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cjmp::set_has_attributes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cjmp::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cjmp::clear_attributes() {
  if (attributes_ != NULL) attributes_->::attributes::Clear();
  clear_has_attributes();
}
inline const ::attributes& cjmp::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::attributes* cjmp::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::attributes;
  return attributes_;
}
inline ::attributes* cjmp::release_attributes() {
  clear_has_attributes();
  ::attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// label_stmt

// required .label label = 1;
inline bool label_stmt::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void label_stmt::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void label_stmt::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void label_stmt::clear_label() {
  if (label_ != NULL) label_->::label::Clear();
  clear_has_label();
}
inline const ::label& label_stmt::label() const {
  return label_ != NULL ? *label_ : *default_instance_->label_;
}
inline ::label* label_stmt::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::label;
  return label_;
}
inline ::label* label_stmt::release_label() {
  clear_has_label();
  ::label* temp = label_;
  label_ = NULL;
  return temp;
}

// required .attributes attributes = 2;
inline bool label_stmt::has_attributes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void label_stmt::set_has_attributes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void label_stmt::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void label_stmt::clear_attributes() {
  if (attributes_ != NULL) attributes_->::attributes::Clear();
  clear_has_attributes();
}
inline const ::attributes& label_stmt::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::attributes* label_stmt::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::attributes;
  return attributes_;
}
inline ::attributes* label_stmt::release_attributes() {
  clear_has_attributes();
  ::attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// halt

// required .exp exp = 1;
inline bool halt::has_exp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void halt::set_has_exp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void halt::clear_has_exp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void halt::clear_exp() {
  if (exp_ != NULL) exp_->::exp::Clear();
  clear_has_exp();
}
inline const ::exp& halt::exp() const {
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::exp* halt::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::exp;
  return exp_;
}
inline ::exp* halt::release_exp() {
  clear_has_exp();
  ::exp* temp = exp_;
  exp_ = NULL;
  return temp;
}

// required .attributes attributes = 2;
inline bool halt::has_attributes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void halt::set_has_attributes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void halt::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void halt::clear_attributes() {
  if (attributes_ != NULL) attributes_->::attributes::Clear();
  clear_has_attributes();
}
inline const ::attributes& halt::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::attributes* halt::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::attributes;
  return attributes_;
}
inline ::attributes* halt::release_attributes() {
  clear_has_attributes();
  ::attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// assert_stmt

// required .exp exp = 1;
inline bool assert_stmt::has_exp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void assert_stmt::set_has_exp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void assert_stmt::clear_has_exp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void assert_stmt::clear_exp() {
  if (exp_ != NULL) exp_->::exp::Clear();
  clear_has_exp();
}
inline const ::exp& assert_stmt::exp() const {
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::exp* assert_stmt::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::exp;
  return exp_;
}
inline ::exp* assert_stmt::release_exp() {
  clear_has_exp();
  ::exp* temp = exp_;
  exp_ = NULL;
  return temp;
}

// required .attributes attributes = 2;
inline bool assert_stmt::has_attributes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void assert_stmt::set_has_attributes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void assert_stmt::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void assert_stmt::clear_attributes() {
  if (attributes_ != NULL) attributes_->::attributes::Clear();
  clear_has_attributes();
}
inline const ::attributes& assert_stmt::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::attributes* assert_stmt::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::attributes;
  return attributes_;
}
inline ::attributes* assert_stmt::release_attributes() {
  clear_has_attributes();
  ::attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// assume

// required .exp exp = 1;
inline bool assume::has_exp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void assume::set_has_exp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void assume::clear_has_exp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void assume::clear_exp() {
  if (exp_ != NULL) exp_->::exp::Clear();
  clear_has_exp();
}
inline const ::exp& assume::exp() const {
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::exp* assume::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::exp;
  return exp_;
}
inline ::exp* assume::release_exp() {
  clear_has_exp();
  ::exp* temp = exp_;
  exp_ = NULL;
  return temp;
}

// required .attributes attributes = 2;
inline bool assume::has_attributes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void assume::set_has_attributes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void assume::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void assume::clear_attributes() {
  if (attributes_ != NULL) attributes_->::attributes::Clear();
  clear_has_attributes();
}
inline const ::attributes& assume::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::attributes* assume::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::attributes;
  return attributes_;
}
inline ::attributes* assume::release_attributes() {
  clear_has_attributes();
  ::attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// comment

// required string string = 1;
inline bool comment::has_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void comment::set_has_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void comment::clear_has_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void comment::clear_string() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    string_->clear();
  }
  clear_has_string();
}
inline const ::std::string& comment::string() const {
  return *string_;
}
inline void comment::set_string(const ::std::string& value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void comment::set_string(const char* value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void comment::set_string(const char* value, size_t size) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* comment::mutable_string() {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  return string_;
}
inline ::std::string* comment::release_string() {
  clear_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_;
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .attributes attributes = 2;
inline bool comment::has_attributes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void comment::set_has_attributes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void comment::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void comment::clear_attributes() {
  if (attributes_ != NULL) attributes_->::attributes::Clear();
  clear_has_attributes();
}
inline const ::attributes& comment::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::attributes* comment::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::attributes;
  return attributes_;
}
inline ::attributes* comment::release_attributes() {
  clear_has_attributes();
  ::attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// special

// required string string = 1;
inline bool special::has_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void special::set_has_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void special::clear_has_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void special::clear_string() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    string_->clear();
  }
  clear_has_string();
}
inline const ::std::string& special::string() const {
  return *string_;
}
inline void special::set_string(const ::std::string& value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void special::set_string(const char* value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void special::set_string(const char* value, size_t size) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* special::mutable_string() {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  return string_;
}
inline ::std::string* special::release_string() {
  clear_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_;
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .attributes attributes = 2;
inline bool special::has_attributes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void special::set_has_attributes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void special::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void special::clear_attributes() {
  if (attributes_ != NULL) attributes_->::attributes::Clear();
  clear_has_attributes();
}
inline const ::attributes& special::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::attributes* special::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::attributes;
  return attributes_;
}
inline ::attributes* special::release_attributes() {
  clear_has_attributes();
  ::attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// typ

// optional sint32 reg = 1;
inline bool typ::has_reg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void typ::set_has_reg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void typ::clear_has_reg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void typ::clear_reg() {
  reg_ = 0;
  clear_has_reg();
}
inline ::google::protobuf::int32 typ::reg() const {
  return reg_;
}
inline void typ::set_reg(::google::protobuf::int32 value) {
  set_has_reg();
  reg_ = value;
}

// optional .tmem tmem = 2;
inline bool typ::has_tmem() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void typ::set_has_tmem() {
  _has_bits_[0] |= 0x00000002u;
}
inline void typ::clear_has_tmem() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void typ::clear_tmem() {
  if (tmem_ != NULL) tmem_->::tmem::Clear();
  clear_has_tmem();
}
inline const ::tmem& typ::tmem() const {
  return tmem_ != NULL ? *tmem_ : *default_instance_->tmem_;
}
inline ::tmem* typ::mutable_tmem() {
  set_has_tmem();
  if (tmem_ == NULL) tmem_ = new ::tmem;
  return tmem_;
}
inline ::tmem* typ::release_tmem() {
  clear_has_tmem();
  ::tmem* temp = tmem_;
  tmem_ = NULL;
  return temp;
}

// optional .array array = 3;
inline bool typ::has_array() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void typ::set_has_array() {
  _has_bits_[0] |= 0x00000004u;
}
inline void typ::clear_has_array() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void typ::clear_array() {
  if (array_ != NULL) array_->::array::Clear();
  clear_has_array();
}
inline const ::array& typ::array() const {
  return array_ != NULL ? *array_ : *default_instance_->array_;
}
inline ::array* typ::mutable_array() {
  set_has_array();
  if (array_ == NULL) array_ = new ::array;
  return array_;
}
inline ::array* typ::release_array() {
  clear_has_array();
  ::array* temp = array_;
  array_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// tmem

// required .typ index_type = 1;
inline bool tmem::has_index_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tmem::set_has_index_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tmem::clear_has_index_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tmem::clear_index_type() {
  if (index_type_ != NULL) index_type_->::typ::Clear();
  clear_has_index_type();
}
inline const ::typ& tmem::index_type() const {
  return index_type_ != NULL ? *index_type_ : *default_instance_->index_type_;
}
inline ::typ* tmem::mutable_index_type() {
  set_has_index_type();
  if (index_type_ == NULL) index_type_ = new ::typ;
  return index_type_;
}
inline ::typ* tmem::release_index_type() {
  clear_has_index_type();
  ::typ* temp = index_type_;
  index_type_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// array

// required .typ index_type = 1;
inline bool array::has_index_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void array::set_has_index_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void array::clear_has_index_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void array::clear_index_type() {
  if (index_type_ != NULL) index_type_->::typ::Clear();
  clear_has_index_type();
}
inline const ::typ& array::index_type() const {
  return index_type_ != NULL ? *index_type_ : *default_instance_->index_type_;
}
inline ::typ* array::mutable_index_type() {
  set_has_index_type();
  if (index_type_ == NULL) index_type_ = new ::typ;
  return index_type_;
}
inline ::typ* array::release_index_type() {
  clear_has_index_type();
  ::typ* temp = index_type_;
  index_type_ = NULL;
  return temp;
}

// required .typ element_type = 2;
inline bool array::has_element_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void array::set_has_element_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void array::clear_has_element_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void array::clear_element_type() {
  if (element_type_ != NULL) element_type_->::typ::Clear();
  clear_has_element_type();
}
inline const ::typ& array::element_type() const {
  return element_type_ != NULL ? *element_type_ : *default_instance_->element_type_;
}
inline ::typ* array::mutable_element_type() {
  set_has_element_type();
  if (element_type_ == NULL) element_type_ = new ::typ;
  return element_type_;
}
inline ::typ* array::release_element_type() {
  clear_has_element_type();
  ::typ* temp = element_type_;
  element_type_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// label

// optional string name = 1;
inline bool label::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void label::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void label::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void label::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& label::name() const {
  return *name_;
}
inline void label::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void label::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void label::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* label::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* label::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional sint64 addr = 2;
inline bool label::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void label::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void label::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void label::clear_addr() {
  addr_ = GOOGLE_LONGLONG(0);
  clear_has_addr();
}
inline ::google::protobuf::int64 label::addr() const {
  return addr_;
}
inline void label::set_addr(::google::protobuf::int64 value) {
  set_has_addr();
  addr_ = value;
}

// -------------------------------------------------------------------

// var

// required string name = 1;
inline bool var::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void var::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void var::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void var::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& var::name() const {
  return *name_;
}
inline void var::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void var::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void var::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* var::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* var::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required sint32 id = 2;
inline bool var::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void var::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void var::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void var::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 var::id() const {
  return id_;
}
inline void var::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required .typ typ = 3;
inline bool var::has_typ() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void var::set_has_typ() {
  _has_bits_[0] |= 0x00000004u;
}
inline void var::clear_has_typ() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void var::clear_typ() {
  if (typ_ != NULL) typ_->::typ::Clear();
  clear_has_typ();
}
inline const ::typ& var::typ() const {
  return typ_ != NULL ? *typ_ : *default_instance_->typ_;
}
inline ::typ* var::mutable_typ() {
  set_has_typ();
  if (typ_ == NULL) typ_ = new ::typ;
  return typ_;
}
inline ::typ* var::release_typ() {
  clear_has_typ();
  ::typ* temp = typ_;
  typ_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// attribute

// optional string asm = 1;
inline bool attribute::has_asm_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void attribute::set_has_asm_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void attribute::clear_has_asm_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void attribute::clear_asm_() {
  if (asm__ != &::google::protobuf::internal::kEmptyString) {
    asm__->clear();
  }
  clear_has_asm_();
}
inline const ::std::string& attribute::asm_() const {
  return *asm__;
}
inline void attribute::set_asm_(const ::std::string& value) {
  set_has_asm_();
  if (asm__ == &::google::protobuf::internal::kEmptyString) {
    asm__ = new ::std::string;
  }
  asm__->assign(value);
}
inline void attribute::set_asm_(const char* value) {
  set_has_asm_();
  if (asm__ == &::google::protobuf::internal::kEmptyString) {
    asm__ = new ::std::string;
  }
  asm__->assign(value);
}
inline void attribute::set_asm_(const char* value, size_t size) {
  set_has_asm_();
  if (asm__ == &::google::protobuf::internal::kEmptyString) {
    asm__ = new ::std::string;
  }
  asm__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* attribute::mutable_asm_() {
  set_has_asm_();
  if (asm__ == &::google::protobuf::internal::kEmptyString) {
    asm__ = new ::std::string;
  }
  return asm__;
}
inline ::std::string* attribute::release_asm_() {
  clear_has_asm_();
  if (asm__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = asm__;
    asm__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional sint64 address = 2;
inline bool attribute::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void attribute::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void attribute::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void attribute::clear_address() {
  address_ = GOOGLE_LONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::int64 attribute::address() const {
  return address_;
}
inline void attribute::set_address(::google::protobuf::int64 value) {
  set_has_address();
  address_ = value;
}

// optional .liveout liveout = 3;
inline bool attribute::has_liveout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void attribute::set_has_liveout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void attribute::clear_has_liveout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void attribute::clear_liveout() {
  if (liveout_ != NULL) liveout_->::liveout::Clear();
  clear_has_liveout();
}
inline const ::liveout& attribute::liveout() const {
  return liveout_ != NULL ? *liveout_ : *default_instance_->liveout_;
}
inline ::liveout* attribute::mutable_liveout() {
  set_has_liveout();
  if (liveout_ == NULL) liveout_ = new ::liveout;
  return liveout_;
}
inline ::liveout* attribute::release_liveout() {
  clear_has_liveout();
  ::liveout* temp = liveout_;
  liveout_ = NULL;
  return temp;
}

// optional string strattr = 4;
inline bool attribute::has_strattr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void attribute::set_has_strattr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void attribute::clear_has_strattr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void attribute::clear_strattr() {
  if (strattr_ != &::google::protobuf::internal::kEmptyString) {
    strattr_->clear();
  }
  clear_has_strattr();
}
inline const ::std::string& attribute::strattr() const {
  return *strattr_;
}
inline void attribute::set_strattr(const ::std::string& value) {
  set_has_strattr();
  if (strattr_ == &::google::protobuf::internal::kEmptyString) {
    strattr_ = new ::std::string;
  }
  strattr_->assign(value);
}
inline void attribute::set_strattr(const char* value) {
  set_has_strattr();
  if (strattr_ == &::google::protobuf::internal::kEmptyString) {
    strattr_ = new ::std::string;
  }
  strattr_->assign(value);
}
inline void attribute::set_strattr(const char* value, size_t size) {
  set_has_strattr();
  if (strattr_ == &::google::protobuf::internal::kEmptyString) {
    strattr_ = new ::std::string;
  }
  strattr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* attribute::mutable_strattr() {
  set_has_strattr();
  if (strattr_ == &::google::protobuf::internal::kEmptyString) {
    strattr_ = new ::std::string;
  }
  return strattr_;
}
inline ::std::string* attribute::release_strattr() {
  clear_has_strattr();
  if (strattr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strattr_;
    strattr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .context context = 5;
inline bool attribute::has_context() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void attribute::set_has_context() {
  _has_bits_[0] |= 0x00000010u;
}
inline void attribute::clear_has_context() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void attribute::clear_context() {
  if (context_ != NULL) context_->::context::Clear();
  clear_has_context();
}
inline const ::context& attribute::context() const {
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::context* attribute::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::context;
  return context_;
}
inline ::context* attribute::release_context() {
  clear_has_context();
  ::context* temp = context_;
  context_ = NULL;
  return temp;
}

// optional uint64 thread_id = 6;
inline bool attribute::has_thread_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void attribute::set_has_thread_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void attribute::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void attribute::clear_thread_id() {
  thread_id_ = GOOGLE_ULONGLONG(0);
  clear_has_thread_id();
}
inline ::google::protobuf::uint64 attribute::thread_id() const {
  return thread_id_;
}
inline void attribute::set_thread_id(::google::protobuf::uint64 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// optional .synthetic synthetic = 7;
inline bool attribute::has_synthetic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void attribute::set_has_synthetic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void attribute::clear_has_synthetic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void attribute::clear_synthetic() {
  if (synthetic_ != NULL) synthetic_->::synthetic::Clear();
  clear_has_synthetic();
}
inline const ::synthetic& attribute::synthetic() const {
  return synthetic_ != NULL ? *synthetic_ : *default_instance_->synthetic_;
}
inline ::synthetic* attribute::mutable_synthetic() {
  set_has_synthetic();
  if (synthetic_ == NULL) synthetic_ = new ::synthetic;
  return synthetic_;
}
inline ::synthetic* attribute::release_synthetic() {
  clear_has_synthetic();
  ::synthetic* temp = synthetic_;
  synthetic_ = NULL;
  return temp;
}

// optional string other = 8;
inline bool attribute::has_other() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void attribute::set_has_other() {
  _has_bits_[0] |= 0x00000080u;
}
inline void attribute::clear_has_other() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void attribute::clear_other() {
  if (other_ != &::google::protobuf::internal::kEmptyString) {
    other_->clear();
  }
  clear_has_other();
}
inline const ::std::string& attribute::other() const {
  return *other_;
}
inline void attribute::set_other(const ::std::string& value) {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  other_->assign(value);
}
inline void attribute::set_other(const char* value) {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  other_->assign(value);
}
inline void attribute::set_other(const char* value, size_t size) {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  other_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* attribute::mutable_other() {
  set_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    other_ = new ::std::string;
  }
  return other_;
}
inline ::std::string* attribute::release_other() {
  clear_has_other();
  if (other_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = other_;
    other_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// attributes

// repeated .attribute elem = 1;
inline int attributes::elem_size() const {
  return elem_.size();
}
inline void attributes::clear_elem() {
  elem_.Clear();
}
inline const ::attribute& attributes::elem(int index) const {
  return elem_.Get(index);
}
inline ::attribute* attributes::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::attribute* attributes::add_elem() {
  return elem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::attribute >&
attributes::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::attribute >*
attributes::mutable_elem() {
  return &elem_;
}

// -------------------------------------------------------------------

// liveout

// -------------------------------------------------------------------

// synthetic

// -------------------------------------------------------------------

// operand_info_specific

// optional .mem_operand mem_operand = 1;
inline bool operand_info_specific::has_mem_operand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void operand_info_specific::set_has_mem_operand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void operand_info_specific::clear_has_mem_operand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void operand_info_specific::clear_mem_operand() {
  if (mem_operand_ != NULL) mem_operand_->::mem_operand::Clear();
  clear_has_mem_operand();
}
inline const ::mem_operand& operand_info_specific::mem_operand() const {
  return mem_operand_ != NULL ? *mem_operand_ : *default_instance_->mem_operand_;
}
inline ::mem_operand* operand_info_specific::mutable_mem_operand() {
  set_has_mem_operand();
  if (mem_operand_ == NULL) mem_operand_ = new ::mem_operand;
  return mem_operand_;
}
inline ::mem_operand* operand_info_specific::release_mem_operand() {
  clear_has_mem_operand();
  ::mem_operand* temp = mem_operand_;
  mem_operand_ = NULL;
  return temp;
}

// optional .reg_operand reg_operand = 2;
inline bool operand_info_specific::has_reg_operand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void operand_info_specific::set_has_reg_operand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void operand_info_specific::clear_has_reg_operand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void operand_info_specific::clear_reg_operand() {
  if (reg_operand_ != NULL) reg_operand_->::reg_operand::Clear();
  clear_has_reg_operand();
}
inline const ::reg_operand& operand_info_specific::reg_operand() const {
  return reg_operand_ != NULL ? *reg_operand_ : *default_instance_->reg_operand_;
}
inline ::reg_operand* operand_info_specific::mutable_reg_operand() {
  set_has_reg_operand();
  if (reg_operand_ == NULL) reg_operand_ = new ::reg_operand;
  return reg_operand_;
}
inline ::reg_operand* operand_info_specific::release_reg_operand() {
  clear_has_reg_operand();
  ::reg_operand* temp = reg_operand_;
  reg_operand_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// reg_operand

// required string name = 1;
inline bool reg_operand::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reg_operand::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reg_operand::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reg_operand::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& reg_operand::name() const {
  return *name_;
}
inline void reg_operand::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void reg_operand::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void reg_operand::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* reg_operand::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* reg_operand::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// operand_usage

// required bool read = 1;
inline bool operand_usage::has_read() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void operand_usage::set_has_read() {
  _has_bits_[0] |= 0x00000001u;
}
inline void operand_usage::clear_has_read() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void operand_usage::clear_read() {
  read_ = false;
  clear_has_read();
}
inline bool operand_usage::read() const {
  return read_;
}
inline void operand_usage::set_read(bool value) {
  set_has_read();
  read_ = value;
}

// required bool written = 2;
inline bool operand_usage::has_written() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void operand_usage::set_has_written() {
  _has_bits_[0] |= 0x00000002u;
}
inline void operand_usage::clear_has_written() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void operand_usage::clear_written() {
  written_ = false;
  clear_has_written();
}
inline bool operand_usage::written() const {
  return written_;
}
inline void operand_usage::set_written(bool value) {
  set_has_written();
  written_ = value;
}

// required bool index = 3;
inline bool operand_usage::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void operand_usage::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void operand_usage::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void operand_usage::clear_index() {
  index_ = false;
  clear_has_index();
}
inline bool operand_usage::index() const {
  return index_;
}
inline void operand_usage::set_index(bool value) {
  set_has_index();
  index_ = value;
}

// required bool base = 4;
inline bool operand_usage::has_base() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void operand_usage::set_has_base() {
  _has_bits_[0] |= 0x00000008u;
}
inline void operand_usage::clear_has_base() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void operand_usage::clear_base() {
  base_ = false;
  clear_has_base();
}
inline bool operand_usage::base() const {
  return base_;
}
inline void operand_usage::set_base(bool value) {
  set_has_base();
  base_ = value;
}

// -------------------------------------------------------------------

// mem_operand

// required sint64 address = 1;
inline bool mem_operand::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mem_operand::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mem_operand::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mem_operand::clear_address() {
  address_ = GOOGLE_LONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::int64 mem_operand::address() const {
  return address_;
}
inline void mem_operand::set_address(::google::protobuf::int64 value) {
  set_has_address();
  address_ = value;
}

// -------------------------------------------------------------------

// taint_info

// optional bool no_taint = 1;
inline bool taint_info::has_no_taint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void taint_info::set_has_no_taint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void taint_info::clear_has_no_taint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void taint_info::clear_no_taint() {
  no_taint_ = false;
  clear_has_no_taint();
}
inline bool taint_info::no_taint() const {
  return no_taint_;
}
inline void taint_info::set_no_taint(bool value) {
  set_has_no_taint();
  no_taint_ = value;
}

// optional uint64 taint_id = 2;
inline bool taint_info::has_taint_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void taint_info::set_has_taint_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void taint_info::clear_has_taint_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void taint_info::clear_taint_id() {
  taint_id_ = GOOGLE_ULONGLONG(0);
  clear_has_taint_id();
}
inline ::google::protobuf::uint64 taint_info::taint_id() const {
  return taint_id_;
}
inline void taint_info::set_taint_id(::google::protobuf::uint64 value) {
  set_has_taint_id();
  taint_id_ = value;
}

// optional bool taint_multiple = 3;
inline bool taint_info::has_taint_multiple() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void taint_info::set_has_taint_multiple() {
  _has_bits_[0] |= 0x00000004u;
}
inline void taint_info::clear_has_taint_multiple() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void taint_info::clear_taint_multiple() {
  taint_multiple_ = false;
  clear_has_taint_multiple();
}
inline bool taint_info::taint_multiple() const {
  return taint_multiple_;
}
inline void taint_info::set_taint_multiple(bool value) {
  set_has_taint_multiple();
  taint_multiple_ = value;
}

// -------------------------------------------------------------------

// context

// required .operand_info_specific operand_info_specific = 1;
inline bool context::has_operand_info_specific() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void context::set_has_operand_info_specific() {
  _has_bits_[0] |= 0x00000001u;
}
inline void context::clear_has_operand_info_specific() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void context::clear_operand_info_specific() {
  if (operand_info_specific_ != NULL) operand_info_specific_->::operand_info_specific::Clear();
  clear_has_operand_info_specific();
}
inline const ::operand_info_specific& context::operand_info_specific() const {
  return operand_info_specific_ != NULL ? *operand_info_specific_ : *default_instance_->operand_info_specific_;
}
inline ::operand_info_specific* context::mutable_operand_info_specific() {
  set_has_operand_info_specific();
  if (operand_info_specific_ == NULL) operand_info_specific_ = new ::operand_info_specific;
  return operand_info_specific_;
}
inline ::operand_info_specific* context::release_operand_info_specific() {
  clear_has_operand_info_specific();
  ::operand_info_specific* temp = operand_info_specific_;
  operand_info_specific_ = NULL;
  return temp;
}

// required sint32 bit_length = 2;
inline bool context::has_bit_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void context::set_has_bit_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void context::clear_has_bit_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void context::clear_bit_length() {
  bit_length_ = 0;
  clear_has_bit_length();
}
inline ::google::protobuf::int32 context::bit_length() const {
  return bit_length_;
}
inline void context::set_bit_length(::google::protobuf::int32 value) {
  set_has_bit_length();
  bit_length_ = value;
}

// required .operand_usage operand_usage = 3;
inline bool context::has_operand_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void context::set_has_operand_usage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void context::clear_has_operand_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void context::clear_operand_usage() {
  if (operand_usage_ != NULL) operand_usage_->::operand_usage::Clear();
  clear_has_operand_usage();
}
inline const ::operand_usage& context::operand_usage() const {
  return operand_usage_ != NULL ? *operand_usage_ : *default_instance_->operand_usage_;
}
inline ::operand_usage* context::mutable_operand_usage() {
  set_has_operand_usage();
  if (operand_usage_ == NULL) operand_usage_ = new ::operand_usage;
  return operand_usage_;
}
inline ::operand_usage* context::release_operand_usage() {
  clear_has_operand_usage();
  ::operand_usage* temp = operand_usage_;
  operand_usage_ = NULL;
  return temp;
}

// required .taint_info taint_info = 4;
inline bool context::has_taint_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void context::set_has_taint_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void context::clear_has_taint_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void context::clear_taint_info() {
  if (taint_info_ != NULL) taint_info_->::taint_info::Clear();
  clear_has_taint_info();
}
inline const ::taint_info& context::taint_info() const {
  return taint_info_ != NULL ? *taint_info_ : *default_instance_->taint_info_;
}
inline ::taint_info* context::mutable_taint_info() {
  set_has_taint_info();
  if (taint_info_ == NULL) taint_info_ = new ::taint_info;
  return taint_info_;
}
inline ::taint_info* context::release_taint_info() {
  clear_has_taint_info();
  ::taint_info* temp = taint_info_;
  taint_info_ = NULL;
  return temp;
}

// required string value = 5;
inline bool context::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void context::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void context::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void context::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& context::value() const {
  return *value_;
}
inline void context::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void context::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void context::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* context::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* context::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// exp

// optional .load load = 1;
inline bool exp::has_load() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exp::set_has_load() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exp::clear_has_load() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exp::clear_load() {
  if (load_ != NULL) load_->::load::Clear();
  clear_has_load();
}
inline const ::load& exp::load() const {
  return load_ != NULL ? *load_ : *default_instance_->load_;
}
inline ::load* exp::mutable_load() {
  set_has_load();
  if (load_ == NULL) load_ = new ::load;
  return load_;
}
inline ::load* exp::release_load() {
  clear_has_load();
  ::load* temp = load_;
  load_ = NULL;
  return temp;
}

// optional .store store = 2;
inline bool exp::has_store() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exp::set_has_store() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exp::clear_has_store() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exp::clear_store() {
  if (store_ != NULL) store_->::store::Clear();
  clear_has_store();
}
inline const ::store& exp::store() const {
  return store_ != NULL ? *store_ : *default_instance_->store_;
}
inline ::store* exp::mutable_store() {
  set_has_store();
  if (store_ == NULL) store_ = new ::store;
  return store_;
}
inline ::store* exp::release_store() {
  clear_has_store();
  ::store* temp = store_;
  store_ = NULL;
  return temp;
}

// optional .binop binop = 3;
inline bool exp::has_binop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void exp::set_has_binop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void exp::clear_has_binop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void exp::clear_binop() {
  if (binop_ != NULL) binop_->::binop::Clear();
  clear_has_binop();
}
inline const ::binop& exp::binop() const {
  return binop_ != NULL ? *binop_ : *default_instance_->binop_;
}
inline ::binop* exp::mutable_binop() {
  set_has_binop();
  if (binop_ == NULL) binop_ = new ::binop;
  return binop_;
}
inline ::binop* exp::release_binop() {
  clear_has_binop();
  ::binop* temp = binop_;
  binop_ = NULL;
  return temp;
}

// optional .unop unop = 4;
inline bool exp::has_unop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void exp::set_has_unop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void exp::clear_has_unop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void exp::clear_unop() {
  if (unop_ != NULL) unop_->::unop::Clear();
  clear_has_unop();
}
inline const ::unop& exp::unop() const {
  return unop_ != NULL ? *unop_ : *default_instance_->unop_;
}
inline ::unop* exp::mutable_unop() {
  set_has_unop();
  if (unop_ == NULL) unop_ = new ::unop;
  return unop_;
}
inline ::unop* exp::release_unop() {
  clear_has_unop();
  ::unop* temp = unop_;
  unop_ = NULL;
  return temp;
}

// optional .var var = 5;
inline bool exp::has_var() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void exp::set_has_var() {
  _has_bits_[0] |= 0x00000010u;
}
inline void exp::clear_has_var() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void exp::clear_var() {
  if (var_ != NULL) var_->::var::Clear();
  clear_has_var();
}
inline const ::var& exp::var() const {
  return var_ != NULL ? *var_ : *default_instance_->var_;
}
inline ::var* exp::mutable_var() {
  set_has_var();
  if (var_ == NULL) var_ = new ::var;
  return var_;
}
inline ::var* exp::release_var() {
  clear_has_var();
  ::var* temp = var_;
  var_ = NULL;
  return temp;
}

// optional string lab = 6;
inline bool exp::has_lab() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void exp::set_has_lab() {
  _has_bits_[0] |= 0x00000020u;
}
inline void exp::clear_has_lab() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void exp::clear_lab() {
  if (lab_ != &::google::protobuf::internal::kEmptyString) {
    lab_->clear();
  }
  clear_has_lab();
}
inline const ::std::string& exp::lab() const {
  return *lab_;
}
inline void exp::set_lab(const ::std::string& value) {
  set_has_lab();
  if (lab_ == &::google::protobuf::internal::kEmptyString) {
    lab_ = new ::std::string;
  }
  lab_->assign(value);
}
inline void exp::set_lab(const char* value) {
  set_has_lab();
  if (lab_ == &::google::protobuf::internal::kEmptyString) {
    lab_ = new ::std::string;
  }
  lab_->assign(value);
}
inline void exp::set_lab(const char* value, size_t size) {
  set_has_lab();
  if (lab_ == &::google::protobuf::internal::kEmptyString) {
    lab_ = new ::std::string;
  }
  lab_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exp::mutable_lab() {
  set_has_lab();
  if (lab_ == &::google::protobuf::internal::kEmptyString) {
    lab_ = new ::std::string;
  }
  return lab_;
}
inline ::std::string* exp::release_lab() {
  clear_has_lab();
  if (lab_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lab_;
    lab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .inte inte = 7;
inline bool exp::has_inte() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void exp::set_has_inte() {
  _has_bits_[0] |= 0x00000040u;
}
inline void exp::clear_has_inte() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void exp::clear_inte() {
  if (inte_ != NULL) inte_->::inte::Clear();
  clear_has_inte();
}
inline const ::inte& exp::inte() const {
  return inte_ != NULL ? *inte_ : *default_instance_->inte_;
}
inline ::inte* exp::mutable_inte() {
  set_has_inte();
  if (inte_ == NULL) inte_ = new ::inte;
  return inte_;
}
inline ::inte* exp::release_inte() {
  clear_has_inte();
  ::inte* temp = inte_;
  inte_ = NULL;
  return temp;
}

// optional .cast cast = 8;
inline bool exp::has_cast() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void exp::set_has_cast() {
  _has_bits_[0] |= 0x00000080u;
}
inline void exp::clear_has_cast() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void exp::clear_cast() {
  if (cast_ != NULL) cast_->::cast::Clear();
  clear_has_cast();
}
inline const ::cast& exp::cast() const {
  return cast_ != NULL ? *cast_ : *default_instance_->cast_;
}
inline ::cast* exp::mutable_cast() {
  set_has_cast();
  if (cast_ == NULL) cast_ = new ::cast;
  return cast_;
}
inline ::cast* exp::release_cast() {
  clear_has_cast();
  ::cast* temp = cast_;
  cast_ = NULL;
  return temp;
}

// optional .let_exp let_exp = 9;
inline bool exp::has_let_exp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void exp::set_has_let_exp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void exp::clear_has_let_exp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void exp::clear_let_exp() {
  if (let_exp_ != NULL) let_exp_->::let_exp::Clear();
  clear_has_let_exp();
}
inline const ::let_exp& exp::let_exp() const {
  return let_exp_ != NULL ? *let_exp_ : *default_instance_->let_exp_;
}
inline ::let_exp* exp::mutable_let_exp() {
  set_has_let_exp();
  if (let_exp_ == NULL) let_exp_ = new ::let_exp;
  return let_exp_;
}
inline ::let_exp* exp::release_let_exp() {
  clear_has_let_exp();
  ::let_exp* temp = let_exp_;
  let_exp_ = NULL;
  return temp;
}

// optional .unknown unknown = 10;
inline bool exp::has_unknown() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void exp::set_has_unknown() {
  _has_bits_[0] |= 0x00000200u;
}
inline void exp::clear_has_unknown() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void exp::clear_unknown() {
  if (unknown_ != NULL) unknown_->::unknown::Clear();
  clear_has_unknown();
}
inline const ::unknown& exp::unknown() const {
  return unknown_ != NULL ? *unknown_ : *default_instance_->unknown_;
}
inline ::unknown* exp::mutable_unknown() {
  set_has_unknown();
  if (unknown_ == NULL) unknown_ = new ::unknown;
  return unknown_;
}
inline ::unknown* exp::release_unknown() {
  clear_has_unknown();
  ::unknown* temp = unknown_;
  unknown_ = NULL;
  return temp;
}

// optional .ite ite = 11;
inline bool exp::has_ite() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void exp::set_has_ite() {
  _has_bits_[0] |= 0x00000400u;
}
inline void exp::clear_has_ite() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void exp::clear_ite() {
  if (ite_ != NULL) ite_->::ite::Clear();
  clear_has_ite();
}
inline const ::ite& exp::ite() const {
  return ite_ != NULL ? *ite_ : *default_instance_->ite_;
}
inline ::ite* exp::mutable_ite() {
  set_has_ite();
  if (ite_ == NULL) ite_ = new ::ite;
  return ite_;
}
inline ::ite* exp::release_ite() {
  clear_has_ite();
  ::ite* temp = ite_;
  ite_ = NULL;
  return temp;
}

// optional .extract extract = 12;
inline bool exp::has_extract() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void exp::set_has_extract() {
  _has_bits_[0] |= 0x00000800u;
}
inline void exp::clear_has_extract() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void exp::clear_extract() {
  if (extract_ != NULL) extract_->::extract::Clear();
  clear_has_extract();
}
inline const ::extract& exp::extract() const {
  return extract_ != NULL ? *extract_ : *default_instance_->extract_;
}
inline ::extract* exp::mutable_extract() {
  set_has_extract();
  if (extract_ == NULL) extract_ = new ::extract;
  return extract_;
}
inline ::extract* exp::release_extract() {
  clear_has_extract();
  ::extract* temp = extract_;
  extract_ = NULL;
  return temp;
}

// optional .concat concat = 13;
inline bool exp::has_concat() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void exp::set_has_concat() {
  _has_bits_[0] |= 0x00001000u;
}
inline void exp::clear_has_concat() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void exp::clear_concat() {
  if (concat_ != NULL) concat_->::concat::Clear();
  clear_has_concat();
}
inline const ::concat& exp::concat() const {
  return concat_ != NULL ? *concat_ : *default_instance_->concat_;
}
inline ::concat* exp::mutable_concat() {
  set_has_concat();
  if (concat_ == NULL) concat_ = new ::concat;
  return concat_;
}
inline ::concat* exp::release_concat() {
  clear_has_concat();
  ::concat* temp = concat_;
  concat_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// load

// required .exp memory = 1;
inline bool load::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void load::set_has_memory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void load::clear_has_memory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void load::clear_memory() {
  if (memory_ != NULL) memory_->::exp::Clear();
  clear_has_memory();
}
inline const ::exp& load::memory() const {
  return memory_ != NULL ? *memory_ : *default_instance_->memory_;
}
inline ::exp* load::mutable_memory() {
  set_has_memory();
  if (memory_ == NULL) memory_ = new ::exp;
  return memory_;
}
inline ::exp* load::release_memory() {
  clear_has_memory();
  ::exp* temp = memory_;
  memory_ = NULL;
  return temp;
}

// required .exp address = 2;
inline bool load::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void load::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void load::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void load::clear_address() {
  if (address_ != NULL) address_->::exp::Clear();
  clear_has_address();
}
inline const ::exp& load::address() const {
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::exp* load::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::exp;
  return address_;
}
inline ::exp* load::release_address() {
  clear_has_address();
  ::exp* temp = address_;
  address_ = NULL;
  return temp;
}

// required .exp endian = 3;
inline bool load::has_endian() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void load::set_has_endian() {
  _has_bits_[0] |= 0x00000004u;
}
inline void load::clear_has_endian() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void load::clear_endian() {
  if (endian_ != NULL) endian_->::exp::Clear();
  clear_has_endian();
}
inline const ::exp& load::endian() const {
  return endian_ != NULL ? *endian_ : *default_instance_->endian_;
}
inline ::exp* load::mutable_endian() {
  set_has_endian();
  if (endian_ == NULL) endian_ = new ::exp;
  return endian_;
}
inline ::exp* load::release_endian() {
  clear_has_endian();
  ::exp* temp = endian_;
  endian_ = NULL;
  return temp;
}

// required .typ typ = 4;
inline bool load::has_typ() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void load::set_has_typ() {
  _has_bits_[0] |= 0x00000008u;
}
inline void load::clear_has_typ() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void load::clear_typ() {
  if (typ_ != NULL) typ_->::typ::Clear();
  clear_has_typ();
}
inline const ::typ& load::typ() const {
  return typ_ != NULL ? *typ_ : *default_instance_->typ_;
}
inline ::typ* load::mutable_typ() {
  set_has_typ();
  if (typ_ == NULL) typ_ = new ::typ;
  return typ_;
}
inline ::typ* load::release_typ() {
  clear_has_typ();
  ::typ* temp = typ_;
  typ_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// store

// required .exp memory = 1;
inline bool store::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void store::set_has_memory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void store::clear_has_memory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void store::clear_memory() {
  if (memory_ != NULL) memory_->::exp::Clear();
  clear_has_memory();
}
inline const ::exp& store::memory() const {
  return memory_ != NULL ? *memory_ : *default_instance_->memory_;
}
inline ::exp* store::mutable_memory() {
  set_has_memory();
  if (memory_ == NULL) memory_ = new ::exp;
  return memory_;
}
inline ::exp* store::release_memory() {
  clear_has_memory();
  ::exp* temp = memory_;
  memory_ = NULL;
  return temp;
}

// required .exp address = 2;
inline bool store::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void store::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void store::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void store::clear_address() {
  if (address_ != NULL) address_->::exp::Clear();
  clear_has_address();
}
inline const ::exp& store::address() const {
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::exp* store::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::exp;
  return address_;
}
inline ::exp* store::release_address() {
  clear_has_address();
  ::exp* temp = address_;
  address_ = NULL;
  return temp;
}

// required .exp value = 3;
inline bool store::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void store::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void store::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void store::clear_value() {
  if (value_ != NULL) value_->::exp::Clear();
  clear_has_value();
}
inline const ::exp& store::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::exp* store::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::exp;
  return value_;
}
inline ::exp* store::release_value() {
  clear_has_value();
  ::exp* temp = value_;
  value_ = NULL;
  return temp;
}

// required .exp endian = 4;
inline bool store::has_endian() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void store::set_has_endian() {
  _has_bits_[0] |= 0x00000008u;
}
inline void store::clear_has_endian() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void store::clear_endian() {
  if (endian_ != NULL) endian_->::exp::Clear();
  clear_has_endian();
}
inline const ::exp& store::endian() const {
  return endian_ != NULL ? *endian_ : *default_instance_->endian_;
}
inline ::exp* store::mutable_endian() {
  set_has_endian();
  if (endian_ == NULL) endian_ = new ::exp;
  return endian_;
}
inline ::exp* store::release_endian() {
  clear_has_endian();
  ::exp* temp = endian_;
  endian_ = NULL;
  return temp;
}

// required .typ typ = 5;
inline bool store::has_typ() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void store::set_has_typ() {
  _has_bits_[0] |= 0x00000010u;
}
inline void store::clear_has_typ() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void store::clear_typ() {
  if (typ_ != NULL) typ_->::typ::Clear();
  clear_has_typ();
}
inline const ::typ& store::typ() const {
  return typ_ != NULL ? *typ_ : *default_instance_->typ_;
}
inline ::typ* store::mutable_typ() {
  set_has_typ();
  if (typ_ == NULL) typ_ = new ::typ;
  return typ_;
}
inline ::typ* store::release_typ() {
  clear_has_typ();
  ::typ* temp = typ_;
  typ_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// binop

// required .binop_type binop_type = 1;
inline bool binop::has_binop_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void binop::set_has_binop_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void binop::clear_has_binop_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void binop::clear_binop_type() {
  binop_type_ = 1;
  clear_has_binop_type();
}
inline binop_type binop::binop_type() const {
  return static_cast< binop_type >(binop_type_);
}
inline void binop::set_binop_type(binop_type value) {
  GOOGLE_DCHECK(binop_type_IsValid(value));
  set_has_binop_type();
  binop_type_ = value;
}

// required .exp lexp = 2;
inline bool binop::has_lexp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void binop::set_has_lexp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void binop::clear_has_lexp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void binop::clear_lexp() {
  if (lexp_ != NULL) lexp_->::exp::Clear();
  clear_has_lexp();
}
inline const ::exp& binop::lexp() const {
  return lexp_ != NULL ? *lexp_ : *default_instance_->lexp_;
}
inline ::exp* binop::mutable_lexp() {
  set_has_lexp();
  if (lexp_ == NULL) lexp_ = new ::exp;
  return lexp_;
}
inline ::exp* binop::release_lexp() {
  clear_has_lexp();
  ::exp* temp = lexp_;
  lexp_ = NULL;
  return temp;
}

// required .exp rexp = 3;
inline bool binop::has_rexp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void binop::set_has_rexp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void binop::clear_has_rexp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void binop::clear_rexp() {
  if (rexp_ != NULL) rexp_->::exp::Clear();
  clear_has_rexp();
}
inline const ::exp& binop::rexp() const {
  return rexp_ != NULL ? *rexp_ : *default_instance_->rexp_;
}
inline ::exp* binop::mutable_rexp() {
  set_has_rexp();
  if (rexp_ == NULL) rexp_ = new ::exp;
  return rexp_;
}
inline ::exp* binop::release_rexp() {
  clear_has_rexp();
  ::exp* temp = rexp_;
  rexp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// unop

// required .unop_type unop_type = 1;
inline bool unop::has_unop_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void unop::set_has_unop_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void unop::clear_has_unop_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void unop::clear_unop_type() {
  unop_type_ = 1;
  clear_has_unop_type();
}
inline unop_type unop::unop_type() const {
  return static_cast< unop_type >(unop_type_);
}
inline void unop::set_unop_type(unop_type value) {
  GOOGLE_DCHECK(unop_type_IsValid(value));
  set_has_unop_type();
  unop_type_ = value;
}

// required .exp exp = 2;
inline bool unop::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void unop::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void unop::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void unop::clear_exp() {
  if (exp_ != NULL) exp_->::exp::Clear();
  clear_has_exp();
}
inline const ::exp& unop::exp() const {
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::exp* unop::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::exp;
  return exp_;
}
inline ::exp* unop::release_exp() {
  clear_has_exp();
  ::exp* temp = exp_;
  exp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// inte

// required string int = 1;
inline bool inte::has_int_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void inte::set_has_int_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void inte::clear_has_int_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void inte::clear_int_() {
  if (int__ != &::google::protobuf::internal::kEmptyString) {
    int__->clear();
  }
  clear_has_int_();
}
inline const ::std::string& inte::int_() const {
  return *int__;
}
inline void inte::set_int_(const ::std::string& value) {
  set_has_int_();
  if (int__ == &::google::protobuf::internal::kEmptyString) {
    int__ = new ::std::string;
  }
  int__->assign(value);
}
inline void inte::set_int_(const char* value) {
  set_has_int_();
  if (int__ == &::google::protobuf::internal::kEmptyString) {
    int__ = new ::std::string;
  }
  int__->assign(value);
}
inline void inte::set_int_(const char* value, size_t size) {
  set_has_int_();
  if (int__ == &::google::protobuf::internal::kEmptyString) {
    int__ = new ::std::string;
  }
  int__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* inte::mutable_int_() {
  set_has_int_();
  if (int__ == &::google::protobuf::internal::kEmptyString) {
    int__ = new ::std::string;
  }
  return int__;
}
inline ::std::string* inte::release_int_() {
  clear_has_int_();
  if (int__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = int__;
    int__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .typ typ = 2;
inline bool inte::has_typ() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void inte::set_has_typ() {
  _has_bits_[0] |= 0x00000002u;
}
inline void inte::clear_has_typ() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void inte::clear_typ() {
  if (typ_ != NULL) typ_->::typ::Clear();
  clear_has_typ();
}
inline const ::typ& inte::typ() const {
  return typ_ != NULL ? *typ_ : *default_instance_->typ_;
}
inline ::typ* inte::mutable_typ() {
  set_has_typ();
  if (typ_ == NULL) typ_ = new ::typ;
  return typ_;
}
inline ::typ* inte::release_typ() {
  clear_has_typ();
  ::typ* temp = typ_;
  typ_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// cast

// required .cast_type cast_type = 1;
inline bool cast::has_cast_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cast::set_has_cast_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cast::clear_has_cast_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cast::clear_cast_type() {
  cast_type_ = 1;
  clear_has_cast_type();
}
inline cast_type cast::cast_type() const {
  return static_cast< cast_type >(cast_type_);
}
inline void cast::set_cast_type(cast_type value) {
  GOOGLE_DCHECK(cast_type_IsValid(value));
  set_has_cast_type();
  cast_type_ = value;
}

// required .typ new_type = 2;
inline bool cast::has_new_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cast::set_has_new_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cast::clear_has_new_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cast::clear_new_type() {
  if (new_type_ != NULL) new_type_->::typ::Clear();
  clear_has_new_type();
}
inline const ::typ& cast::new_type() const {
  return new_type_ != NULL ? *new_type_ : *default_instance_->new_type_;
}
inline ::typ* cast::mutable_new_type() {
  set_has_new_type();
  if (new_type_ == NULL) new_type_ = new ::typ;
  return new_type_;
}
inline ::typ* cast::release_new_type() {
  clear_has_new_type();
  ::typ* temp = new_type_;
  new_type_ = NULL;
  return temp;
}

// required .exp exp = 3;
inline bool cast::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cast::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cast::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cast::clear_exp() {
  if (exp_ != NULL) exp_->::exp::Clear();
  clear_has_exp();
}
inline const ::exp& cast::exp() const {
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::exp* cast::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::exp;
  return exp_;
}
inline ::exp* cast::release_exp() {
  clear_has_exp();
  ::exp* temp = exp_;
  exp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// let_exp

// required .var var = 1;
inline bool let_exp::has_var() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void let_exp::set_has_var() {
  _has_bits_[0] |= 0x00000001u;
}
inline void let_exp::clear_has_var() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void let_exp::clear_var() {
  if (var_ != NULL) var_->::var::Clear();
  clear_has_var();
}
inline const ::var& let_exp::var() const {
  return var_ != NULL ? *var_ : *default_instance_->var_;
}
inline ::var* let_exp::mutable_var() {
  set_has_var();
  if (var_ == NULL) var_ = new ::var;
  return var_;
}
inline ::var* let_exp::release_var() {
  clear_has_var();
  ::var* temp = var_;
  var_ = NULL;
  return temp;
}

// required .exp e1 = 2;
inline bool let_exp::has_e1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void let_exp::set_has_e1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void let_exp::clear_has_e1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void let_exp::clear_e1() {
  if (e1_ != NULL) e1_->::exp::Clear();
  clear_has_e1();
}
inline const ::exp& let_exp::e1() const {
  return e1_ != NULL ? *e1_ : *default_instance_->e1_;
}
inline ::exp* let_exp::mutable_e1() {
  set_has_e1();
  if (e1_ == NULL) e1_ = new ::exp;
  return e1_;
}
inline ::exp* let_exp::release_e1() {
  clear_has_e1();
  ::exp* temp = e1_;
  e1_ = NULL;
  return temp;
}

// required .exp e2 = 3;
inline bool let_exp::has_e2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void let_exp::set_has_e2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void let_exp::clear_has_e2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void let_exp::clear_e2() {
  if (e2_ != NULL) e2_->::exp::Clear();
  clear_has_e2();
}
inline const ::exp& let_exp::e2() const {
  return e2_ != NULL ? *e2_ : *default_instance_->e2_;
}
inline ::exp* let_exp::mutable_e2() {
  set_has_e2();
  if (e2_ == NULL) e2_ = new ::exp;
  return e2_;
}
inline ::exp* let_exp::release_e2() {
  clear_has_e2();
  ::exp* temp = e2_;
  e2_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// unknown

// required string string = 1;
inline bool unknown::has_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void unknown::set_has_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void unknown::clear_has_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void unknown::clear_string() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    string_->clear();
  }
  clear_has_string();
}
inline const ::std::string& unknown::string() const {
  return *string_;
}
inline void unknown::set_string(const ::std::string& value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void unknown::set_string(const char* value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void unknown::set_string(const char* value, size_t size) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* unknown::mutable_string() {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  return string_;
}
inline ::std::string* unknown::release_string() {
  clear_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_;
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .typ typ = 2;
inline bool unknown::has_typ() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void unknown::set_has_typ() {
  _has_bits_[0] |= 0x00000002u;
}
inline void unknown::clear_has_typ() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void unknown::clear_typ() {
  if (typ_ != NULL) typ_->::typ::Clear();
  clear_has_typ();
}
inline const ::typ& unknown::typ() const {
  return typ_ != NULL ? *typ_ : *default_instance_->typ_;
}
inline ::typ* unknown::mutable_typ() {
  set_has_typ();
  if (typ_ == NULL) typ_ = new ::typ;
  return typ_;
}
inline ::typ* unknown::release_typ() {
  clear_has_typ();
  ::typ* temp = typ_;
  typ_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ite

// required .exp condition = 1;
inline bool ite::has_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ite::set_has_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ite::clear_has_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ite::clear_condition() {
  if (condition_ != NULL) condition_->::exp::Clear();
  clear_has_condition();
}
inline const ::exp& ite::condition() const {
  return condition_ != NULL ? *condition_ : *default_instance_->condition_;
}
inline ::exp* ite::mutable_condition() {
  set_has_condition();
  if (condition_ == NULL) condition_ = new ::exp;
  return condition_;
}
inline ::exp* ite::release_condition() {
  clear_has_condition();
  ::exp* temp = condition_;
  condition_ = NULL;
  return temp;
}

// required .exp iftrue = 2;
inline bool ite::has_iftrue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ite::set_has_iftrue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ite::clear_has_iftrue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ite::clear_iftrue() {
  if (iftrue_ != NULL) iftrue_->::exp::Clear();
  clear_has_iftrue();
}
inline const ::exp& ite::iftrue() const {
  return iftrue_ != NULL ? *iftrue_ : *default_instance_->iftrue_;
}
inline ::exp* ite::mutable_iftrue() {
  set_has_iftrue();
  if (iftrue_ == NULL) iftrue_ = new ::exp;
  return iftrue_;
}
inline ::exp* ite::release_iftrue() {
  clear_has_iftrue();
  ::exp* temp = iftrue_;
  iftrue_ = NULL;
  return temp;
}

// required .exp iffalse = 3;
inline bool ite::has_iffalse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ite::set_has_iffalse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ite::clear_has_iffalse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ite::clear_iffalse() {
  if (iffalse_ != NULL) iffalse_->::exp::Clear();
  clear_has_iffalse();
}
inline const ::exp& ite::iffalse() const {
  return iffalse_ != NULL ? *iffalse_ : *default_instance_->iffalse_;
}
inline ::exp* ite::mutable_iffalse() {
  set_has_iffalse();
  if (iffalse_ == NULL) iffalse_ = new ::exp;
  return iffalse_;
}
inline ::exp* ite::release_iffalse() {
  clear_has_iffalse();
  ::exp* temp = iffalse_;
  iffalse_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// extract

// required sint32 hbit = 1;
inline bool extract::has_hbit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void extract::set_has_hbit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void extract::clear_has_hbit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void extract::clear_hbit() {
  hbit_ = 0;
  clear_has_hbit();
}
inline ::google::protobuf::int32 extract::hbit() const {
  return hbit_;
}
inline void extract::set_hbit(::google::protobuf::int32 value) {
  set_has_hbit();
  hbit_ = value;
}

// required sint32 lbit = 2;
inline bool extract::has_lbit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void extract::set_has_lbit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void extract::clear_has_lbit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void extract::clear_lbit() {
  lbit_ = 0;
  clear_has_lbit();
}
inline ::google::protobuf::int32 extract::lbit() const {
  return lbit_;
}
inline void extract::set_lbit(::google::protobuf::int32 value) {
  set_has_lbit();
  lbit_ = value;
}

// required .exp exp = 3;
inline bool extract::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void extract::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void extract::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void extract::clear_exp() {
  if (exp_ != NULL) exp_->::exp::Clear();
  clear_has_exp();
}
inline const ::exp& extract::exp() const {
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::exp* extract::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::exp;
  return exp_;
}
inline ::exp* extract::release_exp() {
  clear_has_exp();
  ::exp* temp = exp_;
  exp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// concat

// required .exp le = 1;
inline bool concat::has_le() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void concat::set_has_le() {
  _has_bits_[0] |= 0x00000001u;
}
inline void concat::clear_has_le() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void concat::clear_le() {
  if (le_ != NULL) le_->::exp::Clear();
  clear_has_le();
}
inline const ::exp& concat::le() const {
  return le_ != NULL ? *le_ : *default_instance_->le_;
}
inline ::exp* concat::mutable_le() {
  set_has_le();
  if (le_ == NULL) le_ = new ::exp;
  return le_;
}
inline ::exp* concat::release_le() {
  clear_has_le();
  ::exp* temp = le_;
  le_ = NULL;
  return temp;
}

// required .exp re = 2;
inline bool concat::has_re() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void concat::set_has_re() {
  _has_bits_[0] |= 0x00000002u;
}
inline void concat::clear_has_re() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void concat::clear_re() {
  if (re_ != NULL) re_->::exp::Clear();
  clear_has_re();
}
inline const ::exp& concat::re() const {
  return re_ != NULL ? *re_ : *default_instance_->re_;
}
inline ::exp* concat::mutable_re() {
  set_has_re();
  if (re_ == NULL) re_ = new ::exp;
  return re_;
}
inline ::exp* concat::release_re() {
  clear_has_re();
  ::exp* temp = re_;
  re_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< cast_type>() {
  return cast_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< binop_type>() {
  return binop_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< unop_type>() {
  return unop_type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_stmt_2epiqi_2eproto__INCLUDED
