// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frame.piqi.proto

#ifndef PROTOBUF_frame_2epiqi_2eproto__INCLUDED
#define PROTOBUF_frame_2epiqi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_frame_2epiqi_2eproto();
void protobuf_AssignDesc_frame_2epiqi_2eproto();
void protobuf_ShutdownFile_frame_2epiqi_2eproto();

class frame;
class operand_list;
class operand_info;
class operand_info_specific;
class reg_operand;
class mem_operand;
class operand_usage;
class taint_info;
class std_frame;
class syscall_frame;
class argument_list;
class exception_frame;
class taint_intro_frame;
class taint_intro_list;
class taint_intro;
class modload_frame;
class key_frame;
class tagged_value_lists;
class tagged_value_list;
class value_source_tag;
class value_list;
class value_info;

// ===================================================================

class frame : public ::google::protobuf::Message {
 public:
  frame();
  virtual ~frame();
  
  frame(const frame& from);
  
  inline frame& operator=(const frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const frame& default_instance();
  
  void Swap(frame* other);
  
  // implements Message ----------------------------------------------
  
  frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const frame& from);
  void MergeFrom(const frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .std_frame std_frame = 1;
  inline bool has_std_frame() const;
  inline void clear_std_frame();
  static const int kStdFrameFieldNumber = 1;
  inline const ::std_frame& std_frame() const;
  inline ::std_frame* mutable_std_frame();
  inline ::std_frame* release_std_frame();
  
  // optional .syscall_frame syscall_frame = 2;
  inline bool has_syscall_frame() const;
  inline void clear_syscall_frame();
  static const int kSyscallFrameFieldNumber = 2;
  inline const ::syscall_frame& syscall_frame() const;
  inline ::syscall_frame* mutable_syscall_frame();
  inline ::syscall_frame* release_syscall_frame();
  
  // optional .exception_frame exception_frame = 3;
  inline bool has_exception_frame() const;
  inline void clear_exception_frame();
  static const int kExceptionFrameFieldNumber = 3;
  inline const ::exception_frame& exception_frame() const;
  inline ::exception_frame* mutable_exception_frame();
  inline ::exception_frame* release_exception_frame();
  
  // optional .taint_intro_frame taint_intro_frame = 4;
  inline bool has_taint_intro_frame() const;
  inline void clear_taint_intro_frame();
  static const int kTaintIntroFrameFieldNumber = 4;
  inline const ::taint_intro_frame& taint_intro_frame() const;
  inline ::taint_intro_frame* mutable_taint_intro_frame();
  inline ::taint_intro_frame* release_taint_intro_frame();
  
  // optional .modload_frame modload_frame = 5;
  inline bool has_modload_frame() const;
  inline void clear_modload_frame();
  static const int kModloadFrameFieldNumber = 5;
  inline const ::modload_frame& modload_frame() const;
  inline ::modload_frame* mutable_modload_frame();
  inline ::modload_frame* release_modload_frame();
  
  // optional .key_frame key_frame = 6;
  inline bool has_key_frame() const;
  inline void clear_key_frame();
  static const int kKeyFrameFieldNumber = 6;
  inline const ::key_frame& key_frame() const;
  inline ::key_frame* mutable_key_frame();
  inline ::key_frame* release_key_frame();
  
  // @@protoc_insertion_point(class_scope:frame)
 private:
  inline void set_has_std_frame();
  inline void clear_has_std_frame();
  inline void set_has_syscall_frame();
  inline void clear_has_syscall_frame();
  inline void set_has_exception_frame();
  inline void clear_has_exception_frame();
  inline void set_has_taint_intro_frame();
  inline void clear_has_taint_intro_frame();
  inline void set_has_modload_frame();
  inline void clear_has_modload_frame();
  inline void set_has_key_frame();
  inline void clear_has_key_frame();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std_frame* std_frame_;
  ::syscall_frame* syscall_frame_;
  ::exception_frame* exception_frame_;
  ::taint_intro_frame* taint_intro_frame_;
  ::modload_frame* modload_frame_;
  ::key_frame* key_frame_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static frame* default_instance_;
};
// -------------------------------------------------------------------

class operand_list : public ::google::protobuf::Message {
 public:
  operand_list();
  virtual ~operand_list();
  
  operand_list(const operand_list& from);
  
  inline operand_list& operator=(const operand_list& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const operand_list& default_instance();
  
  void Swap(operand_list* other);
  
  // implements Message ----------------------------------------------
  
  operand_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operand_list& from);
  void MergeFrom(const operand_list& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .operand_info elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::operand_info& elem(int index) const;
  inline ::operand_info* mutable_elem(int index);
  inline ::operand_info* add_elem();
  inline const ::google::protobuf::RepeatedPtrField< ::operand_info >&
      elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::operand_info >*
      mutable_elem();
  
  // @@protoc_insertion_point(class_scope:operand_list)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::operand_info > elem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static operand_list* default_instance_;
};
// -------------------------------------------------------------------

class operand_info : public ::google::protobuf::Message {
 public:
  operand_info();
  virtual ~operand_info();
  
  operand_info(const operand_info& from);
  
  inline operand_info& operator=(const operand_info& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const operand_info& default_instance();
  
  void Swap(operand_info* other);
  
  // implements Message ----------------------------------------------
  
  operand_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operand_info& from);
  void MergeFrom(const operand_info& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .operand_info_specific operand_info_specific = 1;
  inline bool has_operand_info_specific() const;
  inline void clear_operand_info_specific();
  static const int kOperandInfoSpecificFieldNumber = 1;
  inline const ::operand_info_specific& operand_info_specific() const;
  inline ::operand_info_specific* mutable_operand_info_specific();
  inline ::operand_info_specific* release_operand_info_specific();
  
  // required sint32 bit_length = 2;
  inline bool has_bit_length() const;
  inline void clear_bit_length();
  static const int kBitLengthFieldNumber = 2;
  inline ::google::protobuf::int32 bit_length() const;
  inline void set_bit_length(::google::protobuf::int32 value);
  
  // required .operand_usage operand_usage = 3;
  inline bool has_operand_usage() const;
  inline void clear_operand_usage();
  static const int kOperandUsageFieldNumber = 3;
  inline const ::operand_usage& operand_usage() const;
  inline ::operand_usage* mutable_operand_usage();
  inline ::operand_usage* release_operand_usage();
  
  // required .taint_info taint_info = 4;
  inline bool has_taint_info() const;
  inline void clear_taint_info();
  static const int kTaintInfoFieldNumber = 4;
  inline const ::taint_info& taint_info() const;
  inline ::taint_info* mutable_taint_info();
  inline ::taint_info* release_taint_info();
  
  // required bytes value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:operand_info)
 private:
  inline void set_has_operand_info_specific();
  inline void clear_has_operand_info_specific();
  inline void set_has_bit_length();
  inline void clear_has_bit_length();
  inline void set_has_operand_usage();
  inline void clear_has_operand_usage();
  inline void set_has_taint_info();
  inline void clear_has_taint_info();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::operand_info_specific* operand_info_specific_;
  ::operand_usage* operand_usage_;
  ::taint_info* taint_info_;
  ::std::string* value_;
  ::google::protobuf::int32 bit_length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static operand_info* default_instance_;
};
// -------------------------------------------------------------------

class operand_info_specific : public ::google::protobuf::Message {
 public:
  operand_info_specific();
  virtual ~operand_info_specific();
  
  operand_info_specific(const operand_info_specific& from);
  
  inline operand_info_specific& operator=(const operand_info_specific& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const operand_info_specific& default_instance();
  
  void Swap(operand_info_specific* other);
  
  // implements Message ----------------------------------------------
  
  operand_info_specific* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operand_info_specific& from);
  void MergeFrom(const operand_info_specific& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .mem_operand mem_operand = 1;
  inline bool has_mem_operand() const;
  inline void clear_mem_operand();
  static const int kMemOperandFieldNumber = 1;
  inline const ::mem_operand& mem_operand() const;
  inline ::mem_operand* mutable_mem_operand();
  inline ::mem_operand* release_mem_operand();
  
  // optional .reg_operand reg_operand = 2;
  inline bool has_reg_operand() const;
  inline void clear_reg_operand();
  static const int kRegOperandFieldNumber = 2;
  inline const ::reg_operand& reg_operand() const;
  inline ::reg_operand* mutable_reg_operand();
  inline ::reg_operand* release_reg_operand();
  
  // @@protoc_insertion_point(class_scope:operand_info_specific)
 private:
  inline void set_has_mem_operand();
  inline void clear_has_mem_operand();
  inline void set_has_reg_operand();
  inline void clear_has_reg_operand();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::mem_operand* mem_operand_;
  ::reg_operand* reg_operand_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static operand_info_specific* default_instance_;
};
// -------------------------------------------------------------------

class reg_operand : public ::google::protobuf::Message {
 public:
  reg_operand();
  virtual ~reg_operand();
  
  reg_operand(const reg_operand& from);
  
  inline reg_operand& operator=(const reg_operand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const reg_operand& default_instance();
  
  void Swap(reg_operand* other);
  
  // implements Message ----------------------------------------------
  
  reg_operand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reg_operand& from);
  void MergeFrom(const reg_operand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:reg_operand)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static reg_operand* default_instance_;
};
// -------------------------------------------------------------------

class mem_operand : public ::google::protobuf::Message {
 public:
  mem_operand();
  virtual ~mem_operand();
  
  mem_operand(const mem_operand& from);
  
  inline mem_operand& operator=(const mem_operand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mem_operand& default_instance();
  
  void Swap(mem_operand* other);
  
  // implements Message ----------------------------------------------
  
  mem_operand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mem_operand& from);
  void MergeFrom(const mem_operand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline ::google::protobuf::uint64 address() const;
  inline void set_address(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:mem_operand)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 address_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static mem_operand* default_instance_;
};
// -------------------------------------------------------------------

class operand_usage : public ::google::protobuf::Message {
 public:
  operand_usage();
  virtual ~operand_usage();
  
  operand_usage(const operand_usage& from);
  
  inline operand_usage& operator=(const operand_usage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const operand_usage& default_instance();
  
  void Swap(operand_usage* other);
  
  // implements Message ----------------------------------------------
  
  operand_usage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operand_usage& from);
  void MergeFrom(const operand_usage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool read = 1;
  inline bool has_read() const;
  inline void clear_read();
  static const int kReadFieldNumber = 1;
  inline bool read() const;
  inline void set_read(bool value);
  
  // required bool written = 2;
  inline bool has_written() const;
  inline void clear_written();
  static const int kWrittenFieldNumber = 2;
  inline bool written() const;
  inline void set_written(bool value);
  
  // required bool index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline bool index() const;
  inline void set_index(bool value);
  
  // required bool base = 4;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 4;
  inline bool base() const;
  inline void set_base(bool value);
  
  // @@protoc_insertion_point(class_scope:operand_usage)
 private:
  inline void set_has_read();
  inline void clear_has_read();
  inline void set_has_written();
  inline void clear_has_written();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_base();
  inline void clear_has_base();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool read_;
  bool written_;
  bool index_;
  bool base_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static operand_usage* default_instance_;
};
// -------------------------------------------------------------------

class taint_info : public ::google::protobuf::Message {
 public:
  taint_info();
  virtual ~taint_info();
  
  taint_info(const taint_info& from);
  
  inline taint_info& operator=(const taint_info& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const taint_info& default_instance();
  
  void Swap(taint_info* other);
  
  // implements Message ----------------------------------------------
  
  taint_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const taint_info& from);
  void MergeFrom(const taint_info& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool no_taint = 1;
  inline bool has_no_taint() const;
  inline void clear_no_taint();
  static const int kNoTaintFieldNumber = 1;
  inline bool no_taint() const;
  inline void set_no_taint(bool value);
  
  // optional uint64 taint_id = 2;
  inline bool has_taint_id() const;
  inline void clear_taint_id();
  static const int kTaintIdFieldNumber = 2;
  inline ::google::protobuf::uint64 taint_id() const;
  inline void set_taint_id(::google::protobuf::uint64 value);
  
  // optional bool taint_multiple = 3;
  inline bool has_taint_multiple() const;
  inline void clear_taint_multiple();
  static const int kTaintMultipleFieldNumber = 3;
  inline bool taint_multiple() const;
  inline void set_taint_multiple(bool value);
  
  // @@protoc_insertion_point(class_scope:taint_info)
 private:
  inline void set_has_no_taint();
  inline void clear_has_no_taint();
  inline void set_has_taint_id();
  inline void clear_has_taint_id();
  inline void set_has_taint_multiple();
  inline void clear_has_taint_multiple();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 taint_id_;
  bool no_taint_;
  bool taint_multiple_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static taint_info* default_instance_;
};
// -------------------------------------------------------------------

class std_frame : public ::google::protobuf::Message {
 public:
  std_frame();
  virtual ~std_frame();
  
  std_frame(const std_frame& from);
  
  inline std_frame& operator=(const std_frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const std_frame& default_instance();
  
  void Swap(std_frame* other);
  
  // implements Message ----------------------------------------------
  
  std_frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const std_frame& from);
  void MergeFrom(const std_frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline ::google::protobuf::uint64 address() const;
  inline void set_address(::google::protobuf::uint64 value);
  
  // required uint64 thread_id = 2;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 2;
  inline ::google::protobuf::uint64 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint64 value);
  
  // required bytes rawbytes = 3;
  inline bool has_rawbytes() const;
  inline void clear_rawbytes();
  static const int kRawbytesFieldNumber = 3;
  inline const ::std::string& rawbytes() const;
  inline void set_rawbytes(const ::std::string& value);
  inline void set_rawbytes(const char* value);
  inline void set_rawbytes(const void* value, size_t size);
  inline ::std::string* mutable_rawbytes();
  inline ::std::string* release_rawbytes();
  
  // required .operand_list operand_list = 4;
  inline bool has_operand_list() const;
  inline void clear_operand_list();
  static const int kOperandListFieldNumber = 4;
  inline const ::operand_list& operand_list() const;
  inline ::operand_list* mutable_operand_list();
  inline ::operand_list* release_operand_list();
  
  // @@protoc_insertion_point(class_scope:std_frame)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_rawbytes();
  inline void clear_has_rawbytes();
  inline void set_has_operand_list();
  inline void clear_has_operand_list();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 address_;
  ::google::protobuf::uint64 thread_id_;
  ::std::string* rawbytes_;
  ::operand_list* operand_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static std_frame* default_instance_;
};
// -------------------------------------------------------------------

class syscall_frame : public ::google::protobuf::Message {
 public:
  syscall_frame();
  virtual ~syscall_frame();
  
  syscall_frame(const syscall_frame& from);
  
  inline syscall_frame& operator=(const syscall_frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const syscall_frame& default_instance();
  
  void Swap(syscall_frame* other);
  
  // implements Message ----------------------------------------------
  
  syscall_frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const syscall_frame& from);
  void MergeFrom(const syscall_frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline ::google::protobuf::uint64 address() const;
  inline void set_address(::google::protobuf::uint64 value);
  
  // required uint64 thread_id = 2;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 2;
  inline ::google::protobuf::uint64 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint64 value);
  
  // required uint64 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::uint64 number() const;
  inline void set_number(::google::protobuf::uint64 value);
  
  // required .argument_list argument_list = 4;
  inline bool has_argument_list() const;
  inline void clear_argument_list();
  static const int kArgumentListFieldNumber = 4;
  inline const ::argument_list& argument_list() const;
  inline ::argument_list* mutable_argument_list();
  inline ::argument_list* release_argument_list();
  
  // @@protoc_insertion_point(class_scope:syscall_frame)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_argument_list();
  inline void clear_has_argument_list();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 address_;
  ::google::protobuf::uint64 thread_id_;
  ::google::protobuf::uint64 number_;
  ::argument_list* argument_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static syscall_frame* default_instance_;
};
// -------------------------------------------------------------------

class argument_list : public ::google::protobuf::Message {
 public:
  argument_list();
  virtual ~argument_list();
  
  argument_list(const argument_list& from);
  
  inline argument_list& operator=(const argument_list& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const argument_list& default_instance();
  
  void Swap(argument_list* other);
  
  // implements Message ----------------------------------------------
  
  argument_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const argument_list& from);
  void MergeFrom(const argument_list& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated sint64 elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline ::google::protobuf::int64 elem(int index) const;
  inline void set_elem(int index, ::google::protobuf::int64 value);
  inline void add_elem(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      elem() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_elem();
  
  // @@protoc_insertion_point(class_scope:argument_list)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > elem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static argument_list* default_instance_;
};
// -------------------------------------------------------------------

class exception_frame : public ::google::protobuf::Message {
 public:
  exception_frame();
  virtual ~exception_frame();
  
  exception_frame(const exception_frame& from);
  
  inline exception_frame& operator=(const exception_frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const exception_frame& default_instance();
  
  void Swap(exception_frame* other);
  
  // implements Message ----------------------------------------------
  
  exception_frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exception_frame& from);
  void MergeFrom(const exception_frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 exception_number = 1;
  inline bool has_exception_number() const;
  inline void clear_exception_number();
  static const int kExceptionNumberFieldNumber = 1;
  inline ::google::protobuf::uint64 exception_number() const;
  inline void set_exception_number(::google::protobuf::uint64 value);
  
  // optional uint64 thread_id = 2;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 2;
  inline ::google::protobuf::uint64 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint64 value);
  
  // optional uint64 from_addr = 3;
  inline bool has_from_addr() const;
  inline void clear_from_addr();
  static const int kFromAddrFieldNumber = 3;
  inline ::google::protobuf::uint64 from_addr() const;
  inline void set_from_addr(::google::protobuf::uint64 value);
  
  // optional uint64 to_addr = 4;
  inline bool has_to_addr() const;
  inline void clear_to_addr();
  static const int kToAddrFieldNumber = 4;
  inline ::google::protobuf::uint64 to_addr() const;
  inline void set_to_addr(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:exception_frame)
 private:
  inline void set_has_exception_number();
  inline void clear_has_exception_number();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_from_addr();
  inline void clear_has_from_addr();
  inline void set_has_to_addr();
  inline void clear_has_to_addr();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 exception_number_;
  ::google::protobuf::uint64 thread_id_;
  ::google::protobuf::uint64 from_addr_;
  ::google::protobuf::uint64 to_addr_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static exception_frame* default_instance_;
};
// -------------------------------------------------------------------

class taint_intro_frame : public ::google::protobuf::Message {
 public:
  taint_intro_frame();
  virtual ~taint_intro_frame();
  
  taint_intro_frame(const taint_intro_frame& from);
  
  inline taint_intro_frame& operator=(const taint_intro_frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const taint_intro_frame& default_instance();
  
  void Swap(taint_intro_frame* other);
  
  // implements Message ----------------------------------------------
  
  taint_intro_frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const taint_intro_frame& from);
  void MergeFrom(const taint_intro_frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .taint_intro_list taint_intro_list = 1;
  inline bool has_taint_intro_list() const;
  inline void clear_taint_intro_list();
  static const int kTaintIntroListFieldNumber = 1;
  inline const ::taint_intro_list& taint_intro_list() const;
  inline ::taint_intro_list* mutable_taint_intro_list();
  inline ::taint_intro_list* release_taint_intro_list();
  
  // @@protoc_insertion_point(class_scope:taint_intro_frame)
 private:
  inline void set_has_taint_intro_list();
  inline void clear_has_taint_intro_list();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::taint_intro_list* taint_intro_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static taint_intro_frame* default_instance_;
};
// -------------------------------------------------------------------

class taint_intro_list : public ::google::protobuf::Message {
 public:
  taint_intro_list();
  virtual ~taint_intro_list();
  
  taint_intro_list(const taint_intro_list& from);
  
  inline taint_intro_list& operator=(const taint_intro_list& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const taint_intro_list& default_instance();
  
  void Swap(taint_intro_list* other);
  
  // implements Message ----------------------------------------------
  
  taint_intro_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const taint_intro_list& from);
  void MergeFrom(const taint_intro_list& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .taint_intro elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::taint_intro& elem(int index) const;
  inline ::taint_intro* mutable_elem(int index);
  inline ::taint_intro* add_elem();
  inline const ::google::protobuf::RepeatedPtrField< ::taint_intro >&
      elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::taint_intro >*
      mutable_elem();
  
  // @@protoc_insertion_point(class_scope:taint_intro_list)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::taint_intro > elem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static taint_intro_list* default_instance_;
};
// -------------------------------------------------------------------

class taint_intro : public ::google::protobuf::Message {
 public:
  taint_intro();
  virtual ~taint_intro();
  
  taint_intro(const taint_intro& from);
  
  inline taint_intro& operator=(const taint_intro& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const taint_intro& default_instance();
  
  void Swap(taint_intro* other);
  
  // implements Message ----------------------------------------------
  
  taint_intro* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const taint_intro& from);
  void MergeFrom(const taint_intro& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline ::google::protobuf::uint64 addr() const;
  inline void set_addr(::google::protobuf::uint64 value);
  
  // required uint64 taint_id = 2;
  inline bool has_taint_id() const;
  inline void clear_taint_id();
  static const int kTaintIdFieldNumber = 2;
  inline ::google::protobuf::uint64 taint_id() const;
  inline void set_taint_id(::google::protobuf::uint64 value);
  
  // optional bytes value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // required string source_name = 4;
  inline bool has_source_name() const;
  inline void clear_source_name();
  static const int kSourceNameFieldNumber = 4;
  inline const ::std::string& source_name() const;
  inline void set_source_name(const ::std::string& value);
  inline void set_source_name(const char* value);
  inline void set_source_name(const char* value, size_t size);
  inline ::std::string* mutable_source_name();
  inline ::std::string* release_source_name();
  
  // required uint64 offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:taint_intro)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_taint_id();
  inline void clear_has_taint_id();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_source_name();
  inline void clear_has_source_name();
  inline void set_has_offset();
  inline void clear_has_offset();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 addr_;
  ::google::protobuf::uint64 taint_id_;
  ::std::string* value_;
  ::std::string* source_name_;
  ::google::protobuf::uint64 offset_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static taint_intro* default_instance_;
};
// -------------------------------------------------------------------

class modload_frame : public ::google::protobuf::Message {
 public:
  modload_frame();
  virtual ~modload_frame();
  
  modload_frame(const modload_frame& from);
  
  inline modload_frame& operator=(const modload_frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const modload_frame& default_instance();
  
  void Swap(modload_frame* other);
  
  // implements Message ----------------------------------------------
  
  modload_frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const modload_frame& from);
  void MergeFrom(const modload_frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string module_name = 1;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 1;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  
  // required uint64 low_address = 2;
  inline bool has_low_address() const;
  inline void clear_low_address();
  static const int kLowAddressFieldNumber = 2;
  inline ::google::protobuf::uint64 low_address() const;
  inline void set_low_address(::google::protobuf::uint64 value);
  
  // required uint64 high_address = 3;
  inline bool has_high_address() const;
  inline void clear_high_address();
  static const int kHighAddressFieldNumber = 3;
  inline ::google::protobuf::uint64 high_address() const;
  inline void set_high_address(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:modload_frame)
 private:
  inline void set_has_module_name();
  inline void clear_has_module_name();
  inline void set_has_low_address();
  inline void clear_has_low_address();
  inline void set_has_high_address();
  inline void clear_has_high_address();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* module_name_;
  ::google::protobuf::uint64 low_address_;
  ::google::protobuf::uint64 high_address_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static modload_frame* default_instance_;
};
// -------------------------------------------------------------------

class key_frame : public ::google::protobuf::Message {
 public:
  key_frame();
  virtual ~key_frame();
  
  key_frame(const key_frame& from);
  
  inline key_frame& operator=(const key_frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const key_frame& default_instance();
  
  void Swap(key_frame* other);
  
  // implements Message ----------------------------------------------
  
  key_frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const key_frame& from);
  void MergeFrom(const key_frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .tagged_value_lists tagged_value_lists = 1;
  inline bool has_tagged_value_lists() const;
  inline void clear_tagged_value_lists();
  static const int kTaggedValueListsFieldNumber = 1;
  inline const ::tagged_value_lists& tagged_value_lists() const;
  inline ::tagged_value_lists* mutable_tagged_value_lists();
  inline ::tagged_value_lists* release_tagged_value_lists();
  
  // @@protoc_insertion_point(class_scope:key_frame)
 private:
  inline void set_has_tagged_value_lists();
  inline void clear_has_tagged_value_lists();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::tagged_value_lists* tagged_value_lists_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static key_frame* default_instance_;
};
// -------------------------------------------------------------------

class tagged_value_lists : public ::google::protobuf::Message {
 public:
  tagged_value_lists();
  virtual ~tagged_value_lists();
  
  tagged_value_lists(const tagged_value_lists& from);
  
  inline tagged_value_lists& operator=(const tagged_value_lists& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const tagged_value_lists& default_instance();
  
  void Swap(tagged_value_lists* other);
  
  // implements Message ----------------------------------------------
  
  tagged_value_lists* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tagged_value_lists& from);
  void MergeFrom(const tagged_value_lists& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tagged_value_list elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::tagged_value_list& elem(int index) const;
  inline ::tagged_value_list* mutable_elem(int index);
  inline ::tagged_value_list* add_elem();
  inline const ::google::protobuf::RepeatedPtrField< ::tagged_value_list >&
      elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::tagged_value_list >*
      mutable_elem();
  
  // @@protoc_insertion_point(class_scope:tagged_value_lists)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::tagged_value_list > elem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static tagged_value_lists* default_instance_;
};
// -------------------------------------------------------------------

class tagged_value_list : public ::google::protobuf::Message {
 public:
  tagged_value_list();
  virtual ~tagged_value_list();
  
  tagged_value_list(const tagged_value_list& from);
  
  inline tagged_value_list& operator=(const tagged_value_list& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const tagged_value_list& default_instance();
  
  void Swap(tagged_value_list* other);
  
  // implements Message ----------------------------------------------
  
  tagged_value_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tagged_value_list& from);
  void MergeFrom(const tagged_value_list& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .value_source_tag value_source_tag = 1;
  inline bool has_value_source_tag() const;
  inline void clear_value_source_tag();
  static const int kValueSourceTagFieldNumber = 1;
  inline const ::value_source_tag& value_source_tag() const;
  inline ::value_source_tag* mutable_value_source_tag();
  inline ::value_source_tag* release_value_source_tag();
  
  // required .value_list value_list = 2;
  inline bool has_value_list() const;
  inline void clear_value_list();
  static const int kValueListFieldNumber = 2;
  inline const ::value_list& value_list() const;
  inline ::value_list* mutable_value_list();
  inline ::value_list* release_value_list();
  
  // @@protoc_insertion_point(class_scope:tagged_value_list)
 private:
  inline void set_has_value_source_tag();
  inline void clear_has_value_source_tag();
  inline void set_has_value_list();
  inline void clear_has_value_list();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::value_source_tag* value_source_tag_;
  ::value_list* value_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static tagged_value_list* default_instance_;
};
// -------------------------------------------------------------------

class value_source_tag : public ::google::protobuf::Message {
 public:
  value_source_tag();
  virtual ~value_source_tag();
  
  value_source_tag(const value_source_tag& from);
  
  inline value_source_tag& operator=(const value_source_tag& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const value_source_tag& default_instance();
  
  void Swap(value_source_tag* other);
  
  // implements Message ----------------------------------------------
  
  value_source_tag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const value_source_tag& from);
  void MergeFrom(const value_source_tag& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool no_thread_id = 1;
  inline bool has_no_thread_id() const;
  inline void clear_no_thread_id();
  static const int kNoThreadIdFieldNumber = 1;
  inline bool no_thread_id() const;
  inline void set_no_thread_id(bool value);
  
  // optional uint64 thread_id = 2;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 2;
  inline ::google::protobuf::uint64 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:value_source_tag)
 private:
  inline void set_has_no_thread_id();
  inline void clear_has_no_thread_id();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 thread_id_;
  bool no_thread_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static value_source_tag* default_instance_;
};
// -------------------------------------------------------------------

class value_list : public ::google::protobuf::Message {
 public:
  value_list();
  virtual ~value_list();
  
  value_list(const value_list& from);
  
  inline value_list& operator=(const value_list& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const value_list& default_instance();
  
  void Swap(value_list* other);
  
  // implements Message ----------------------------------------------
  
  value_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const value_list& from);
  void MergeFrom(const value_list& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .value_info elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::value_info& elem(int index) const;
  inline ::value_info* mutable_elem(int index);
  inline ::value_info* add_elem();
  inline const ::google::protobuf::RepeatedPtrField< ::value_info >&
      elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::value_info >*
      mutable_elem();
  
  // @@protoc_insertion_point(class_scope:value_list)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::value_info > elem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static value_list* default_instance_;
};
// -------------------------------------------------------------------

class value_info : public ::google::protobuf::Message {
 public:
  value_info();
  virtual ~value_info();
  
  value_info(const value_info& from);
  
  inline value_info& operator=(const value_info& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const value_info& default_instance();
  
  void Swap(value_info* other);
  
  // implements Message ----------------------------------------------
  
  value_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const value_info& from);
  void MergeFrom(const value_info& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .operand_info_specific operand_info_specific = 1;
  inline bool has_operand_info_specific() const;
  inline void clear_operand_info_specific();
  static const int kOperandInfoSpecificFieldNumber = 1;
  inline const ::operand_info_specific& operand_info_specific() const;
  inline ::operand_info_specific* mutable_operand_info_specific();
  inline ::operand_info_specific* release_operand_info_specific();
  
  // required sint32 bit_length = 2;
  inline bool has_bit_length() const;
  inline void clear_bit_length();
  static const int kBitLengthFieldNumber = 2;
  inline ::google::protobuf::int32 bit_length() const;
  inline void set_bit_length(::google::protobuf::int32 value);
  
  // optional .taint_info taint_info = 3;
  inline bool has_taint_info() const;
  inline void clear_taint_info();
  static const int kTaintInfoFieldNumber = 3;
  inline const ::taint_info& taint_info() const;
  inline ::taint_info* mutable_taint_info();
  inline ::taint_info* release_taint_info();
  
  // required bytes value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:value_info)
 private:
  inline void set_has_operand_info_specific();
  inline void clear_has_operand_info_specific();
  inline void set_has_bit_length();
  inline void clear_has_bit_length();
  inline void set_has_taint_info();
  inline void clear_has_taint_info();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::operand_info_specific* operand_info_specific_;
  ::taint_info* taint_info_;
  ::std::string* value_;
  ::google::protobuf::int32 bit_length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_frame_2epiqi_2eproto();
  friend void protobuf_AssignDesc_frame_2epiqi_2eproto();
  friend void protobuf_ShutdownFile_frame_2epiqi_2eproto();
  
  void InitAsDefaultInstance();
  static value_info* default_instance_;
};
// ===================================================================


// ===================================================================

// frame

// optional .std_frame std_frame = 1;
inline bool frame::has_std_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void frame::set_has_std_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void frame::clear_has_std_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void frame::clear_std_frame() {
  if (std_frame_ != NULL) std_frame_->::std_frame::Clear();
  clear_has_std_frame();
}
inline const ::std_frame& frame::std_frame() const {
  return std_frame_ != NULL ? *std_frame_ : *default_instance_->std_frame_;
}
inline ::std_frame* frame::mutable_std_frame() {
  set_has_std_frame();
  if (std_frame_ == NULL) std_frame_ = new ::std_frame;
  return std_frame_;
}
inline ::std_frame* frame::release_std_frame() {
  clear_has_std_frame();
  ::std_frame* temp = std_frame_;
  std_frame_ = NULL;
  return temp;
}

// optional .syscall_frame syscall_frame = 2;
inline bool frame::has_syscall_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void frame::set_has_syscall_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void frame::clear_has_syscall_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void frame::clear_syscall_frame() {
  if (syscall_frame_ != NULL) syscall_frame_->::syscall_frame::Clear();
  clear_has_syscall_frame();
}
inline const ::syscall_frame& frame::syscall_frame() const {
  return syscall_frame_ != NULL ? *syscall_frame_ : *default_instance_->syscall_frame_;
}
inline ::syscall_frame* frame::mutable_syscall_frame() {
  set_has_syscall_frame();
  if (syscall_frame_ == NULL) syscall_frame_ = new ::syscall_frame;
  return syscall_frame_;
}
inline ::syscall_frame* frame::release_syscall_frame() {
  clear_has_syscall_frame();
  ::syscall_frame* temp = syscall_frame_;
  syscall_frame_ = NULL;
  return temp;
}

// optional .exception_frame exception_frame = 3;
inline bool frame::has_exception_frame() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void frame::set_has_exception_frame() {
  _has_bits_[0] |= 0x00000004u;
}
inline void frame::clear_has_exception_frame() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void frame::clear_exception_frame() {
  if (exception_frame_ != NULL) exception_frame_->::exception_frame::Clear();
  clear_has_exception_frame();
}
inline const ::exception_frame& frame::exception_frame() const {
  return exception_frame_ != NULL ? *exception_frame_ : *default_instance_->exception_frame_;
}
inline ::exception_frame* frame::mutable_exception_frame() {
  set_has_exception_frame();
  if (exception_frame_ == NULL) exception_frame_ = new ::exception_frame;
  return exception_frame_;
}
inline ::exception_frame* frame::release_exception_frame() {
  clear_has_exception_frame();
  ::exception_frame* temp = exception_frame_;
  exception_frame_ = NULL;
  return temp;
}

// optional .taint_intro_frame taint_intro_frame = 4;
inline bool frame::has_taint_intro_frame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void frame::set_has_taint_intro_frame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void frame::clear_has_taint_intro_frame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void frame::clear_taint_intro_frame() {
  if (taint_intro_frame_ != NULL) taint_intro_frame_->::taint_intro_frame::Clear();
  clear_has_taint_intro_frame();
}
inline const ::taint_intro_frame& frame::taint_intro_frame() const {
  return taint_intro_frame_ != NULL ? *taint_intro_frame_ : *default_instance_->taint_intro_frame_;
}
inline ::taint_intro_frame* frame::mutable_taint_intro_frame() {
  set_has_taint_intro_frame();
  if (taint_intro_frame_ == NULL) taint_intro_frame_ = new ::taint_intro_frame;
  return taint_intro_frame_;
}
inline ::taint_intro_frame* frame::release_taint_intro_frame() {
  clear_has_taint_intro_frame();
  ::taint_intro_frame* temp = taint_intro_frame_;
  taint_intro_frame_ = NULL;
  return temp;
}

// optional .modload_frame modload_frame = 5;
inline bool frame::has_modload_frame() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void frame::set_has_modload_frame() {
  _has_bits_[0] |= 0x00000010u;
}
inline void frame::clear_has_modload_frame() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void frame::clear_modload_frame() {
  if (modload_frame_ != NULL) modload_frame_->::modload_frame::Clear();
  clear_has_modload_frame();
}
inline const ::modload_frame& frame::modload_frame() const {
  return modload_frame_ != NULL ? *modload_frame_ : *default_instance_->modload_frame_;
}
inline ::modload_frame* frame::mutable_modload_frame() {
  set_has_modload_frame();
  if (modload_frame_ == NULL) modload_frame_ = new ::modload_frame;
  return modload_frame_;
}
inline ::modload_frame* frame::release_modload_frame() {
  clear_has_modload_frame();
  ::modload_frame* temp = modload_frame_;
  modload_frame_ = NULL;
  return temp;
}

// optional .key_frame key_frame = 6;
inline bool frame::has_key_frame() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void frame::set_has_key_frame() {
  _has_bits_[0] |= 0x00000020u;
}
inline void frame::clear_has_key_frame() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void frame::clear_key_frame() {
  if (key_frame_ != NULL) key_frame_->::key_frame::Clear();
  clear_has_key_frame();
}
inline const ::key_frame& frame::key_frame() const {
  return key_frame_ != NULL ? *key_frame_ : *default_instance_->key_frame_;
}
inline ::key_frame* frame::mutable_key_frame() {
  set_has_key_frame();
  if (key_frame_ == NULL) key_frame_ = new ::key_frame;
  return key_frame_;
}
inline ::key_frame* frame::release_key_frame() {
  clear_has_key_frame();
  ::key_frame* temp = key_frame_;
  key_frame_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// operand_list

// repeated .operand_info elem = 1;
inline int operand_list::elem_size() const {
  return elem_.size();
}
inline void operand_list::clear_elem() {
  elem_.Clear();
}
inline const ::operand_info& operand_list::elem(int index) const {
  return elem_.Get(index);
}
inline ::operand_info* operand_list::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::operand_info* operand_list::add_elem() {
  return elem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operand_info >&
operand_list::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::operand_info >*
operand_list::mutable_elem() {
  return &elem_;
}

// -------------------------------------------------------------------

// operand_info

// required .operand_info_specific operand_info_specific = 1;
inline bool operand_info::has_operand_info_specific() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void operand_info::set_has_operand_info_specific() {
  _has_bits_[0] |= 0x00000001u;
}
inline void operand_info::clear_has_operand_info_specific() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void operand_info::clear_operand_info_specific() {
  if (operand_info_specific_ != NULL) operand_info_specific_->::operand_info_specific::Clear();
  clear_has_operand_info_specific();
}
inline const ::operand_info_specific& operand_info::operand_info_specific() const {
  return operand_info_specific_ != NULL ? *operand_info_specific_ : *default_instance_->operand_info_specific_;
}
inline ::operand_info_specific* operand_info::mutable_operand_info_specific() {
  set_has_operand_info_specific();
  if (operand_info_specific_ == NULL) operand_info_specific_ = new ::operand_info_specific;
  return operand_info_specific_;
}
inline ::operand_info_specific* operand_info::release_operand_info_specific() {
  clear_has_operand_info_specific();
  ::operand_info_specific* temp = operand_info_specific_;
  operand_info_specific_ = NULL;
  return temp;
}

// required sint32 bit_length = 2;
inline bool operand_info::has_bit_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void operand_info::set_has_bit_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void operand_info::clear_has_bit_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void operand_info::clear_bit_length() {
  bit_length_ = 0;
  clear_has_bit_length();
}
inline ::google::protobuf::int32 operand_info::bit_length() const {
  return bit_length_;
}
inline void operand_info::set_bit_length(::google::protobuf::int32 value) {
  set_has_bit_length();
  bit_length_ = value;
}

// required .operand_usage operand_usage = 3;
inline bool operand_info::has_operand_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void operand_info::set_has_operand_usage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void operand_info::clear_has_operand_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void operand_info::clear_operand_usage() {
  if (operand_usage_ != NULL) operand_usage_->::operand_usage::Clear();
  clear_has_operand_usage();
}
inline const ::operand_usage& operand_info::operand_usage() const {
  return operand_usage_ != NULL ? *operand_usage_ : *default_instance_->operand_usage_;
}
inline ::operand_usage* operand_info::mutable_operand_usage() {
  set_has_operand_usage();
  if (operand_usage_ == NULL) operand_usage_ = new ::operand_usage;
  return operand_usage_;
}
inline ::operand_usage* operand_info::release_operand_usage() {
  clear_has_operand_usage();
  ::operand_usage* temp = operand_usage_;
  operand_usage_ = NULL;
  return temp;
}

// required .taint_info taint_info = 4;
inline bool operand_info::has_taint_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void operand_info::set_has_taint_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void operand_info::clear_has_taint_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void operand_info::clear_taint_info() {
  if (taint_info_ != NULL) taint_info_->::taint_info::Clear();
  clear_has_taint_info();
}
inline const ::taint_info& operand_info::taint_info() const {
  return taint_info_ != NULL ? *taint_info_ : *default_instance_->taint_info_;
}
inline ::taint_info* operand_info::mutable_taint_info() {
  set_has_taint_info();
  if (taint_info_ == NULL) taint_info_ = new ::taint_info;
  return taint_info_;
}
inline ::taint_info* operand_info::release_taint_info() {
  clear_has_taint_info();
  ::taint_info* temp = taint_info_;
  taint_info_ = NULL;
  return temp;
}

// required bytes value = 5;
inline bool operand_info::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void operand_info::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void operand_info::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void operand_info::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& operand_info::value() const {
  return *value_;
}
inline void operand_info::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void operand_info::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void operand_info::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* operand_info::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* operand_info::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// operand_info_specific

// optional .mem_operand mem_operand = 1;
inline bool operand_info_specific::has_mem_operand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void operand_info_specific::set_has_mem_operand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void operand_info_specific::clear_has_mem_operand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void operand_info_specific::clear_mem_operand() {
  if (mem_operand_ != NULL) mem_operand_->::mem_operand::Clear();
  clear_has_mem_operand();
}
inline const ::mem_operand& operand_info_specific::mem_operand() const {
  return mem_operand_ != NULL ? *mem_operand_ : *default_instance_->mem_operand_;
}
inline ::mem_operand* operand_info_specific::mutable_mem_operand() {
  set_has_mem_operand();
  if (mem_operand_ == NULL) mem_operand_ = new ::mem_operand;
  return mem_operand_;
}
inline ::mem_operand* operand_info_specific::release_mem_operand() {
  clear_has_mem_operand();
  ::mem_operand* temp = mem_operand_;
  mem_operand_ = NULL;
  return temp;
}

// optional .reg_operand reg_operand = 2;
inline bool operand_info_specific::has_reg_operand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void operand_info_specific::set_has_reg_operand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void operand_info_specific::clear_has_reg_operand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void operand_info_specific::clear_reg_operand() {
  if (reg_operand_ != NULL) reg_operand_->::reg_operand::Clear();
  clear_has_reg_operand();
}
inline const ::reg_operand& operand_info_specific::reg_operand() const {
  return reg_operand_ != NULL ? *reg_operand_ : *default_instance_->reg_operand_;
}
inline ::reg_operand* operand_info_specific::mutable_reg_operand() {
  set_has_reg_operand();
  if (reg_operand_ == NULL) reg_operand_ = new ::reg_operand;
  return reg_operand_;
}
inline ::reg_operand* operand_info_specific::release_reg_operand() {
  clear_has_reg_operand();
  ::reg_operand* temp = reg_operand_;
  reg_operand_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// reg_operand

// required string name = 1;
inline bool reg_operand::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reg_operand::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reg_operand::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reg_operand::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& reg_operand::name() const {
  return *name_;
}
inline void reg_operand::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void reg_operand::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void reg_operand::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* reg_operand::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* reg_operand::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// mem_operand

// required uint64 address = 1;
inline bool mem_operand::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mem_operand::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mem_operand::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mem_operand::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 mem_operand::address() const {
  return address_;
}
inline void mem_operand::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
}

// -------------------------------------------------------------------

// operand_usage

// required bool read = 1;
inline bool operand_usage::has_read() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void operand_usage::set_has_read() {
  _has_bits_[0] |= 0x00000001u;
}
inline void operand_usage::clear_has_read() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void operand_usage::clear_read() {
  read_ = false;
  clear_has_read();
}
inline bool operand_usage::read() const {
  return read_;
}
inline void operand_usage::set_read(bool value) {
  set_has_read();
  read_ = value;
}

// required bool written = 2;
inline bool operand_usage::has_written() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void operand_usage::set_has_written() {
  _has_bits_[0] |= 0x00000002u;
}
inline void operand_usage::clear_has_written() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void operand_usage::clear_written() {
  written_ = false;
  clear_has_written();
}
inline bool operand_usage::written() const {
  return written_;
}
inline void operand_usage::set_written(bool value) {
  set_has_written();
  written_ = value;
}

// required bool index = 3;
inline bool operand_usage::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void operand_usage::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void operand_usage::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void operand_usage::clear_index() {
  index_ = false;
  clear_has_index();
}
inline bool operand_usage::index() const {
  return index_;
}
inline void operand_usage::set_index(bool value) {
  set_has_index();
  index_ = value;
}

// required bool base = 4;
inline bool operand_usage::has_base() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void operand_usage::set_has_base() {
  _has_bits_[0] |= 0x00000008u;
}
inline void operand_usage::clear_has_base() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void operand_usage::clear_base() {
  base_ = false;
  clear_has_base();
}
inline bool operand_usage::base() const {
  return base_;
}
inline void operand_usage::set_base(bool value) {
  set_has_base();
  base_ = value;
}

// -------------------------------------------------------------------

// taint_info

// optional bool no_taint = 1;
inline bool taint_info::has_no_taint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void taint_info::set_has_no_taint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void taint_info::clear_has_no_taint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void taint_info::clear_no_taint() {
  no_taint_ = false;
  clear_has_no_taint();
}
inline bool taint_info::no_taint() const {
  return no_taint_;
}
inline void taint_info::set_no_taint(bool value) {
  set_has_no_taint();
  no_taint_ = value;
}

// optional uint64 taint_id = 2;
inline bool taint_info::has_taint_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void taint_info::set_has_taint_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void taint_info::clear_has_taint_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void taint_info::clear_taint_id() {
  taint_id_ = GOOGLE_ULONGLONG(0);
  clear_has_taint_id();
}
inline ::google::protobuf::uint64 taint_info::taint_id() const {
  return taint_id_;
}
inline void taint_info::set_taint_id(::google::protobuf::uint64 value) {
  set_has_taint_id();
  taint_id_ = value;
}

// optional bool taint_multiple = 3;
inline bool taint_info::has_taint_multiple() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void taint_info::set_has_taint_multiple() {
  _has_bits_[0] |= 0x00000004u;
}
inline void taint_info::clear_has_taint_multiple() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void taint_info::clear_taint_multiple() {
  taint_multiple_ = false;
  clear_has_taint_multiple();
}
inline bool taint_info::taint_multiple() const {
  return taint_multiple_;
}
inline void taint_info::set_taint_multiple(bool value) {
  set_has_taint_multiple();
  taint_multiple_ = value;
}

// -------------------------------------------------------------------

// std_frame

// required uint64 address = 1;
inline bool std_frame::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void std_frame::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void std_frame::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void std_frame::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 std_frame::address() const {
  return address_;
}
inline void std_frame::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
}

// required uint64 thread_id = 2;
inline bool std_frame::has_thread_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void std_frame::set_has_thread_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void std_frame::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void std_frame::clear_thread_id() {
  thread_id_ = GOOGLE_ULONGLONG(0);
  clear_has_thread_id();
}
inline ::google::protobuf::uint64 std_frame::thread_id() const {
  return thread_id_;
}
inline void std_frame::set_thread_id(::google::protobuf::uint64 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// required bytes rawbytes = 3;
inline bool std_frame::has_rawbytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void std_frame::set_has_rawbytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void std_frame::clear_has_rawbytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void std_frame::clear_rawbytes() {
  if (rawbytes_ != &::google::protobuf::internal::kEmptyString) {
    rawbytes_->clear();
  }
  clear_has_rawbytes();
}
inline const ::std::string& std_frame::rawbytes() const {
  return *rawbytes_;
}
inline void std_frame::set_rawbytes(const ::std::string& value) {
  set_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    rawbytes_ = new ::std::string;
  }
  rawbytes_->assign(value);
}
inline void std_frame::set_rawbytes(const char* value) {
  set_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    rawbytes_ = new ::std::string;
  }
  rawbytes_->assign(value);
}
inline void std_frame::set_rawbytes(const void* value, size_t size) {
  set_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    rawbytes_ = new ::std::string;
  }
  rawbytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* std_frame::mutable_rawbytes() {
  set_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    rawbytes_ = new ::std::string;
  }
  return rawbytes_;
}
inline ::std::string* std_frame::release_rawbytes() {
  clear_has_rawbytes();
  if (rawbytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rawbytes_;
    rawbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .operand_list operand_list = 4;
inline bool std_frame::has_operand_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void std_frame::set_has_operand_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void std_frame::clear_has_operand_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void std_frame::clear_operand_list() {
  if (operand_list_ != NULL) operand_list_->::operand_list::Clear();
  clear_has_operand_list();
}
inline const ::operand_list& std_frame::operand_list() const {
  return operand_list_ != NULL ? *operand_list_ : *default_instance_->operand_list_;
}
inline ::operand_list* std_frame::mutable_operand_list() {
  set_has_operand_list();
  if (operand_list_ == NULL) operand_list_ = new ::operand_list;
  return operand_list_;
}
inline ::operand_list* std_frame::release_operand_list() {
  clear_has_operand_list();
  ::operand_list* temp = operand_list_;
  operand_list_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// syscall_frame

// required uint64 address = 1;
inline bool syscall_frame::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void syscall_frame::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void syscall_frame::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void syscall_frame::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 syscall_frame::address() const {
  return address_;
}
inline void syscall_frame::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
}

// required uint64 thread_id = 2;
inline bool syscall_frame::has_thread_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void syscall_frame::set_has_thread_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void syscall_frame::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void syscall_frame::clear_thread_id() {
  thread_id_ = GOOGLE_ULONGLONG(0);
  clear_has_thread_id();
}
inline ::google::protobuf::uint64 syscall_frame::thread_id() const {
  return thread_id_;
}
inline void syscall_frame::set_thread_id(::google::protobuf::uint64 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// required uint64 number = 3;
inline bool syscall_frame::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void syscall_frame::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void syscall_frame::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void syscall_frame::clear_number() {
  number_ = GOOGLE_ULONGLONG(0);
  clear_has_number();
}
inline ::google::protobuf::uint64 syscall_frame::number() const {
  return number_;
}
inline void syscall_frame::set_number(::google::protobuf::uint64 value) {
  set_has_number();
  number_ = value;
}

// required .argument_list argument_list = 4;
inline bool syscall_frame::has_argument_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void syscall_frame::set_has_argument_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void syscall_frame::clear_has_argument_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void syscall_frame::clear_argument_list() {
  if (argument_list_ != NULL) argument_list_->::argument_list::Clear();
  clear_has_argument_list();
}
inline const ::argument_list& syscall_frame::argument_list() const {
  return argument_list_ != NULL ? *argument_list_ : *default_instance_->argument_list_;
}
inline ::argument_list* syscall_frame::mutable_argument_list() {
  set_has_argument_list();
  if (argument_list_ == NULL) argument_list_ = new ::argument_list;
  return argument_list_;
}
inline ::argument_list* syscall_frame::release_argument_list() {
  clear_has_argument_list();
  ::argument_list* temp = argument_list_;
  argument_list_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// argument_list

// repeated sint64 elem = 1;
inline int argument_list::elem_size() const {
  return elem_.size();
}
inline void argument_list::clear_elem() {
  elem_.Clear();
}
inline ::google::protobuf::int64 argument_list::elem(int index) const {
  return elem_.Get(index);
}
inline void argument_list::set_elem(int index, ::google::protobuf::int64 value) {
  elem_.Set(index, value);
}
inline void argument_list::add_elem(::google::protobuf::int64 value) {
  elem_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
argument_list::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
argument_list::mutable_elem() {
  return &elem_;
}

// -------------------------------------------------------------------

// exception_frame

// required uint64 exception_number = 1;
inline bool exception_frame::has_exception_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exception_frame::set_has_exception_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exception_frame::clear_has_exception_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exception_frame::clear_exception_number() {
  exception_number_ = GOOGLE_ULONGLONG(0);
  clear_has_exception_number();
}
inline ::google::protobuf::uint64 exception_frame::exception_number() const {
  return exception_number_;
}
inline void exception_frame::set_exception_number(::google::protobuf::uint64 value) {
  set_has_exception_number();
  exception_number_ = value;
}

// optional uint64 thread_id = 2;
inline bool exception_frame::has_thread_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exception_frame::set_has_thread_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exception_frame::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exception_frame::clear_thread_id() {
  thread_id_ = GOOGLE_ULONGLONG(0);
  clear_has_thread_id();
}
inline ::google::protobuf::uint64 exception_frame::thread_id() const {
  return thread_id_;
}
inline void exception_frame::set_thread_id(::google::protobuf::uint64 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// optional uint64 from_addr = 3;
inline bool exception_frame::has_from_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void exception_frame::set_has_from_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void exception_frame::clear_has_from_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void exception_frame::clear_from_addr() {
  from_addr_ = GOOGLE_ULONGLONG(0);
  clear_has_from_addr();
}
inline ::google::protobuf::uint64 exception_frame::from_addr() const {
  return from_addr_;
}
inline void exception_frame::set_from_addr(::google::protobuf::uint64 value) {
  set_has_from_addr();
  from_addr_ = value;
}

// optional uint64 to_addr = 4;
inline bool exception_frame::has_to_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void exception_frame::set_has_to_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void exception_frame::clear_has_to_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void exception_frame::clear_to_addr() {
  to_addr_ = GOOGLE_ULONGLONG(0);
  clear_has_to_addr();
}
inline ::google::protobuf::uint64 exception_frame::to_addr() const {
  return to_addr_;
}
inline void exception_frame::set_to_addr(::google::protobuf::uint64 value) {
  set_has_to_addr();
  to_addr_ = value;
}

// -------------------------------------------------------------------

// taint_intro_frame

// required .taint_intro_list taint_intro_list = 1;
inline bool taint_intro_frame::has_taint_intro_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void taint_intro_frame::set_has_taint_intro_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void taint_intro_frame::clear_has_taint_intro_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void taint_intro_frame::clear_taint_intro_list() {
  if (taint_intro_list_ != NULL) taint_intro_list_->::taint_intro_list::Clear();
  clear_has_taint_intro_list();
}
inline const ::taint_intro_list& taint_intro_frame::taint_intro_list() const {
  return taint_intro_list_ != NULL ? *taint_intro_list_ : *default_instance_->taint_intro_list_;
}
inline ::taint_intro_list* taint_intro_frame::mutable_taint_intro_list() {
  set_has_taint_intro_list();
  if (taint_intro_list_ == NULL) taint_intro_list_ = new ::taint_intro_list;
  return taint_intro_list_;
}
inline ::taint_intro_list* taint_intro_frame::release_taint_intro_list() {
  clear_has_taint_intro_list();
  ::taint_intro_list* temp = taint_intro_list_;
  taint_intro_list_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// taint_intro_list

// repeated .taint_intro elem = 1;
inline int taint_intro_list::elem_size() const {
  return elem_.size();
}
inline void taint_intro_list::clear_elem() {
  elem_.Clear();
}
inline const ::taint_intro& taint_intro_list::elem(int index) const {
  return elem_.Get(index);
}
inline ::taint_intro* taint_intro_list::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::taint_intro* taint_intro_list::add_elem() {
  return elem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::taint_intro >&
taint_intro_list::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::taint_intro >*
taint_intro_list::mutable_elem() {
  return &elem_;
}

// -------------------------------------------------------------------

// taint_intro

// required uint64 addr = 1;
inline bool taint_intro::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void taint_intro::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void taint_intro::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void taint_intro::clear_addr() {
  addr_ = GOOGLE_ULONGLONG(0);
  clear_has_addr();
}
inline ::google::protobuf::uint64 taint_intro::addr() const {
  return addr_;
}
inline void taint_intro::set_addr(::google::protobuf::uint64 value) {
  set_has_addr();
  addr_ = value;
}

// required uint64 taint_id = 2;
inline bool taint_intro::has_taint_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void taint_intro::set_has_taint_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void taint_intro::clear_has_taint_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void taint_intro::clear_taint_id() {
  taint_id_ = GOOGLE_ULONGLONG(0);
  clear_has_taint_id();
}
inline ::google::protobuf::uint64 taint_intro::taint_id() const {
  return taint_id_;
}
inline void taint_intro::set_taint_id(::google::protobuf::uint64 value) {
  set_has_taint_id();
  taint_id_ = value;
}

// optional bytes value = 3;
inline bool taint_intro::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void taint_intro::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void taint_intro::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void taint_intro::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& taint_intro::value() const {
  return *value_;
}
inline void taint_intro::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void taint_intro::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void taint_intro::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* taint_intro::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* taint_intro::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string source_name = 4;
inline bool taint_intro::has_source_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void taint_intro::set_has_source_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void taint_intro::clear_has_source_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void taint_intro::clear_source_name() {
  if (source_name_ != &::google::protobuf::internal::kEmptyString) {
    source_name_->clear();
  }
  clear_has_source_name();
}
inline const ::std::string& taint_intro::source_name() const {
  return *source_name_;
}
inline void taint_intro::set_source_name(const ::std::string& value) {
  set_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    source_name_ = new ::std::string;
  }
  source_name_->assign(value);
}
inline void taint_intro::set_source_name(const char* value) {
  set_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    source_name_ = new ::std::string;
  }
  source_name_->assign(value);
}
inline void taint_intro::set_source_name(const char* value, size_t size) {
  set_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    source_name_ = new ::std::string;
  }
  source_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* taint_intro::mutable_source_name() {
  set_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    source_name_ = new ::std::string;
  }
  return source_name_;
}
inline ::std::string* taint_intro::release_source_name() {
  clear_has_source_name();
  if (source_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_name_;
    source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 offset = 5;
inline bool taint_intro::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void taint_intro::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void taint_intro::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void taint_intro::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 taint_intro::offset() const {
  return offset_;
}
inline void taint_intro::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// modload_frame

// required string module_name = 1;
inline bool modload_frame::has_module_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void modload_frame::set_has_module_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void modload_frame::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void modload_frame::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& modload_frame::module_name() const {
  return *module_name_;
}
inline void modload_frame::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void modload_frame::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void modload_frame::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* modload_frame::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* modload_frame::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 low_address = 2;
inline bool modload_frame::has_low_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void modload_frame::set_has_low_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void modload_frame::clear_has_low_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void modload_frame::clear_low_address() {
  low_address_ = GOOGLE_ULONGLONG(0);
  clear_has_low_address();
}
inline ::google::protobuf::uint64 modload_frame::low_address() const {
  return low_address_;
}
inline void modload_frame::set_low_address(::google::protobuf::uint64 value) {
  set_has_low_address();
  low_address_ = value;
}

// required uint64 high_address = 3;
inline bool modload_frame::has_high_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void modload_frame::set_has_high_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void modload_frame::clear_has_high_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void modload_frame::clear_high_address() {
  high_address_ = GOOGLE_ULONGLONG(0);
  clear_has_high_address();
}
inline ::google::protobuf::uint64 modload_frame::high_address() const {
  return high_address_;
}
inline void modload_frame::set_high_address(::google::protobuf::uint64 value) {
  set_has_high_address();
  high_address_ = value;
}

// -------------------------------------------------------------------

// key_frame

// required .tagged_value_lists tagged_value_lists = 1;
inline bool key_frame::has_tagged_value_lists() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void key_frame::set_has_tagged_value_lists() {
  _has_bits_[0] |= 0x00000001u;
}
inline void key_frame::clear_has_tagged_value_lists() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void key_frame::clear_tagged_value_lists() {
  if (tagged_value_lists_ != NULL) tagged_value_lists_->::tagged_value_lists::Clear();
  clear_has_tagged_value_lists();
}
inline const ::tagged_value_lists& key_frame::tagged_value_lists() const {
  return tagged_value_lists_ != NULL ? *tagged_value_lists_ : *default_instance_->tagged_value_lists_;
}
inline ::tagged_value_lists* key_frame::mutable_tagged_value_lists() {
  set_has_tagged_value_lists();
  if (tagged_value_lists_ == NULL) tagged_value_lists_ = new ::tagged_value_lists;
  return tagged_value_lists_;
}
inline ::tagged_value_lists* key_frame::release_tagged_value_lists() {
  clear_has_tagged_value_lists();
  ::tagged_value_lists* temp = tagged_value_lists_;
  tagged_value_lists_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// tagged_value_lists

// repeated .tagged_value_list elem = 1;
inline int tagged_value_lists::elem_size() const {
  return elem_.size();
}
inline void tagged_value_lists::clear_elem() {
  elem_.Clear();
}
inline const ::tagged_value_list& tagged_value_lists::elem(int index) const {
  return elem_.Get(index);
}
inline ::tagged_value_list* tagged_value_lists::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::tagged_value_list* tagged_value_lists::add_elem() {
  return elem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tagged_value_list >&
tagged_value_lists::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::tagged_value_list >*
tagged_value_lists::mutable_elem() {
  return &elem_;
}

// -------------------------------------------------------------------

// tagged_value_list

// required .value_source_tag value_source_tag = 1;
inline bool tagged_value_list::has_value_source_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tagged_value_list::set_has_value_source_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tagged_value_list::clear_has_value_source_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tagged_value_list::clear_value_source_tag() {
  if (value_source_tag_ != NULL) value_source_tag_->::value_source_tag::Clear();
  clear_has_value_source_tag();
}
inline const ::value_source_tag& tagged_value_list::value_source_tag() const {
  return value_source_tag_ != NULL ? *value_source_tag_ : *default_instance_->value_source_tag_;
}
inline ::value_source_tag* tagged_value_list::mutable_value_source_tag() {
  set_has_value_source_tag();
  if (value_source_tag_ == NULL) value_source_tag_ = new ::value_source_tag;
  return value_source_tag_;
}
inline ::value_source_tag* tagged_value_list::release_value_source_tag() {
  clear_has_value_source_tag();
  ::value_source_tag* temp = value_source_tag_;
  value_source_tag_ = NULL;
  return temp;
}

// required .value_list value_list = 2;
inline bool tagged_value_list::has_value_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tagged_value_list::set_has_value_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tagged_value_list::clear_has_value_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tagged_value_list::clear_value_list() {
  if (value_list_ != NULL) value_list_->::value_list::Clear();
  clear_has_value_list();
}
inline const ::value_list& tagged_value_list::value_list() const {
  return value_list_ != NULL ? *value_list_ : *default_instance_->value_list_;
}
inline ::value_list* tagged_value_list::mutable_value_list() {
  set_has_value_list();
  if (value_list_ == NULL) value_list_ = new ::value_list;
  return value_list_;
}
inline ::value_list* tagged_value_list::release_value_list() {
  clear_has_value_list();
  ::value_list* temp = value_list_;
  value_list_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// value_source_tag

// optional bool no_thread_id = 1;
inline bool value_source_tag::has_no_thread_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void value_source_tag::set_has_no_thread_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void value_source_tag::clear_has_no_thread_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void value_source_tag::clear_no_thread_id() {
  no_thread_id_ = false;
  clear_has_no_thread_id();
}
inline bool value_source_tag::no_thread_id() const {
  return no_thread_id_;
}
inline void value_source_tag::set_no_thread_id(bool value) {
  set_has_no_thread_id();
  no_thread_id_ = value;
}

// optional uint64 thread_id = 2;
inline bool value_source_tag::has_thread_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void value_source_tag::set_has_thread_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void value_source_tag::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void value_source_tag::clear_thread_id() {
  thread_id_ = GOOGLE_ULONGLONG(0);
  clear_has_thread_id();
}
inline ::google::protobuf::uint64 value_source_tag::thread_id() const {
  return thread_id_;
}
inline void value_source_tag::set_thread_id(::google::protobuf::uint64 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// -------------------------------------------------------------------

// value_list

// repeated .value_info elem = 1;
inline int value_list::elem_size() const {
  return elem_.size();
}
inline void value_list::clear_elem() {
  elem_.Clear();
}
inline const ::value_info& value_list::elem(int index) const {
  return elem_.Get(index);
}
inline ::value_info* value_list::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::value_info* value_list::add_elem() {
  return elem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::value_info >&
value_list::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::value_info >*
value_list::mutable_elem() {
  return &elem_;
}

// -------------------------------------------------------------------

// value_info

// required .operand_info_specific operand_info_specific = 1;
inline bool value_info::has_operand_info_specific() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void value_info::set_has_operand_info_specific() {
  _has_bits_[0] |= 0x00000001u;
}
inline void value_info::clear_has_operand_info_specific() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void value_info::clear_operand_info_specific() {
  if (operand_info_specific_ != NULL) operand_info_specific_->::operand_info_specific::Clear();
  clear_has_operand_info_specific();
}
inline const ::operand_info_specific& value_info::operand_info_specific() const {
  return operand_info_specific_ != NULL ? *operand_info_specific_ : *default_instance_->operand_info_specific_;
}
inline ::operand_info_specific* value_info::mutable_operand_info_specific() {
  set_has_operand_info_specific();
  if (operand_info_specific_ == NULL) operand_info_specific_ = new ::operand_info_specific;
  return operand_info_specific_;
}
inline ::operand_info_specific* value_info::release_operand_info_specific() {
  clear_has_operand_info_specific();
  ::operand_info_specific* temp = operand_info_specific_;
  operand_info_specific_ = NULL;
  return temp;
}

// required sint32 bit_length = 2;
inline bool value_info::has_bit_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void value_info::set_has_bit_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void value_info::clear_has_bit_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void value_info::clear_bit_length() {
  bit_length_ = 0;
  clear_has_bit_length();
}
inline ::google::protobuf::int32 value_info::bit_length() const {
  return bit_length_;
}
inline void value_info::set_bit_length(::google::protobuf::int32 value) {
  set_has_bit_length();
  bit_length_ = value;
}

// optional .taint_info taint_info = 3;
inline bool value_info::has_taint_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void value_info::set_has_taint_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void value_info::clear_has_taint_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void value_info::clear_taint_info() {
  if (taint_info_ != NULL) taint_info_->::taint_info::Clear();
  clear_has_taint_info();
}
inline const ::taint_info& value_info::taint_info() const {
  return taint_info_ != NULL ? *taint_info_ : *default_instance_->taint_info_;
}
inline ::taint_info* value_info::mutable_taint_info() {
  set_has_taint_info();
  if (taint_info_ == NULL) taint_info_ = new ::taint_info;
  return taint_info_;
}
inline ::taint_info* value_info::release_taint_info() {
  clear_has_taint_info();
  ::taint_info* temp = taint_info_;
  taint_info_ = NULL;
  return temp;
}

// required bytes value = 4;
inline bool value_info::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void value_info::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void value_info::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void value_info::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& value_info::value() const {
  return *value_;
}
inline void value_info::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void value_info::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void value_info::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* value_info::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* value_info::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_frame_2epiqi_2eproto__INCLUDED
